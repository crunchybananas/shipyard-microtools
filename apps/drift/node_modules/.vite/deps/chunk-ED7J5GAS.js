import {
  OWNER,
  getOwner,
  setOwner
} from "./chunk-RS7R57CN.js";
import {
  ALLOW_CYCLES,
  CONSTANT_TAG,
  CURRENT_TAG,
  UPDATE_TAG,
  combine,
  consumeTag,
  createUpdatableTag,
  destroy,
  dirtyTagFor,
  getCustomTagFor,
  hasInternalComponentManager,
  isDestroyed,
  isDestroying,
  isTracking,
  registerDestructor,
  setCustomTagFor,
  tagFor,
  tagMetaFor,
  track,
  trackedData,
  untrack,
  validateTag,
  valueForTag
} from "./chunk-HJOPXKLZ.js";
import {
  __publicField
} from "./chunk-JXSOYYVP.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/index-BGP1rw3B.js
var hasDOM = typeof self === "object" && self !== null && self.Object === Object && typeof Window !== "undefined" && self.constructor === Window && typeof document === "object" && document !== null && self.document === document && typeof location === "object" && location !== null && self.location === location && typeof history === "object" && history !== null && self.history === history && typeof navigator === "object" && navigator !== null && self.navigator === navigator && typeof navigator.userAgent === "string";
var window2 = hasDOM ? self : null;
var location$1 = hasDOM ? self.location : null;
var history$1 = hasDOM ? self.history : null;
var userAgent = hasDOM ? self.navigator.userAgent : "Lynx (textmode)";
var isChrome = hasDOM ? typeof chrome === "object" && !(typeof opera === "object") : false;
var isFirefox = hasDOM ? /Firefox|FxiOS/.test(userAgent) : false;
var environment = Object.freeze(Object.defineProperty({
  __proto__: null,
  hasDOM,
  history: history$1,
  isChrome,
  isFirefox,
  location: location$1,
  userAgent,
  window: window2
}, Symbol.toStringTag, {
  value: "Module"
}));

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/env-DxZ20QzS.js
function checkGlobal(value) {
  return value && value.Object === Object ? value : void 0;
}
function checkElementIdShadowing(value) {
  return value && value.nodeType === void 0 ? value : void 0;
}
var global$1 = checkGlobal(checkElementIdShadowing(typeof global === "object" && global)) || checkGlobal(typeof self === "object" && self) || checkGlobal(typeof window === "object" && window) || typeof mainContext !== "undefined" && mainContext || // set before strict mode in Ember loader/wrapper
new Function("return this")();
var context = (function(global2, Ember) {
  return Ember === void 0 ? {
    imports: global2,
    exports: global2,
    lookup: global2
  } : {
    // import jQuery
    imports: Ember.imports || global2,
    // export Ember
    exports: Ember.exports || global2,
    // search for Namespaces
    lookup: Ember.lookup || global2
  };
})(global$1, global$1.Ember);
var ENV = {
  ENABLE_OPTIONAL_FEATURES: false,
  /**
    Determines whether Ember should add to `Array`
    native object prototypes, a few extra methods in order to provide a more
    friendly API.
     The behavior from setting this option to `true` was deprecated in Ember 5.10.
     @property EXTEND_PROTOTYPES
    @type Boolean
    @default true
    @for EmberENV
    @private
    @deprecated in v5.10
  */
  EXTEND_PROTOTYPES: {
    Array: false
  },
  /**
    The `LOG_STACKTRACE_ON_DEPRECATION` property, when true, tells Ember to log
    a full stack trace during deprecation warnings.
     @property LOG_STACKTRACE_ON_DEPRECATION
    @type Boolean
    @default true
    @for EmberENV
    @public
  */
  LOG_STACKTRACE_ON_DEPRECATION: true,
  /**
    The `LOG_VERSION` property, when true, tells Ember to log versions of all
    dependent libraries in use.
     @property LOG_VERSION
    @type Boolean
    @default true
    @for EmberENV
    @public
  */
  LOG_VERSION: true,
  RAISE_ON_DEPRECATION: false,
  STRUCTURED_PROFILE: false,
  /**
    Whether to perform extra bookkeeping needed to make the `captureRenderTree`
    API work.
     This has to be set before the ember JavaScript code is evaluated. This is
    usually done by setting `window.EmberENV = { _DEBUG_RENDER_TREE: true };`
    before the "vendor" `<script>` tag in `index.html`.
     Setting the flag after Ember is already loaded will not work correctly. It
    may appear to work somewhat, but fundamentally broken.
     This is not intended to be set directly. Ember Inspector will enable the
    flag on behalf of the user as needed.
     This flag is always on in development mode.
     The flag is off by default in production mode, due to the cost associated
    with the the bookkeeping work.
     The expected flow is that Ember Inspector will ask the user to refresh the
    page after enabling the feature. It could also offer a feature where the
    user add some domains to the "always on" list. In either case, Ember
    Inspector will inject the code on the page to set the flag if needed.
     @property _DEBUG_RENDER_TREE
    @for EmberENV
    @type Boolean
    @default false
    @private
  */
  _DEBUG_RENDER_TREE: true,
  /**
   Whether to force all deprecations to be enabled. This is used internally by
   Ember to enable deprecations in tests. It is not intended to be set in
   projects.
    @property _ALL_DEPRECATIONS_ENABLED
   @for EmberENV
   @type Boolean
   @default false
   @private
   */
  _ALL_DEPRECATIONS_ENABLED: false,
  /**
   Override the version of ember-source used to determine when deprecations "break".
   This is used internally by Ember to test with deprecated features "removed".
   This is never intended to be set by projects.
   @property _OVERRIDE_DEPRECATION_VERSION
   @for EmberENV
   @type string | null
   @default null
   @private
   */
  _OVERRIDE_DEPRECATION_VERSION: null,
  /**
    Whether the app defaults to using async observers.
     This is not intended to be set directly, as the implementation may change in
    the future. Use `@ember/optional-features` instead.
     @property _DEFAULT_ASYNC_OBSERVERS
    @for EmberENV
    @type Boolean
    @default false
    @private
  */
  _DEFAULT_ASYNC_OBSERVERS: false,
  /**
    Controls the maximum number of scheduled rerenders without "settling". In general,
    applications should not need to modify this environment variable, but please
    open an issue so that we can determine if a better default value is needed.
     @property _RERENDER_LOOP_LIMIT
    @for EmberENV
    @type number
    @default 1000
    @private
   */
  _RERENDER_LOOP_LIMIT: 1e3,
  EMBER_LOAD_HOOKS: {},
  FEATURES: {}
};
((EmberENV) => {
  if (typeof EmberENV !== "object" || EmberENV === null) return;
  for (let flag in EmberENV) {
    if (!Object.prototype.hasOwnProperty.call(EmberENV, flag) || flag === "EXTEND_PROTOTYPES" || flag === "EMBER_LOAD_HOOKS") continue;
    let defaultValue = ENV[flag];
    if (defaultValue === true) {
      ENV[flag] = EmberENV[flag] !== false;
    } else if (defaultValue === false) {
      ENV[flag] = EmberENV[flag] === true;
    } else {
      ENV[flag] = EmberENV[flag];
    }
  }
  let {
    EMBER_LOAD_HOOKS
  } = EmberENV;
  if (typeof EMBER_LOAD_HOOKS === "object" && EMBER_LOAD_HOOKS !== null) {
    for (let hookName in EMBER_LOAD_HOOKS) {
      if (!Object.prototype.hasOwnProperty.call(EMBER_LOAD_HOOKS, hookName)) continue;
      let hooks = EMBER_LOAD_HOOKS[hookName];
      if (Array.isArray(hooks)) {
        ENV.EMBER_LOAD_HOOKS[hookName] = hooks.filter((hook) => typeof hook === "function");
      }
    }
  }
  let {
    FEATURES
  } = EmberENV;
  if (typeof FEATURES === "object" && FEATURES !== null) {
    for (let feature in FEATURES) {
      if (!Object.prototype.hasOwnProperty.call(FEATURES, feature)) continue;
      ENV.FEATURES[feature] = FEATURES[feature] === true;
    }
  }
  if (true) {
    ENV._DEBUG_RENDER_TREE = true;
  }
})(global$1.EmberENV);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/assert.js
var assert = () => {
};
function setAssert(implementation) {
  assert = implementation;
  return implementation;
}
if (true) {
  let assert2 = function(desc, test) {
    if (!test) {
      throw new Error(`Assertion Failed: ${desc}`);
    }
  };
  setAssert(assert2);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/handlers.js
var HANDLERS = {};
var registerHandler = function registerHandler2(_type, _callback) {
};
var invoke = () => {
};
if (true) {
  registerHandler = function registerHandler5(type, callback) {
    let nextHandler = HANDLERS[type] || (() => {
    });
    HANDLERS[type] = (message, options) => {
      callback(message, options, nextHandler);
    };
  };
  invoke = function invoke2(type, message, test, options) {
    if (test) {
      return;
    }
    let handlerForType = HANDLERS[type];
    if (handlerForType) {
      handlerForType(message, options);
    }
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/deprecate.js
var registerHandler3 = () => {
};
var missingOptionsDeprecation;
var missingOptionsIdDeprecation;
var missingOptionDeprecation = () => "";
var deprecate = () => {
};
if (true) {
  registerHandler3 = function registerHandler5(handler) {
    registerHandler("deprecate", handler);
  };
  let formatMessage = function formatMessage2(_message, options) {
    let message = _message;
    if (options?.id) {
      message = message + ` [deprecation id: ${options.id}]`;
    }
    if (options?.until) {
      message = message + ` This will be removed in ${options.for} ${options.until}.`;
    }
    if (options?.url) {
      message += ` See ${options.url} for more details.`;
    }
    return message;
  };
  registerHandler3(function logDeprecationToConsole(message, options) {
    let updatedMessage = formatMessage(message, options);
    console.warn(`DEPRECATION: ${updatedMessage}`);
  });
  let captureErrorForStack;
  if (new Error().stack) {
    captureErrorForStack = () => new Error();
  } else {
    captureErrorForStack = () => {
      try {
        __fail__.fail();
        return;
      } catch (e) {
        return e;
      }
    };
  }
  registerHandler3(function logDeprecationStackTrace(message, options, next) {
    if (ENV.LOG_STACKTRACE_ON_DEPRECATION) {
      let stackStr = "";
      let error = captureErrorForStack();
      let stack;
      if (error instanceof Error) {
        if (error.stack) {
          if (error["arguments"]) {
            stack = error.stack.replace(/^\s+at\s+/gm, "").replace(/^([^(]+?)([\n$])/gm, "{anonymous}($1)$2").replace(/^Object.<anonymous>\s*\(([^)]+)\)/gm, "{anonymous}($1)").split("\n");
            stack.shift();
          } else {
            stack = error.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
          }
          stackStr = `
    ${stack.slice(2).join("\n    ")}`;
        }
      }
      let updatedMessage = formatMessage(message, options);
      console.warn(`DEPRECATION: ${updatedMessage}${stackStr}`);
    } else {
      next(message, options);
    }
  });
  registerHandler3(function raiseOnDeprecation(message, options, next) {
    if (ENV.RAISE_ON_DEPRECATION) {
      let updatedMessage = formatMessage(message);
      throw new Error(updatedMessage);
    } else {
      next(message, options);
    }
  });
  missingOptionsDeprecation = "When calling `deprecate` you must provide an `options` hash as the third parameter.  `options` should include `id` and `until` properties.";
  missingOptionsIdDeprecation = "When calling `deprecate` you must provide `id` in options.";
  missingOptionDeprecation = (id, missingOption) => {
    return `When calling \`deprecate\` you must provide \`${missingOption}\` in options. Missing options.${missingOption} in "${id}" deprecation`;
  };
  deprecate = function deprecate3(message, test, options) {
    assert(missingOptionsDeprecation, Boolean(options && (options.id || options.until)));
    assert(missingOptionsIdDeprecation, Boolean(options.id));
    assert(missingOptionDeprecation(options.id, "until"), Boolean(options.until));
    assert(missingOptionDeprecation(options.id, "for"), Boolean(options.for));
    assert(missingOptionDeprecation(options.id, "since"), Boolean(options.since));
    invoke("deprecate", message, test, options);
  };
}
var defaultDeprecate = deprecate;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/testing.js
var testing = false;
function isTesting() {
  return testing;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/warn.js
var registerHandler4 = () => {
};
var warn = () => {
};
var missingOptionsDeprecation2;
var missingOptionsIdDeprecation2;
if (true) {
  registerHandler4 = function registerHandler5(handler) {
    registerHandler("warn", handler);
  };
  registerHandler4(function logWarning(message) {
    console.warn(`WARNING: ${message}`);
  });
  missingOptionsDeprecation2 = "When calling `warn` you must provide an `options` hash as the third parameter.  `options` should include an `id` property.";
  missingOptionsIdDeprecation2 = "When calling `warn` you must provide `id` in options.";
  warn = function warn3(message, test, options) {
    if (arguments.length === 2 && typeof test === "object") {
      options = test;
      test = false;
    }
    assert(missingOptionsDeprecation2, Boolean(options));
    assert(missingOptionsIdDeprecation2, Boolean(options && options.id));
    invoke("warn", message, test, options);
  };
}
var _warn = warn;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/lib/inspect.js
var {
  toString: objectToString
} = Object.prototype;
var {
  toString: functionToString
} = Function.prototype;
var {
  isArray
} = Array;
var {
  keys: objectKeys
} = Object;
var {
  stringify
} = JSON;
var LIST_LIMIT = 100;
var DEPTH_LIMIT = 4;
var SAFE_KEY = /^[\w$]+$/;
function inspect(obj) {
  if (typeof obj === "number" && arguments.length === 2) {
    return this;
  }
  return inspectValue(obj, 0);
}
function inspectValue(value, depth, seen) {
  let valueIsArray = false;
  switch (typeof value) {
    case "undefined":
      return "undefined";
    case "object":
      if (value === null) return "null";
      if (isArray(value)) {
        valueIsArray = true;
        break;
      }
      if (value.toString === objectToString || value.toString === void 0) {
        break;
      }
      return value.toString();
    case "function":
      return value.toString === functionToString ? value.name ? `[Function:${value.name}]` : `[Function]` : value.toString();
    case "string":
      return stringify(value);
    case "symbol":
    case "boolean":
    case "number":
    default:
      return value.toString();
  }
  if (seen === void 0) {
    seen = /* @__PURE__ */ new WeakSet();
  } else {
    if (seen.has(value)) return `[Circular]`;
  }
  seen.add(value);
  return valueIsArray ? inspectArray(value, depth + 1, seen) : inspectObject(value, depth + 1, seen);
}
function inspectKey(key) {
  return SAFE_KEY.test(key) ? key : stringify(key);
}
function inspectObject(obj, depth, seen) {
  if (depth > DEPTH_LIMIT) {
    return "[Object]";
  }
  let s = "{";
  let keys = objectKeys(obj);
  for (let i = 0; i < keys.length; i++) {
    s += i === 0 ? " " : ", ";
    if (i >= LIST_LIMIT) {
      s += `... ${keys.length - LIST_LIMIT} more keys`;
      break;
    }
    let key = keys[i];
    assert("has key", key);
    s += `${inspectKey(String(key))}: ${inspectValue(obj[key], depth, seen)}`;
  }
  s += " }";
  return s;
}
function inspectArray(arr, depth, seen) {
  if (depth > DEPTH_LIMIT) {
    return "[Array]";
  }
  let s = "[";
  for (let i = 0; i < arr.length; i++) {
    s += i === 0 ? " " : ", ";
    if (i >= LIST_LIMIT) {
      s += `... ${arr.length - LIST_LIMIT} more items`;
      break;
    }
    s += inspectValue(arr[i], depth, seen);
  }
  s += " ]";
  return s;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/index.js
var noop = () => {
};
var info = noop;
var warn2 = noop;
var debug = noop;
var currentDeprecate;
var debugSeal = noop;
var debugFreeze = noop;
var runInDebug = noop;
var setDebugFunction = noop;
var getDebugFunction = noop;
var deprecateFunc = function() {
  return arguments[arguments.length - 1];
};
function deprecate2(...args) {
  return (currentDeprecate ?? defaultDeprecate)(...args);
}
if (true) {
  setDebugFunction = function(type, callback) {
    switch (type) {
      case "assert":
        return setAssert(callback);
      case "info":
        return info = callback;
      case "warn":
        return warn2 = callback;
      case "debug":
        return debug = callback;
      case "deprecate":
        if (callback === deprecate2) {
          currentDeprecate = void 0;
          return deprecate2;
        } else {
          return currentDeprecate = callback;
        }
      case "debugSeal":
        return debugSeal = callback;
      case "debugFreeze":
        return debugFreeze = callback;
      case "runInDebug":
        return runInDebug = callback;
      case "deprecateFunc":
        return deprecateFunc = callback;
    }
  };
  getDebugFunction = function(type) {
    switch (type) {
      case "assert":
        return assert;
      case "info":
        return info;
      case "warn":
        return warn2;
      case "debug":
        return debug;
      case "deprecate":
        return deprecate2;
      case "debugSeal":
        return debugSeal;
      case "debugFreeze":
        return debugFreeze;
      case "runInDebug":
        return runInDebug;
      case "deprecateFunc":
        return deprecateFunc;
    }
  };
}
if (true) {
  setDebugFunction("debug", function debug2(message) {
    console.debug(`DEBUG: ${message}`);
  });
  setDebugFunction("info", function info2() {
    console.info(...arguments);
  });
  setDebugFunction("deprecateFunc", function deprecateFunc2(...args) {
    if (args.length === 3) {
      let [message, options, func] = args;
      return function(...args2) {
        deprecate2(message, false, options);
        return func.apply(this, args2);
      };
    } else {
      let [message, func] = args;
      return function() {
        deprecate2(message);
        return func.apply(this, arguments);
      };
    }
  });
  setDebugFunction("runInDebug", function runInDebug2(func) {
    func();
  });
  setDebugFunction("debugSeal", function debugSeal2(obj) {
    Object.seal(obj);
  });
  setDebugFunction("debugFreeze", function debugFreeze2(obj) {
    if (!Object.isFrozen(obj)) {
      Object.freeze(obj);
    }
  });
  setDebugFunction("warn", _warn);
}
if (!isTesting()) {
  if (typeof window !== "undefined" && (isFirefox || isChrome) && window.addEventListener) {
    window.addEventListener("load", () => {
      if (document.documentElement && document.documentElement.dataset && !document.documentElement.dataset["emberExtension"]) {
        let downloadURL;
        if (isChrome) {
          downloadURL = "https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi";
        } else if (isFirefox) {
          downloadURL = "https://addons.mozilla.org/en-US/firefox/addon/ember-inspector/";
        }
        debug(`For more advanced debugging, install the Ember Inspector from ${downloadURL}`);
      }
    }, false);
  }
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/mandatory-setter-CXNsxygN.js
function intern(str) {
  let obj = /* @__PURE__ */ Object.create(null);
  obj[str] = 1;
  for (let key in obj) {
    if (key === str) {
      return key;
    }
  }
  return str;
}
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var _uuid = 0;
function uuid() {
  return ++_uuid;
}
var GUID_PREFIX = "ember";
var OBJECT_GUIDS = /* @__PURE__ */ new WeakMap();
var NON_OBJECT_GUIDS = /* @__PURE__ */ new Map();
var GUID_KEY = intern(`__ember${Date.now()}`);
function guidFor(value) {
  let guid;
  if (isObject(value)) {
    guid = OBJECT_GUIDS.get(value);
    if (guid === void 0) {
      guid = `${GUID_PREFIX}${uuid()}`;
      OBJECT_GUIDS.set(value, guid);
    }
  } else {
    guid = NON_OBJECT_GUIDS.get(value);
    if (guid === void 0) {
      let type = typeof value;
      if (type === "string") {
        guid = `st${uuid()}`;
      } else if (type === "number") {
        guid = `nu${uuid()}`;
      } else if (type === "symbol") {
        guid = `sy${uuid()}`;
      } else {
        guid = `(${value})`;
      }
      NON_OBJECT_GUIDS.set(value, guid);
    }
  }
  return guid;
}
var getDebugName;
if (true) {
  let getFunctionName = (fn) => {
    let functionName = fn.name;
    if (functionName === void 0) {
      let match2 = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
      functionName = match2 && match2[1] || "";
    }
    return functionName.replace(/^bound /, "");
  };
  let getObjectName = (obj) => {
    let name;
    let className;
    if (obj.constructor && obj.constructor !== Object) {
      className = getFunctionName(obj.constructor);
    }
    if ("toString" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
      name = obj.toString();
    }
    if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== "_" && className.length > 2 && className !== "Class") {
      return name.replace(/<.*:/, `<${className}:`);
    }
    return name || className;
  };
  let getPrimitiveName = (value) => {
    return String(value);
  };
  getDebugName = (value) => {
    if (typeof value === "function") {
      return getFunctionName(value) || `(unknown function)`;
    } else if (typeof value === "object" && value !== null) {
      return getObjectName(value) || `(unknown object)`;
    } else {
      return getPrimitiveName(value);
    }
  };
}
var getDebugName$1 = getDebugName;
var HAS_SUPER_PATTERN = /\.(_super|call\(this|apply\(this)/;
var fnToString = Function.prototype.toString;
var checkHasSuper = (() => {
  let sourceAvailable = fnToString.call(function() {
    return this;
  }).indexOf("return this") > -1;
  if (sourceAvailable) {
    return function checkHasSuper2(func) {
      return HAS_SUPER_PATTERN.test(fnToString.call(func));
    };
  }
  return function checkHasSuper2() {
    return true;
  };
})();
var HAS_SUPER_MAP = /* @__PURE__ */ new WeakMap();
var ROOT = Object.freeze(function() {
});
HAS_SUPER_MAP.set(ROOT, false);
function hasSuper(func) {
  let hasSuper2 = HAS_SUPER_MAP.get(func);
  if (hasSuper2 === void 0) {
    hasSuper2 = checkHasSuper(func);
    HAS_SUPER_MAP.set(func, hasSuper2);
  }
  return hasSuper2;
}
var OBSERVERS_LISTENERS_MAP = /* @__PURE__ */ new WeakMap();
function observerListenerMetaFor(fn) {
  return OBSERVERS_LISTENERS_MAP.get(fn);
}
var IS_WRAPPED_FUNCTION_SET = /* @__PURE__ */ new WeakSet();
function wrap(func, superFunc) {
  if (!hasSuper(func)) {
    return func;
  }
  if (!IS_WRAPPED_FUNCTION_SET.has(superFunc) && hasSuper(superFunc)) {
    return _wrap(func, _wrap(superFunc, ROOT));
  }
  return _wrap(func, superFunc);
}
function _wrap(func, superFunc) {
  function superWrapper() {
    let orig = this._super;
    this._super = superFunc;
    let ret = func.apply(this, arguments);
    this._super = orig;
    return ret;
  }
  IS_WRAPPED_FUNCTION_SET.add(superWrapper);
  let meta3 = OBSERVERS_LISTENERS_MAP.get(func);
  if (meta3 !== void 0) {
    OBSERVERS_LISTENERS_MAP.set(superWrapper, meta3);
  }
  return superWrapper;
}
function lookupDescriptor(obj, keyName) {
  let current = obj;
  do {
    let descriptor = Object.getOwnPropertyDescriptor(current, keyName);
    if (descriptor !== void 0) {
      return descriptor;
    }
    current = Object.getPrototypeOf(current);
  } while (current !== null);
  return null;
}
var setupMandatorySetter;
var teardownMandatorySetter;
var setWithMandatorySetter;
function isElementKey(key) {
  return typeof key === "number" ? isPositiveInt(key) : isStringInt(key);
}
function isStringInt(str) {
  let num = parseInt(str, 10);
  return isPositiveInt(num) && str === String(num);
}
function isPositiveInt(num) {
  return num >= 0 && num % 1 === 0;
}
if (true) {
  let SEEN_TAGS = /* @__PURE__ */ new WeakSet();
  let MANDATORY_SETTERS = /* @__PURE__ */ new WeakMap();
  let propertyIsEnumerable = function(obj, key) {
    return Object.prototype.propertyIsEnumerable.call(obj, key);
  };
  setupMandatorySetter = function(tag, obj, keyName) {
    if (SEEN_TAGS.has(tag)) {
      return;
    }
    SEEN_TAGS.add(tag);
    if (Array.isArray(obj) && isElementKey(keyName)) {
      return;
    }
    let desc = lookupDescriptor(obj, keyName) || {};
    if (desc.get || desc.set) {
      return;
    }
    if (desc && (!desc.configurable || !desc.writable)) {
      return;
    }
    let setters = MANDATORY_SETTERS.get(obj);
    if (setters === void 0) {
      setters = {};
      MANDATORY_SETTERS.set(obj, setters);
    }
    desc.hadOwnProperty = Object.hasOwnProperty.call(obj, keyName);
    setters[keyName] = desc;
    Object.defineProperty(obj, keyName, {
      configurable: true,
      enumerable: propertyIsEnumerable(obj, keyName),
      get() {
        if (desc.get) {
          return desc.get.call(this);
        } else {
          return desc.value;
        }
      },
      set(value) {
        assert(`You attempted to update ${this}.${String(keyName)} to "${String(value)}", but it is being tracked by a tracking context, such as a template, computed property, or observer. In order to make sure the context updates properly, you must invalidate the property when updating it. You can mark the property as \`@tracked\`, or use \`@ember/object#set\` to do this.`);
      }
    });
  };
  teardownMandatorySetter = function(obj, keyName) {
    let setters = MANDATORY_SETTERS.get(obj);
    if (setters !== void 0 && setters[keyName] !== void 0) {
      Object.defineProperty(obj, keyName, setters[keyName]);
      delete setters[keyName];
    }
  };
  setWithMandatorySetter = function(obj, keyName, value) {
    let setters = MANDATORY_SETTERS.get(obj);
    if (setters !== void 0 && setters[keyName] !== void 0) {
      let setter = setters[keyName];
      if (setter.set) {
        setter.set.call(obj, value);
      } else {
        setter.value = value;
        if (!setter.hadOwnProperty) {
          let desc = lookupDescriptor(obj, keyName);
          desc.enumerable = true;
          Object.defineProperty(obj, keyName, desc);
        }
      }
    } else {
      obj[keyName] = value;
    }
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/dictionary-gc5gpyOG.js
function makeDictionary(parent) {
  let dict = Object.create(parent);
  dict["_dict"] = null;
  delete dict["_dict"];
  return dict;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/owner/index.js
function isFactory(obj) {
  return obj != null && typeof obj.create === "function";
}
function getOwner2(object) {
  return getOwner(object);
}
function setOwner2(object, owner) {
  setOwner(object, owner);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/registry-BJpQx6hv.js
var leakTracking;
var containers;
if (true) {
  try {
    if (typeof gc === "function") {
      leakTracking = (() => {
        let GetWeakSetValues = new Function("weakSet", "return %GetWeakSetValues(weakSet, 0)");
        containers = /* @__PURE__ */ new WeakSet();
        return {
          hasContainers() {
            gc();
            return GetWeakSetValues(containers).length > 0;
          },
          reset() {
            let values = GetWeakSetValues(containers);
            for (let i = 0; i < values.length; i++) {
              containers.delete(values[i]);
            }
          }
        };
      })();
    }
  } catch (_e) {
  }
}
var Container = class {
  static _leakTracking;
  owner;
  registry;
  cache;
  factoryManagerCache;
  validationCache;
  isDestroyed;
  isDestroying;
  constructor(registry, options = {}) {
    this.registry = registry;
    this.owner = options.owner || null;
    this.cache = makeDictionary(options.cache || null);
    this.factoryManagerCache = makeDictionary(options.factoryManagerCache || null);
    this.isDestroyed = false;
    this.isDestroying = false;
    if (true) {
      this.validationCache = makeDictionary(options.validationCache || null);
      if (containers !== void 0) {
        containers.add(this);
      }
    }
  }
  /**
   @private
   @property registry
   @type Registry
   @since 1.11.0
   */
  /**
   @private
   @property cache
   @type InheritingDict
   */
  /**
   @private
   @property validationCache
   @type InheritingDict
   */
  /**
   Given a fullName return a corresponding instance.
    The default behavior is for lookup to return a singleton instance.
   The singleton is scoped to the container, allowing multiple containers
   to all have their own locally scoped singletons.
    ```javascript
   let registry = new Registry();
   let container = registry.container();
    registry.register('api:twitter', Twitter);
    let twitter = container.lookup('api:twitter');
    twitter instanceof Twitter; // => true
    // by default the container will return singletons
   let twitter2 = container.lookup('api:twitter');
   twitter2 instanceof Twitter; // => true
    twitter === twitter2; //=> true
   ```
    If singletons are not wanted, an optional flag can be provided at lookup.
    ```javascript
   let registry = new Registry();
   let container = registry.container();
    registry.register('api:twitter', Twitter);
    let twitter = container.lookup('api:twitter', { singleton: false });
   let twitter2 = container.lookup('api:twitter', { singleton: false });
    twitter === twitter2; //=> false
   ```
    @private
   @method lookup
   @param {String} fullName
   @param {RegisterOptions} [options]
   @return {any}
   */
  lookup(fullName, options) {
    if (this.isDestroyed) {
      throw new Error(`Cannot call \`.lookup('${fullName}')\` after the owner has been destroyed`);
    }
    !this.registry.isValidFullName(fullName) && assert("fullName must be a proper full name", this.registry.isValidFullName(fullName));
    return lookup(this, this.registry.normalize(fullName), options);
  }
  /**
   A depth first traversal, destroying the container, its descendant containers and all
   their managed objects.
    @private
   @method destroy
   */
  destroy() {
    this.isDestroying = true;
    destroyDestroyables(this);
  }
  finalizeDestroy() {
    resetCache(this);
    this.isDestroyed = true;
  }
  /**
   Clear either the entire cache or just the cache for a particular key.
    @private
   @method reset
   @param {String} fullName optional key to reset; if missing, resets everything
  */
  reset(fullName) {
    if (this.isDestroyed) return;
    if (fullName === void 0) {
      destroyDestroyables(this);
      resetCache(this);
    } else {
      resetMember(this, this.registry.normalize(fullName));
    }
  }
  /**
   Returns an object that can be used to provide an owner to a
   manually created instance.
    @private
   @method ownerInjection
   @returns { Object }
  */
  ownerInjection() {
    let injection = {};
    setOwner2(injection, this.owner);
    return injection;
  }
  /**
   Given a fullName, return the corresponding factory. The consumer of the factory
   is responsible for the destruction of any factory instances, as there is no
   way for the container to ensure instances are destroyed when it itself is
   destroyed.
    @public
   @method factoryFor
   @param {String} fullName
   @return {any}
   */
  factoryFor(fullName) {
    if (this.isDestroyed) {
      throw new Error(`Cannot call \`.factoryFor('${fullName}')\` after the owner has been destroyed`);
    }
    let normalizedName = this.registry.normalize(fullName);
    !this.registry.isValidFullName(normalizedName) && assert("fullName must be a proper full name", this.registry.isValidFullName(normalizedName));
    return factoryFor(this, normalizedName, fullName);
  }
};
if (true) {
  Container._leakTracking = leakTracking;
}
function wrapManagerInDeprecationProxy(manager) {
  let validator = {
    set(_obj, prop) {
      throw new Error(`You attempted to set "${String(prop)}" on a factory manager created by container#factoryFor. A factory manager is a read-only construct.`);
    }
  };
  let m = manager;
  let proxiedManager = {
    class: m.class,
    create(props) {
      return m.create(props);
    }
  };
  return new Proxy(proxiedManager, validator);
}
function isSingleton(container, fullName) {
  return container.registry.getOption(fullName, "singleton") !== false;
}
function isInstantiatable(container, fullName) {
  return container.registry.getOption(fullName, "instantiate") !== false;
}
function lookup(container, fullName, options = {}) {
  let normalizedName = fullName;
  if (options.singleton === true || options.singleton === void 0 && isSingleton(container, fullName)) {
    let cached = container.cache[normalizedName];
    if (cached !== void 0) {
      return cached;
    }
  }
  return instantiateFactory(container, normalizedName, fullName, options);
}
function factoryFor(container, normalizedName, fullName) {
  let cached = container.factoryManagerCache[normalizedName];
  if (cached !== void 0) {
    return cached;
  }
  let factory = container.registry.resolve(normalizedName);
  if (factory === void 0) {
    return;
  }
  if (factory && typeof factory._onLookup === "function") {
    factory._onLookup(fullName);
  }
  let manager = new InternalFactoryManager(container, factory, fullName, normalizedName);
  if (true) {
    manager = wrapManagerInDeprecationProxy(manager);
  }
  container.factoryManagerCache[normalizedName] = manager;
  return manager;
}
function isSingletonClass(container, fullName, {
  instantiate,
  singleton
}) {
  return singleton !== false && !instantiate && isSingleton(container, fullName) && !isInstantiatable(container, fullName);
}
function isSingletonInstance(container, fullName, {
  instantiate,
  singleton
}) {
  return singleton !== false && instantiate !== false && (singleton === true || isSingleton(container, fullName)) && isInstantiatable(container, fullName);
}
function isFactoryClass(container, fullname, {
  instantiate,
  singleton
}) {
  return instantiate === false && (singleton === false || !isSingleton(container, fullname)) && !isInstantiatable(container, fullname);
}
function isFactoryInstance(container, fullName, {
  instantiate,
  singleton
}) {
  return instantiate !== false && (singleton === false || !isSingleton(container, fullName)) && isInstantiatable(container, fullName);
}
function instantiateFactory(container, normalizedName, fullName, options) {
  let factoryManager = factoryFor(container, normalizedName, fullName);
  if (factoryManager === void 0) {
    return;
  }
  if (isSingletonInstance(container, fullName, options)) {
    let instance = container.cache[normalizedName] = factoryManager.create();
    if (container.isDestroying) {
      if (typeof instance.destroy === "function") {
        instance.destroy();
      }
    }
    return instance;
  }
  if (isFactoryInstance(container, fullName, options)) {
    return factoryManager.create();
  }
  if (isSingletonClass(container, fullName, options) || isFactoryClass(container, fullName, options)) {
    return factoryManager.class;
  }
  throw new Error("Could not create factory");
}
function destroyDestroyables(container) {
  let cache = container.cache;
  let keys = Object.keys(cache);
  for (let key of keys) {
    let value = cache[key];
    !value && assert("has cached value", value);
    if (value.destroy) {
      value.destroy();
    }
  }
}
function resetCache(container) {
  container.cache = makeDictionary(null);
  container.factoryManagerCache = makeDictionary(null);
}
function resetMember(container, fullName) {
  let member = container.cache[fullName];
  delete container.factoryManagerCache[fullName];
  if (member) {
    delete container.cache[fullName];
    if (member.destroy) {
      member.destroy();
    }
  }
}
var INIT_FACTORY = Symbol("INIT_FACTORY");
function getFactoryFor(obj) {
  return obj[INIT_FACTORY];
}
function setFactoryFor(obj, factory) {
  obj[INIT_FACTORY] = factory;
}
var InternalFactoryManager = class {
  container;
  owner;
  class;
  fullName;
  normalizedName;
  madeToString;
  injections;
  constructor(container, factory, fullName, normalizedName) {
    this.container = container;
    this.owner = container.owner;
    this.class = factory;
    this.fullName = fullName;
    this.normalizedName = normalizedName;
    this.madeToString = void 0;
    this.injections = void 0;
  }
  toString() {
    if (this.madeToString === void 0) {
      this.madeToString = this.container.registry.makeToString(this.class, this.fullName);
    }
    return this.madeToString;
  }
  create(options) {
    let {
      container
    } = this;
    if (container.isDestroyed) {
      throw new Error(`Cannot create new instances after the owner has been destroyed (you attempted to create ${this.fullName})`);
    }
    let props = options ? {
      ...options
    } : {};
    setOwner2(props, container.owner);
    setFactoryFor(props, this);
    if (true) {
      let lazyInjections;
      let validationCache = this.container.validationCache;
      if (!validationCache[this.fullName] && this.class && typeof this.class._lazyInjections === "function") {
        lazyInjections = this.class._lazyInjections();
        lazyInjections = this.container.registry.normalizeInjectionsHash(lazyInjections);
        this.container.registry.validateInjections(lazyInjections);
      }
      validationCache[this.fullName] = true;
      !(typeof this.class.create === "function") && assert(`Failed to create an instance of '${this.normalizedName}'. Most likely an improperly defined class or an invalid module export.`, typeof this.class.create === "function");
    }
    return this.class.create(props);
  }
};
var VALID_FULL_NAME_REGEXP = /^[^:]+:[^:]+$/;
var Registry = class {
  _failSet;
  resolver;
  fallback;
  registrations;
  _normalizeCache;
  _options;
  _resolveCache;
  _typeOptions;
  constructor(options = {}) {
    this.fallback = options.fallback || null;
    this.resolver = options.resolver || null;
    this.registrations = makeDictionary(options.registrations || null);
    this._normalizeCache = makeDictionary(null);
    this._resolveCache = makeDictionary(null);
    this._failSet = /* @__PURE__ */ new Set();
    this._options = makeDictionary(null);
    this._typeOptions = makeDictionary(null);
  }
  /**
   A backup registry for resolving registrations when no matches can be found.
    @private
   @property fallback
   @type Registry
   */
  /**
   An object that has a `resolve` method that resolves a name.
    @private
   @property resolver
   @type Resolver
   */
  /**
   @private
   @property registrations
   @type InheritingDict
   */
  /**
   @private
    @property _normalizeCache
   @type InheritingDict
   */
  /**
   @private
    @property _resolveCache
   @type InheritingDict
   */
  /**
   @private
    @property _options
   @type InheritingDict
   */
  /**
   @private
    @property _typeOptions
   @type InheritingDict
   */
  /**
   Creates a container based on this registry.
    @private
   @method container
   @param {Object} options
   @return {Container} created container
   */
  container(options) {
    return new Container(this, options);
  }
  /**
   Registers a factory for later injection.
    Example:
    ```javascript
   let registry = new Registry();
    registry.register('model:user', Person, {singleton: false });
   registry.register('fruit:favorite', Orange);
   registry.register('communication:main', Email, {singleton: false});
   ```
    @private
   @method register
   @param {String} fullName
   @param {Function} factory
   @param {Object} options
   */
  register(fullName, factory, options = {}) {
    !this.isValidFullName(fullName) && assert("fullName must be a proper full name", this.isValidFullName(fullName));
    !(factory !== void 0) && assert(`Attempting to register an unknown factory: '${fullName}'`, factory !== void 0);
    let normalizedName = this.normalize(fullName);
    !!this._resolveCache[normalizedName] && assert(`Cannot re-register: '${fullName}', as it has already been resolved.`, !this._resolveCache[normalizedName]);
    this._failSet.delete(normalizedName);
    this.registrations[normalizedName] = factory;
    this._options[normalizedName] = options;
  }
  /**
   Unregister a fullName
    ```javascript
   let registry = new Registry();
   registry.register('model:user', User);
    registry.resolve('model:user').create() instanceof User //=> true
    registry.unregister('model:user')
   registry.resolve('model:user') === undefined //=> true
   ```
    @private
   @method unregister
   @param {String} fullName
   */
  unregister(fullName) {
    !this.isValidFullName(fullName) && assert("fullName must be a proper full name", this.isValidFullName(fullName));
    let normalizedName = this.normalize(fullName);
    delete this.registrations[normalizedName];
    delete this._resolveCache[normalizedName];
    delete this._options[normalizedName];
    this._failSet.delete(normalizedName);
  }
  /**
   Given a fullName return the corresponding factory.
    By default `resolve` will retrieve the factory from
   the registry.
    ```javascript
   let registry = new Registry();
   registry.register('api:twitter', Twitter);
    registry.resolve('api:twitter') // => Twitter
   ```
    Optionally the registry can be provided with a custom resolver.
   If provided, `resolve` will first provide the custom resolver
   the opportunity to resolve the fullName, otherwise it will fallback
   to the registry.
    ```javascript
   let registry = new Registry();
   registry.resolver = function(fullName) {
      // lookup via the module system of choice
    };
    // the twitter factory is added to the module system
   registry.resolve('api:twitter') // => Twitter
   ```
    @private
   @method resolve
   @param {String} fullName
   @return {Function} fullName's factory
   */
  resolve(fullName) {
    let factory = resolve(this, this.normalize(fullName));
    if (factory === void 0 && this.fallback !== null) {
      factory = this.fallback.resolve(fullName);
    }
    return factory;
  }
  /**
   A hook that can be used to describe how the resolver will
   attempt to find the factory.
    For example, the default Ember `.describe` returns the full
   class name (including namespace) where Ember's resolver expects
   to find the `fullName`.
    @private
   @method describe
   @param {String} fullName
   @return {string} described fullName
   */
  describe(fullName) {
    if (this.resolver !== null && this.resolver.lookupDescription) {
      return this.resolver.lookupDescription(fullName);
    } else if (this.fallback !== null) {
      return this.fallback.describe(fullName);
    } else {
      return fullName;
    }
  }
  /**
   A hook to enable custom fullName normalization behavior
    @private
   @method normalizeFullName
   @param {String} fullName
   @return {string} normalized fullName
   */
  normalizeFullName(fullName) {
    if (this.resolver !== null && this.resolver.normalize) {
      return this.resolver.normalize(fullName);
    } else if (this.fallback !== null) {
      return this.fallback.normalizeFullName(fullName);
    } else {
      return fullName;
    }
  }
  /**
   Normalize a fullName based on the application's conventions
    @private
   @method normalize
   @param {String} fullName
   @return {string} normalized fullName
   */
  normalize(fullName) {
    return this._normalizeCache[fullName] || (this._normalizeCache[fullName] = this.normalizeFullName(fullName));
  }
  /**
   @method makeToString
    @private
   @param {any} factory
   @param {string} fullName
   @return {function} toString function
   */
  makeToString(factory, fullName) {
    if (this.resolver !== null && this.resolver.makeToString) {
      return this.resolver.makeToString(factory, fullName);
    } else if (this.fallback !== null) {
      return this.fallback.makeToString(factory, fullName);
    } else {
      return typeof factory === "string" ? factory : factory.name ?? "(unknown class)";
    }
  }
  /**
   Given a fullName check if the container is aware of its factory
   or singleton instance.
    @private
   @method has
   @param {String} fullName
   @param {Object} [options]
   @param {String} [options.source] the fullname of the request source (used for local lookups)
   @return {Boolean}
   */
  has(fullName) {
    if (!this.isValidFullName(fullName)) {
      return false;
    }
    return has(this, this.normalize(fullName));
  }
  /**
   Allow registering options for all factories of a type.
    ```javascript
   let registry = new Registry();
   let container = registry.container();
    // if all of type `connection` must not be singletons
   registry.optionsForType('connection', { singleton: false });
    registry.register('connection:twitter', TwitterConnection);
   registry.register('connection:facebook', FacebookConnection);
    let twitter = container.lookup('connection:twitter');
   let twitter2 = container.lookup('connection:twitter');
    twitter === twitter2; // => false
    let facebook = container.lookup('connection:facebook');
   let facebook2 = container.lookup('connection:facebook');
    facebook === facebook2; // => false
   ```
    @private
   @method optionsForType
   @param {String} type
   @param {Object} options
   */
  optionsForType(type, options) {
    this._typeOptions[type] = options;
  }
  getOptionsForType(type) {
    let optionsForType = this._typeOptions[type];
    if (optionsForType === void 0 && this.fallback !== null) {
      optionsForType = this.fallback.getOptionsForType(type);
    }
    return optionsForType;
  }
  /**
   @private
   @method options
   @param {String} fullName
   @param {Object} options
   */
  options(fullName, options) {
    let normalizedName = this.normalize(fullName);
    this._options[normalizedName] = options;
  }
  getOptions(fullName) {
    let normalizedName = this.normalize(fullName);
    let options = this._options[normalizedName];
    if (options === void 0 && this.fallback !== null) {
      options = this.fallback.getOptions(fullName);
    }
    return options;
  }
  getOption(fullName, optionName) {
    let options = this._options[fullName];
    if (options !== void 0 && options[optionName] !== void 0) {
      return options[optionName];
    }
    let type = fullName.split(":")[0];
    !type && assert("has type", type);
    options = this._typeOptions[type];
    if (options && options[optionName] !== void 0) {
      return options[optionName];
    } else if (this.fallback !== null) {
      return this.fallback.getOption(fullName, optionName);
    }
    return void 0;
  }
  /**
   @private
   @method knownForType
   @param {String} type the type to iterate over
  */
  knownForType(type) {
    let localKnown = makeDictionary(null);
    let registeredNames = Object.keys(this.registrations);
    for (let fullName of registeredNames) {
      let itemType = fullName.split(":")[0];
      if (itemType === type) {
        localKnown[fullName] = true;
      }
    }
    let fallbackKnown, resolverKnown;
    if (this.fallback !== null) {
      fallbackKnown = this.fallback.knownForType(type);
    }
    if (this.resolver !== null && this.resolver.knownForType) {
      resolverKnown = this.resolver.knownForType(type);
    }
    return Object.assign({}, fallbackKnown, localKnown, resolverKnown);
  }
  isValidFullName(fullName) {
    return VALID_FULL_NAME_REGEXP.test(fullName);
  }
};
if (true) {
  const proto = Registry.prototype;
  proto.normalizeInjectionsHash = function(hash2) {
    let injections = [];
    for (let key in hash2) {
      if (Object.prototype.hasOwnProperty.call(hash2, key)) {
        let value = hash2[key];
        !value && assert("has value", value);
        let {
          specifier
        } = value;
        !this.isValidFullName(specifier) && assert(`Expected a proper full name, given '${specifier}'`, this.isValidFullName(specifier));
        injections.push({
          property: key,
          specifier
        });
      }
    }
    return injections;
  };
  proto.validateInjections = function(injections) {
    if (!injections) {
      return;
    }
    for (let injection of injections) {
      let {
        specifier
      } = injection;
      !this.has(specifier) && assert(`Attempting to inject an unknown injection: '${specifier}'`, this.has(specifier));
    }
  };
}
function resolve(registry, _normalizedName) {
  let normalizedName = _normalizedName;
  let cached = registry._resolveCache[normalizedName];
  if (cached !== void 0) {
    return cached;
  }
  if (registry._failSet.has(normalizedName)) {
    return;
  }
  let resolved;
  if (registry.resolver) {
    resolved = registry.resolver.resolve(normalizedName);
  }
  if (resolved === void 0) {
    resolved = registry.registrations[normalizedName];
  }
  if (resolved === void 0) {
    registry._failSet.add(normalizedName);
  } else {
    registry._resolveCache[normalizedName] = resolved;
  }
  return resolved;
}
function has(registry, fullName) {
  return registry.resolve(fullName) !== void 0;
}
var privateNames = makeDictionary(null);
var privateSuffix = `${Math.random()}${Date.now()}`.replace(".", "");
function privatize([fullName]) {
  !(arguments.length === 1 && fullName) && assert("has a single string argument", arguments.length === 1 && fullName);
  let name = privateNames[fullName];
  if (name) {
    return name;
  }
  let [type, rawName] = fullName.split(":");
  return privateNames[fullName] = intern(`${type}:${rawName}-${privateSuffix}`);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/to-string-DaIn5NlY.js
var GENERATED_SYMBOLS = [];
function isInternalSymbol(possibleSymbol) {
  return GENERATED_SYMBOLS.indexOf(possibleSymbol) !== -1;
}
function enumerableSymbol(debugName) {
  let id = GUID_KEY + Math.floor(Math.random() * Date.now()).toString();
  let symbol2 = intern(`__${debugName}${id}__`);
  if (true) {
    GENERATED_SYMBOLS.push(symbol2);
  }
  return symbol2;
}
var symbol = Symbol;
var objectToString2 = Object.prototype.toString;
function isNone(obj) {
  return obj === null || obj === void 0;
}
function toString(obj) {
  if (typeof obj === "string") {
    return obj;
  }
  if (null === obj) return "null";
  if (void 0 === obj) return "undefined";
  if (Array.isArray(obj)) {
    let r = "";
    for (let k = 0; k < obj.length; k++) {
      if (k > 0) {
        r += ",";
      }
      if (!isNone(obj[k])) {
        r += toString(obj[k]);
      }
    }
    return r;
  }
  if (typeof obj.toString === "function") {
    return obj.toString();
  }
  return objectToString2.call(obj);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/meta/lib/meta.js
var objectPrototype = Object.prototype;
var counters;
if (true) {
  counters = {
    peekCalls: 0,
    peekPrototypeWalks: 0,
    setCalls: 0,
    deleteCalls: 0,
    metaCalls: 0,
    metaInstantiated: 0,
    matchingListenersCalls: 0,
    observerEventsCalls: 0,
    addToListenersCalls: 0,
    removeFromListenersCalls: 0,
    removeAllListenersCalls: 0,
    listenersInherited: 0,
    listenersFlattened: 0,
    parentListenersUsed: 0,
    flattenedListenersCalls: 0,
    reopensAfterFlatten: 0,
    readableLazyChainsCalls: 0,
    writableLazyChainsCalls: 0
  };
}
var UNDEFINED = symbol("undefined");
var ListenerKind = (function(ListenerKind2) {
  ListenerKind2[ListenerKind2["ADD"] = 0] = "ADD";
  ListenerKind2[ListenerKind2["ONCE"] = 1] = "ONCE";
  ListenerKind2[ListenerKind2["REMOVE"] = 2] = "REMOVE";
  return ListenerKind2;
})(ListenerKind || {});
var currentListenerVersion = 1;
var Meta = class {
  /** @internal */
  _descriptors;
  /** @internal */
  _mixins;
  /** @internal */
  _isInit;
  /** @internal */
  _lazyChains;
  /** @internal */
  _values;
  /** @internal */
  _revisions;
  /** @internal */
  source;
  /** @internal */
  proto;
  /** @internal */
  _parent;
  /** @internal */
  _listeners;
  /** @internal */
  _listenersVersion = 1;
  /** @internal */
  _inheritedEnd = -1;
  /** @internal */
  _flattenedVersion = 0;
  // DEBUG
  /** @internal */
  constructor(obj) {
    if (true) {
      counters.metaInstantiated++;
    }
    this._parent = void 0;
    this._descriptors = void 0;
    this._mixins = void 0;
    this._lazyChains = void 0;
    this._values = void 0;
    this._revisions = void 0;
    this._isInit = false;
    this.source = obj;
    this.proto = obj.constructor === void 0 ? void 0 : obj.constructor.prototype;
    this._listeners = void 0;
  }
  /** @internal */
  get parent() {
    let parent = this._parent;
    if (parent === void 0) {
      let proto = getPrototypeOf(this.source);
      this._parent = parent = proto === null || proto === objectPrototype ? null : meta(proto);
    }
    return parent;
  }
  setInitializing() {
    this._isInit = true;
  }
  /** @internal */
  unsetInitializing() {
    this._isInit = false;
  }
  /** @internal */
  isInitializing() {
    return this._isInit;
  }
  /** @internal */
  isPrototypeMeta(obj) {
    return this.proto === this.source && this.source === obj;
  }
  /** @internal */
  _getOrCreateOwnMap(key) {
    return this[key] || (this[key] = /* @__PURE__ */ Object.create(null));
  }
  /** @internal */
  _getOrCreateOwnSet(key) {
    return this[key] || (this[key] = /* @__PURE__ */ new Set());
  }
  /** @internal */
  _findInheritedMap(key, subkey) {
    let pointer = this;
    while (pointer !== null) {
      let map3 = pointer[key];
      if (map3 !== void 0) {
        let value = map3.get(subkey);
        if (value !== void 0) {
          return value;
        }
      }
      pointer = pointer.parent;
    }
  }
  /** @internal */
  _hasInInheritedSet(key, value) {
    let pointer = this;
    while (pointer !== null) {
      let set2 = pointer[key];
      if (set2 !== void 0 && set2.has(value)) {
        return true;
      }
      pointer = pointer.parent;
    }
    return false;
  }
  /** @internal */
  valueFor(key) {
    let values = this._values;
    return values !== void 0 ? values[key] : void 0;
  }
  /** @internal */
  setValueFor(key, value) {
    let values = this._getOrCreateOwnMap("_values");
    values[key] = value;
  }
  /** @internal */
  revisionFor(key) {
    let revisions = this._revisions;
    return revisions !== void 0 ? revisions[key] : void 0;
  }
  /** @internal */
  setRevisionFor(key, revision) {
    let revisions = this._getOrCreateOwnMap("_revisions");
    revisions[key] = revision;
  }
  /** @internal */
  writableLazyChainsFor(key) {
    if (true) {
      counters.writableLazyChainsCalls++;
    }
    let lazyChains = this._getOrCreateOwnMap("_lazyChains");
    let chains = lazyChains[key];
    if (chains === void 0) {
      chains = lazyChains[key] = [];
    }
    return chains;
  }
  /** @internal */
  readableLazyChainsFor(key) {
    if (true) {
      counters.readableLazyChainsCalls++;
    }
    let lazyChains = this._lazyChains;
    if (lazyChains !== void 0) {
      return lazyChains[key];
    }
    return void 0;
  }
  /** @internal */
  addMixin(mixin) {
    !!isDestroyed(this.source) && assert(isDestroyed(this.source) ? `Cannot add mixins of \`${toString(mixin)}\` on \`${toString(this.source)}\` call addMixin after it has been destroyed.` : "", !isDestroyed(this.source));
    let set2 = this._getOrCreateOwnSet("_mixins");
    set2.add(mixin);
  }
  /** @internal */
  hasMixin(mixin) {
    return this._hasInInheritedSet("_mixins", mixin);
  }
  /** @internal */
  forEachMixins(fn) {
    let pointer = this;
    let seen;
    while (pointer !== null) {
      let set2 = pointer._mixins;
      if (set2 !== void 0) {
        seen = seen === void 0 ? /* @__PURE__ */ new Set() : seen;
        set2.forEach((mixin) => {
          if (!seen.has(mixin)) {
            seen.add(mixin);
            fn(mixin);
          }
        });
      }
      pointer = pointer.parent;
    }
  }
  /** @internal */
  writeDescriptors(subkey, value) {
    !!isDestroyed(this.source) && assert(isDestroyed(this.source) ? `Cannot update descriptors for \`${subkey}\` on \`${toString(this.source)}\` after it has been destroyed.` : "", !isDestroyed(this.source));
    let map3 = this._descriptors || (this._descriptors = /* @__PURE__ */ new Map());
    map3.set(subkey, value);
  }
  /** @internal */
  peekDescriptors(subkey) {
    let possibleDesc = this._findInheritedMap("_descriptors", subkey);
    return possibleDesc === UNDEFINED ? void 0 : possibleDesc;
  }
  /** @internal */
  removeDescriptors(subkey) {
    this.writeDescriptors(subkey, UNDEFINED);
  }
  /** @internal */
  forEachDescriptors(fn) {
    let pointer = this;
    let seen;
    while (pointer !== null) {
      let map3 = pointer._descriptors;
      if (map3 !== void 0) {
        seen = seen === void 0 ? /* @__PURE__ */ new Set() : seen;
        map3.forEach((value, key) => {
          if (!seen.has(key)) {
            seen.add(key);
            if (value !== UNDEFINED) {
              fn(key, value);
            }
          }
        });
      }
      pointer = pointer.parent;
    }
  }
  /** @internal */
  addToListeners(eventName, target, method, once2, sync) {
    if (true) {
      counters.addToListenersCalls++;
    }
    this.pushListener(eventName, target, method, once2 ? ListenerKind.ONCE : ListenerKind.ADD, sync);
  }
  /** @internal */
  removeFromListeners(eventName, target, method) {
    if (true) {
      counters.removeFromListenersCalls++;
    }
    this.pushListener(eventName, target, method, ListenerKind.REMOVE);
  }
  pushListener(event, target, method, kind, sync = false) {
    let listeners = this.writableListeners();
    let i = indexOfListener(listeners, event, target, method);
    if (i !== -1 && i < this._inheritedEnd) {
      listeners.splice(i, 1);
      this._inheritedEnd--;
      i = -1;
    }
    if (i === -1) {
      !!(this.isPrototypeMeta(this.source) && typeof method === "function") && assert("You cannot add function listeners to prototypes. Convert the listener to a string listener, or add it to the instance instead.", !(this.isPrototypeMeta(this.source) && typeof method === "function"));
      !!(!this.isPrototypeMeta(this.source) && typeof method === "function" && kind === ListenerKind.REMOVE) && assert("You attempted to remove a function listener which did not exist on the instance, which means you may have attempted to remove it before it was added.", !(!this.isPrototypeMeta(this.source) && typeof method === "function" && kind === ListenerKind.REMOVE));
      listeners.push({
        event,
        target,
        method,
        kind,
        sync
      });
    } else {
      let listener = listeners[i];
      !listener && assert("has listener", listener);
      if (kind === ListenerKind.REMOVE && listener.kind !== ListenerKind.REMOVE) {
        listeners.splice(i, 1);
      } else {
        !!(listener.kind === ListenerKind.ADD && kind === ListenerKind.ADD && listener.sync !== sync) && assert(`You attempted to add an observer for the same method on '${event.split(":")[0]}' twice to ${target} as both sync and async. Observers must be either sync or async, they cannot be both. This is likely a mistake, you should either remove the code that added the observer a second time, or update it to always be sync or async. The method was ${String(method)}.`, !(listener.kind === ListenerKind.ADD && kind === ListenerKind.ADD && listener.sync !== sync));
        listener.kind = kind;
        listener.sync = sync;
      }
    }
  }
  writableListeners() {
    if (this._flattenedVersion === currentListenerVersion && (this.source === this.proto || this._inheritedEnd === -1)) {
      if (true) {
        counters.reopensAfterFlatten++;
      }
      currentListenerVersion++;
    }
    if (this._inheritedEnd === -1) {
      this._inheritedEnd = 0;
      this._listeners = [];
    }
    return this._listeners;
  }
  /**
    Flattening is based on a global revision counter. If the revision has
    bumped it means that somewhere in a class inheritance chain something has
    changed, so we need to reflatten everything. This can only happen if:
     1. A meta has been flattened (listener has been called)
    2. The meta is a prototype meta with children who have inherited its
       listeners
    3. A new listener is subsequently added to the meta (e.g. via `.reopen()`)
     This is a very rare occurrence, so while the counter is global it shouldn't
    be updated very often in practice.
  */
  flattenedListeners() {
    if (true) {
      counters.flattenedListenersCalls++;
    }
    if (this._flattenedVersion < currentListenerVersion) {
      if (true) {
        counters.listenersFlattened++;
      }
      let parent = this.parent;
      if (parent !== null) {
        let parentListeners = parent.flattenedListeners();
        if (parentListeners !== void 0) {
          if (this._listeners === void 0) {
            if (true) {
              counters.parentListenersUsed++;
            }
            this._listeners = parentListeners;
          } else {
            let listeners = this._listeners;
            if (this._inheritedEnd > 0) {
              listeners.splice(0, this._inheritedEnd);
              this._inheritedEnd = 0;
            }
            for (let listener of parentListeners) {
              let index = indexOfListener(listeners, listener.event, listener.target, listener.method);
              if (index === -1) {
                if (true) {
                  counters.listenersInherited++;
                }
                listeners.unshift(listener);
                this._inheritedEnd++;
              }
            }
          }
        }
      }
      this._flattenedVersion = currentListenerVersion;
    }
    return this._listeners;
  }
  /** @internal */
  matchingListeners(eventName) {
    let listeners = this.flattenedListeners();
    let result;
    if (true) {
      counters.matchingListenersCalls++;
    }
    if (listeners !== void 0) {
      for (let listener of listeners) {
        if (listener.event === eventName && (listener.kind === ListenerKind.ADD || listener.kind === ListenerKind.ONCE)) {
          if (result === void 0) {
            result = [];
          }
          result.push(listener.target, listener.method, listener.kind === ListenerKind.ONCE);
        }
      }
    }
    return result;
  }
  /** @internal */
  observerEvents() {
    let listeners = this.flattenedListeners();
    let result;
    if (true) {
      counters.observerEventsCalls++;
    }
    if (listeners !== void 0) {
      for (let listener of listeners) {
        if ((listener.kind === ListenerKind.ADD || listener.kind === ListenerKind.ONCE) && listener.event.indexOf(":change") !== -1) {
          if (result === void 0) {
            result = [];
          }
          result.push(listener);
        }
      }
    }
    return result;
  }
};
var getPrototypeOf = Object.getPrototypeOf;
var metaStore = /* @__PURE__ */ new WeakMap();
function setMeta(obj, meta3) {
  !(obj !== null) && assert("Cannot call `setMeta` on null", obj !== null);
  !(obj !== void 0) && assert("Cannot call `setMeta` on undefined", obj !== void 0);
  !(typeof obj === "object" || typeof obj === "function") && assert(`Cannot call \`setMeta\` on ${typeof obj}`, typeof obj === "object" || typeof obj === "function");
  if (true) {
    counters.setCalls++;
  }
  metaStore.set(obj, meta3);
}
function peekMeta(obj) {
  !(obj !== null) && assert("Cannot call `peekMeta` on null", obj !== null);
  !(obj !== void 0) && assert("Cannot call `peekMeta` on undefined", obj !== void 0);
  !(typeof obj === "object" || typeof obj === "function") && assert(`Cannot call \`peekMeta\` on ${typeof obj}`, typeof obj === "object" || typeof obj === "function");
  if (true) {
    counters.peekCalls++;
  }
  let meta3 = metaStore.get(obj);
  if (meta3 !== void 0) {
    return meta3;
  }
  let pointer = getPrototypeOf(obj);
  while (pointer !== null) {
    if (true) {
      counters.peekPrototypeWalks++;
    }
    meta3 = metaStore.get(pointer);
    if (meta3 !== void 0) {
      if (meta3.proto !== pointer) {
        meta3.proto = pointer;
      }
      return meta3;
    }
    pointer = getPrototypeOf(pointer);
  }
  return null;
}
var meta = function meta2(obj) {
  !(obj !== null) && assert("Cannot call `meta` on null", obj !== null);
  !(obj !== void 0) && assert("Cannot call `meta` on undefined", obj !== void 0);
  !(typeof obj === "object" || typeof obj === "function") && assert(`Cannot call \`meta\` on ${typeof obj}`, typeof obj === "object" || typeof obj === "function");
  if (true) {
    counters.metaCalls++;
  }
  let maybeMeta = peekMeta(obj);
  if (maybeMeta !== null && maybeMeta.source === obj) {
    return maybeMeta;
  }
  let newMeta = new Meta(obj);
  setMeta(obj, newMeta);
  return newMeta;
};
if (true) {
  meta._counters = counters;
}
function indexOfListener(listeners, event, target, method) {
  for (let i = listeners.length - 1; i >= 0; i--) {
    let listener = listeners[i];
    !listener && assert("has listener", listener);
    if (listener.event === event && listener.target === target && listener.method === method) {
      return i;
    }
  }
  return -1;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/is_proxy-DxRbm8wn.js
var PROXIES = /* @__PURE__ */ new WeakSet();
function isProxy(value) {
  if (isObject(value)) {
    return PROXIES.has(value);
  }
  return false;
}
function setProxy(object) {
  if (isObject(object)) {
    PROXIES.add(object);
  }
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/array/-internals.js
var EMBER_ARRAYS = /* @__PURE__ */ new WeakSet();
function setEmberArray(obj) {
  EMBER_ARRAYS.add(obj);
}
function isEmberArray(obj) {
  return EMBER_ARRAYS.has(obj);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/cache-qDyqAcpg.js
var Cache = class {
  size = 0;
  misses = 0;
  hits = 0;
  constructor(limit, func, store = /* @__PURE__ */ new Map()) {
    this.limit = limit;
    this.func = func;
    this.store = store;
  }
  get(key) {
    if (this.store.has(key)) {
      this.hits++;
      return this.store.get(key);
    } else {
      this.misses++;
      return this.set(key, this.func(key));
    }
  }
  set(key, value) {
    if (this.limit > this.size) {
      this.size++;
      this.store.set(key, value);
    }
    return value;
  }
  purge() {
    this.store.clear();
    this.size = 0;
    this.hits = 0;
    this.misses = 0;
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/ember/version.js
var Version = "6.10.0";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/cache-DtDz7X5V.js
function objectAt(array, index) {
  if (Array.isArray(array)) {
    return array[index];
  } else {
    return array.objectAt(index);
  }
}
var SELF_TAG = symbol("SELF_TAG");
function tagForProperty(obj, propertyKey, addMandatorySetter = false, meta3) {
  let customTagFor = getCustomTagFor(obj);
  if (customTagFor !== void 0) {
    return customTagFor(obj, propertyKey, addMandatorySetter);
  }
  let tag = tagFor(obj, propertyKey, meta3);
  if (addMandatorySetter) {
    setupMandatorySetter(tag, obj, propertyKey);
  }
  return tag;
}
function tagForObject(obj) {
  if (isObject(obj)) {
    if (true) {
      !!isDestroyed(obj) && assert(isDestroyed(obj) ? `Cannot create a new tag for \`${toString(obj)}\` after it has been destroyed.` : "", !isDestroyed(obj));
    }
    return tagFor(obj, SELF_TAG);
  }
  return CONSTANT_TAG;
}
function markObjectAsDirty(obj, propertyKey) {
  dirtyTagFor(obj, propertyKey);
  dirtyTagFor(obj, SELF_TAG);
}
var CHAIN_PASS_THROUGH = /* @__PURE__ */ new WeakSet();
function finishLazyChains(meta3, key, value) {
  let lazyTags = meta3.readableLazyChainsFor(key);
  if (lazyTags === void 0) {
    return;
  }
  if (isObject(value)) {
    for (let [tag, deps] of lazyTags) {
      UPDATE_TAG(tag, getChainTagsForKey(value, deps, tagMetaFor(value), peekMeta(value)));
    }
  }
  lazyTags.length = 0;
}
function getChainTagsForKeys(obj, keys, tagMeta, meta3) {
  let tags = [];
  for (let key of keys) {
    getChainTags(tags, obj, key, tagMeta, meta3);
  }
  return combine(tags);
}
function getChainTagsForKey(obj, key, tagMeta, meta3) {
  return combine(getChainTags([], obj, key, tagMeta, meta3));
}
function getChainTags(chainTags, obj, path, tagMeta, meta$1) {
  let current = obj;
  let currentTagMeta = tagMeta;
  let currentMeta = meta$1;
  let pathLength = path.length;
  let segmentEnd = -1;
  let segment, descriptor;
  while (true) {
    let lastSegmentEnd = segmentEnd + 1;
    segmentEnd = path.indexOf(".", lastSegmentEnd);
    if (segmentEnd === -1) {
      segmentEnd = pathLength;
    }
    segment = path.slice(lastSegmentEnd, segmentEnd);
    if (segment === "@each" && segmentEnd !== pathLength) {
      lastSegmentEnd = segmentEnd + 1;
      segmentEnd = path.indexOf(".", lastSegmentEnd);
      let arrLength = current.length;
      if (typeof arrLength !== "number" || // TODO: should the second test be `isEmberArray` instead?
      !(Array.isArray(current) || "objectAt" in current)) {
        break;
      } else if (arrLength === 0) {
        chainTags.push(tagForProperty(current, "[]"));
        break;
      }
      if (segmentEnd === -1) {
        segment = path.slice(lastSegmentEnd);
      } else {
        segment = path.slice(lastSegmentEnd, segmentEnd);
      }
      for (let i = 0; i < arrLength; i++) {
        let item = objectAt(current, i);
        if (item) {
          !(typeof item === "object") && assert(`When using @each to observe the array \`${current.toString()}\`, the items in the array must be objects`, typeof item === "object");
          chainTags.push(tagForProperty(item, segment, true));
          currentMeta = peekMeta(item);
          descriptor = currentMeta !== null ? currentMeta.peekDescriptors(segment) : void 0;
          if (descriptor !== void 0 && typeof descriptor.altKey === "string") {
            item[segment];
          }
        }
      }
      chainTags.push(tagForProperty(current, "[]", true, currentTagMeta));
      break;
    }
    let propertyTag = tagForProperty(current, segment, true, currentTagMeta);
    descriptor = currentMeta !== null ? currentMeta.peekDescriptors(segment) : void 0;
    chainTags.push(propertyTag);
    if (segmentEnd === pathLength) {
      if (CHAIN_PASS_THROUGH.has(descriptor)) {
        current[segment];
      }
      break;
    }
    if (descriptor === void 0) {
      if (!(segment in current) && typeof current.unknownProperty === "function") {
        current = current.unknownProperty(segment);
      } else {
        current = current[segment];
      }
    } else if (CHAIN_PASS_THROUGH.has(descriptor)) {
      current = current[segment];
    } else {
      let instanceMeta = currentMeta.source === current ? currentMeta : meta(current);
      let lastRevision = instanceMeta.revisionFor(segment);
      if (lastRevision !== void 0 && validateTag(propertyTag, lastRevision)) {
        current = instanceMeta.valueFor(segment);
      } else {
        let lazyChains = instanceMeta.writableLazyChainsFor(segment);
        let rest = path.substring(segmentEnd + 1);
        let placeholderTag = createUpdatableTag();
        lazyChains.push([placeholderTag, rest]);
        chainTags.push(placeholderTag);
        break;
      }
    }
    if (!isObject(current)) {
      break;
    }
    currentTagMeta = tagMetaFor(current);
    currentMeta = peekMeta(current);
  }
  return chainTags;
}
function isElementDescriptor(args) {
  let [maybeTarget, maybeKey, maybeDesc] = args;
  return (
    // Ensure we have the right number of args
    args.length === 3 && // Make sure the target is a class or object (prototype)
    (typeof maybeTarget === "function" || typeof maybeTarget === "object" && maybeTarget !== null) && // Make sure the key is a string
    typeof maybeKey === "string" && // Make sure the descriptor is the right shape
    (typeof maybeDesc === "object" && maybeDesc !== null || maybeDesc === void 0)
  );
}
function nativeDescDecorator(propertyDesc) {
  let decorator = function() {
    return propertyDesc;
  };
  setClassicDecorator(decorator);
  return decorator;
}
var ComputedDescriptor = class {
  enumerable = true;
  configurable = true;
  _dependentKeys = void 0;
  _meta = void 0;
  setup(_obj, keyName, _propertyDesc, meta3) {
    meta3.writeDescriptors(keyName, this);
  }
  teardown(_obj, keyName, meta3) {
    meta3.removeDescriptors(keyName);
  }
};
var COMPUTED_GETTERS;
if (true) {
  COMPUTED_GETTERS = /* @__PURE__ */ new WeakSet();
}
function DESCRIPTOR_GETTER_FUNCTION(name, descriptor) {
  function getter() {
    return descriptor.get(this, name);
  }
  if (true) {
    COMPUTED_GETTERS.add(getter);
  }
  return getter;
}
function DESCRIPTOR_SETTER_FUNCTION(name, descriptor) {
  let set2 = function CPSETTER_FUNCTION(value) {
    return descriptor.set(this, name, value);
  };
  COMPUTED_SETTERS.add(set2);
  return set2;
}
var COMPUTED_SETTERS = /* @__PURE__ */ new WeakSet();
function makeComputedDecorator(desc, DecoratorClass) {
  let decorator = function COMPUTED_DECORATOR(target, key, propertyDesc, maybeMeta, isClassicDecorator2) {
    !(isClassicDecorator2 || !propertyDesc || !propertyDesc.get || !COMPUTED_GETTERS.has(propertyDesc.get)) && assert(`Only one computed property decorator can be applied to a class field or accessor, but '${key}' was decorated twice. You may have added the decorator to both a getter and setter, which is unnecessary.`, isClassicDecorator2 || !propertyDesc || !propertyDesc.get || !COMPUTED_GETTERS.has(propertyDesc.get));
    let meta$1 = arguments.length === 3 ? meta(target) : maybeMeta;
    desc.setup(target, key, propertyDesc, meta$1);
    let computedDesc = {
      enumerable: desc.enumerable,
      configurable: desc.configurable,
      get: DESCRIPTOR_GETTER_FUNCTION(key, desc),
      set: DESCRIPTOR_SETTER_FUNCTION(key, desc)
    };
    return computedDesc;
  };
  setClassicDecorator(decorator, desc);
  Object.setPrototypeOf(decorator, DecoratorClass.prototype);
  return decorator;
}
var DECORATOR_DESCRIPTOR_MAP = /* @__PURE__ */ new WeakMap();
function descriptorForProperty(obj, keyName, _meta) {
  !(obj !== null) && assert("Cannot call `descriptorForProperty` on null", obj !== null);
  !(obj !== void 0) && assert("Cannot call `descriptorForProperty` on undefined", obj !== void 0);
  !(typeof obj === "object" || typeof obj === "function") && assert(`Cannot call \`descriptorForProperty\` on ${typeof obj}`, typeof obj === "object" || typeof obj === "function");
  let meta3 = _meta === void 0 ? peekMeta(obj) : _meta;
  if (meta3 !== null) {
    return meta3.peekDescriptors(keyName);
  }
}
function descriptorForDecorator(dec) {
  return DECORATOR_DESCRIPTOR_MAP.get(dec);
}
function isClassicDecorator(dec) {
  return typeof dec === "function" && DECORATOR_DESCRIPTOR_MAP.has(dec);
}
function setClassicDecorator(dec, value = true) {
  DECORATOR_DESCRIPTOR_MAP.set(dec, value);
}
var END_WITH_EACH_REGEX = /\.@each$/;
function expandProperties(pattern, callback) {
  !(typeof pattern === "string") && assert(`A computed property key must be a string, you passed ${typeof pattern} ${pattern}`, typeof pattern === "string");
  !(pattern.indexOf(" ") === -1) && assert('Brace expanded properties cannot contain spaces, e.g. "user.{firstName, lastName}" should be "user.{firstName,lastName}"', pattern.indexOf(" ") === -1);
  !(pattern.match(/\{[^}{]*\{|\}[^}{]*\}|\{[^}]*$/g) === null) && assert(`Brace expanded properties have to be balanced and cannot be nested, pattern: ${pattern}`, pattern.match(/\{[^}{]*\{|\}[^}{]*\}|\{[^}]*$/g) === null);
  let start = pattern.indexOf("{");
  if (start < 0) {
    callback(pattern.replace(END_WITH_EACH_REGEX, ".[]"));
  } else {
    dive("", pattern, start, callback);
  }
}
function dive(prefix, pattern, start, callback) {
  let end = pattern.indexOf("}"), i = 0, newStart, arrayLength;
  let tempArr = pattern.substring(start + 1, end).split(",");
  let after = pattern.substring(end + 1);
  prefix = prefix + pattern.substring(0, start);
  arrayLength = tempArr.length;
  while (i < arrayLength) {
    newStart = after.indexOf("{");
    if (newStart < 0) {
      callback((prefix + tempArr[i++] + after).replace(END_WITH_EACH_REGEX, ".[]"));
    } else {
      dive(prefix + tempArr[i++], after, newStart, callback);
    }
  }
}
var AFTER_OBSERVERS = ":change";
function changeEvent(keyName) {
  return keyName + AFTER_OBSERVERS;
}
function addListener(obj, eventName, target, method, once2, sync = true) {
  !(Boolean(obj) && Boolean(eventName)) && assert("You must pass at least an object and event name to addListener", Boolean(obj) && Boolean(eventName));
  if (!method && "function" === typeof target) {
    method = target;
    target = null;
  }
  meta(obj).addToListeners(eventName, target, method, once2 === true, sync);
}
function removeListener(obj, eventName, targetOrFunction, functionOrName) {
  !(Boolean(obj) && Boolean(eventName) && (typeof targetOrFunction === "function" || typeof targetOrFunction === "object" && Boolean(functionOrName))) && assert("You must pass at least an object, event name, and method or target and method/method name to removeListener", Boolean(obj) && Boolean(eventName) && (typeof targetOrFunction === "function" || typeof targetOrFunction === "object" && Boolean(functionOrName)));
  let target, method;
  if (typeof targetOrFunction === "object") {
    target = targetOrFunction;
    method = functionOrName;
  } else {
    target = null;
    method = targetOrFunction;
  }
  let m = meta(obj);
  m.removeFromListeners(eventName, target, method);
}
function sendEvent(obj, eventName, params, actions, _meta) {
  if (actions === void 0) {
    let meta3 = _meta === void 0 ? peekMeta(obj) : _meta;
    actions = meta3 !== null ? meta3.matchingListeners(eventName) : void 0;
  }
  if (actions === void 0 || actions.length === 0) {
    return false;
  }
  for (let i = actions.length - 3; i >= 0; i -= 3) {
    let target = actions[i];
    let method = actions[i + 1];
    let once2 = actions[i + 2];
    if (!method) {
      continue;
    }
    if (once2) {
      removeListener(obj, eventName, target, method);
    }
    if (!target) {
      target = obj;
    }
    let type = typeof method;
    if (type === "string" || type === "symbol") {
      method = target[method];
    }
    method.apply(target, params);
  }
  return true;
}
function hasListeners(obj, eventName) {
  let meta3 = peekMeta(obj);
  if (meta3 === null) {
    return false;
  }
  let matched = meta3.matchingListeners(eventName);
  return matched !== void 0 && matched.length > 0;
}
var SYNC_DEFAULT = !ENV._DEFAULT_ASYNC_OBSERVERS;
var SYNC_OBSERVERS = /* @__PURE__ */ new Map();
var ASYNC_OBSERVERS = /* @__PURE__ */ new Map();
function addObserver(obj, path, target, method, sync = SYNC_DEFAULT) {
  let eventName = changeEvent(path);
  addListener(obj, eventName, target, method, false, sync);
  let meta3 = peekMeta(obj);
  if (meta3 === null || !(meta3.isPrototypeMeta(obj) || meta3.isInitializing())) {
    activateObserver(obj, eventName, sync);
  }
}
function removeObserver(obj, path, target, method, sync = SYNC_DEFAULT) {
  let eventName = changeEvent(path);
  let meta3 = peekMeta(obj);
  if (meta3 === null || !(meta3.isPrototypeMeta(obj) || meta3.isInitializing())) {
    deactivateObserver(obj, eventName, sync);
  }
  removeListener(obj, eventName, target, method);
}
function getOrCreateActiveObserversFor(target, sync) {
  let observerMap = sync === true ? SYNC_OBSERVERS : ASYNC_OBSERVERS;
  if (!observerMap.has(target)) {
    observerMap.set(target, /* @__PURE__ */ new Map());
    registerDestructor(target, () => destroyObservers(target), true);
  }
  return observerMap.get(target);
}
function activateObserver(target, eventName, sync = false) {
  let activeObservers = getOrCreateActiveObserversFor(target, sync);
  if (activeObservers.has(eventName)) {
    activeObservers.get(eventName).count++;
  } else {
    let path = eventName.substring(0, eventName.lastIndexOf(":"));
    let tag = getChainTagsForKey(target, path, tagMetaFor(target), peekMeta(target));
    activeObservers.set(eventName, {
      count: 1,
      path,
      tag,
      lastRevision: valueForTag(tag),
      suspended: false
    });
  }
}
var DEACTIVATE_SUSPENDED = false;
var SCHEDULED_DEACTIVATE = [];
function deactivateObserver(target, eventName, sync = false) {
  if (DEACTIVATE_SUSPENDED === true) {
    SCHEDULED_DEACTIVATE.push([target, eventName, sync]);
    return;
  }
  let observerMap = sync === true ? SYNC_OBSERVERS : ASYNC_OBSERVERS;
  let activeObservers = observerMap.get(target);
  if (activeObservers !== void 0) {
    let observer = activeObservers.get(eventName);
    observer.count--;
    if (observer.count === 0) {
      activeObservers.delete(eventName);
      if (activeObservers.size === 0) {
        observerMap.delete(target);
      }
    }
  }
}
function suspendedObserverDeactivation() {
  DEACTIVATE_SUSPENDED = true;
}
function resumeObserverDeactivation() {
  DEACTIVATE_SUSPENDED = false;
  for (let [target, eventName, sync] of SCHEDULED_DEACTIVATE) {
    deactivateObserver(target, eventName, sync);
  }
  SCHEDULED_DEACTIVATE = [];
}
function revalidateObservers(target) {
  if (ASYNC_OBSERVERS.has(target)) {
    ASYNC_OBSERVERS.get(target).forEach((observer) => {
      observer.tag = getChainTagsForKey(target, observer.path, tagMetaFor(target), peekMeta(target));
      observer.lastRevision = valueForTag(observer.tag);
    });
  }
  if (SYNC_OBSERVERS.has(target)) {
    SYNC_OBSERVERS.get(target).forEach((observer) => {
      observer.tag = getChainTagsForKey(target, observer.path, tagMetaFor(target), peekMeta(target));
      observer.lastRevision = valueForTag(observer.tag);
    });
  }
}
var lastKnownRevision = 0;
function flushAsyncObservers(_schedule) {
  let currentRevision = valueForTag(CURRENT_TAG);
  if (lastKnownRevision === currentRevision) {
    return;
  }
  lastKnownRevision = currentRevision;
  ASYNC_OBSERVERS.forEach((activeObservers, target) => {
    let meta3 = peekMeta(target);
    activeObservers.forEach((observer, eventName) => {
      if (!validateTag(observer.tag, observer.lastRevision)) {
        let sendObserver = () => {
          try {
            sendEvent(target, eventName, [target, observer.path], void 0, meta3);
          } finally {
            observer.tag = getChainTagsForKey(target, observer.path, tagMetaFor(target), peekMeta(target));
            observer.lastRevision = valueForTag(observer.tag);
          }
        };
        if (_schedule) {
          _schedule("actions", sendObserver);
        } else {
          sendObserver();
        }
      }
    });
  });
}
function flushSyncObservers() {
  SYNC_OBSERVERS.forEach((activeObservers, target) => {
    let meta3 = peekMeta(target);
    activeObservers.forEach((observer, eventName) => {
      if (!observer.suspended && !validateTag(observer.tag, observer.lastRevision)) {
        try {
          observer.suspended = true;
          sendEvent(target, eventName, [target, observer.path], void 0, meta3);
        } finally {
          observer.tag = getChainTagsForKey(target, observer.path, tagMetaFor(target), peekMeta(target));
          observer.lastRevision = valueForTag(observer.tag);
          observer.suspended = false;
        }
      }
    });
  });
}
function setObserverSuspended(target, property, suspended) {
  let activeObservers = SYNC_OBSERVERS.get(target);
  if (!activeObservers) {
    return;
  }
  let observer = activeObservers.get(changeEvent(property));
  if (observer) {
    observer.suspended = suspended;
  }
}
function destroyObservers(target) {
  if (SYNC_OBSERVERS.size > 0) SYNC_OBSERVERS.delete(target);
  if (ASYNC_OBSERVERS.size > 0) ASYNC_OBSERVERS.delete(target);
}
var PROPERTY_DID_CHANGE = Symbol("PROPERTY_DID_CHANGE");
function hasPropertyDidChange(obj) {
  return obj != null && typeof obj === "object" && typeof obj[PROPERTY_DID_CHANGE] === "function";
}
var deferred = 0;
function notifyPropertyChange(obj, keyName, _meta, value) {
  let meta3 = _meta === void 0 ? peekMeta(obj) : _meta;
  if (meta3 !== null && (meta3.isInitializing() || meta3.isPrototypeMeta(obj))) {
    return;
  }
  markObjectAsDirty(obj, keyName);
  if (deferred <= 0) {
    flushSyncObservers();
  }
  if (PROPERTY_DID_CHANGE in obj) {
    !hasPropertyDidChange(obj) && assert("property did change hook is invalid", hasPropertyDidChange(obj));
    if (arguments.length === 4) {
      obj[PROPERTY_DID_CHANGE](keyName, value);
    } else {
      obj[PROPERTY_DID_CHANGE](keyName);
    }
  }
}
function beginPropertyChanges() {
  deferred++;
  suspendedObserverDeactivation();
}
function endPropertyChanges() {
  deferred--;
  if (deferred <= 0) {
    flushSyncObservers();
    resumeObserverDeactivation();
  }
}
function changeProperties(callback) {
  beginPropertyChanges();
  try {
    callback();
  } finally {
    endPropertyChanges();
  }
}
var DEEP_EACH_REGEX = /\.@each\.[^.]+\./;
function noop2() {
}
var ComputedProperty = class extends ComputedDescriptor {
  _readOnly = false;
  _hasConfig = false;
  _getter = void 0;
  _setter = void 0;
  constructor(args) {
    super();
    let maybeConfig = args[args.length - 1];
    if (typeof maybeConfig === "function" || maybeConfig !== null && typeof maybeConfig === "object") {
      this._hasConfig = true;
      let config2 = args.pop();
      if (typeof config2 === "function") {
        !!isClassicDecorator(config2) && assert(`You attempted to pass a computed property instance to computed(). Computed property instances are decorator functions, and cannot be passed to computed() because they cannot be turned into decorators twice`, !isClassicDecorator(config2));
        this._getter = config2;
      } else {
        const objectConfig = config2;
        !(typeof objectConfig === "object" && !Array.isArray(objectConfig)) && assert("computed expects a function or an object as last argument.", typeof objectConfig === "object" && !Array.isArray(objectConfig));
        !Object.keys(objectConfig).every((key) => key === "get" || key === "set") && assert("Config object passed to computed can only contain `get` and `set` keys.", Object.keys(objectConfig).every((key) => key === "get" || key === "set"));
        !(Boolean(objectConfig.get) || Boolean(objectConfig.set)) && assert("Computed properties must receive a getter or a setter, you passed none.", Boolean(objectConfig.get) || Boolean(objectConfig.set));
        this._getter = objectConfig.get || noop2;
        this._setter = objectConfig.set;
      }
    }
    if (args.length > 0) {
      this._property(...args);
    }
  }
  setup(obj, keyName, propertyDesc, meta3) {
    super.setup(obj, keyName, propertyDesc, meta3);
    !!(propertyDesc && typeof propertyDesc.value === "function") && assert(`@computed can only be used on accessors or fields, attempted to use it with ${keyName} but that was a method. Try converting it to a getter (e.g. \`get ${keyName}() {}\`)`, !(propertyDesc && typeof propertyDesc.value === "function"));
    !(!propertyDesc || !propertyDesc.initializer) && assert(`@computed can only be used on empty fields. ${keyName} has an initial value (e.g. \`${keyName} = someValue\`)`, !propertyDesc || !propertyDesc.initializer);
    !!(this._hasConfig && propertyDesc && (typeof propertyDesc.get === "function" || typeof propertyDesc.set === "function")) && assert(`Attempted to apply a computed property that already has a getter/setter to a ${keyName}, but it is a method or an accessor. If you passed @computed a function or getter/setter (e.g. \`@computed({ get() { ... } })\`), then it must be applied to a field`, !(this._hasConfig && propertyDesc && (typeof propertyDesc.get === "function" || typeof propertyDesc.set === "function")));
    if (this._hasConfig === false) {
      !(propertyDesc && (typeof propertyDesc.get === "function" || typeof propertyDesc.set === "function")) && assert(`Attempted to use @computed on ${keyName}, but it did not have a getter or a setter. You must either pass a get a function or getter/setter to @computed directly (e.g. \`@computed({ get() { ... } })\`) or apply @computed directly to a getter/setter`, propertyDesc && (typeof propertyDesc.get === "function" || typeof propertyDesc.set === "function"));
      let {
        get: get3,
        set: set2
      } = propertyDesc;
      if (get3 !== void 0) {
        this._getter = get3;
      }
      if (set2 !== void 0) {
        this._setter = function setterWrapper(_key, value) {
          let ret = set2.call(this, value);
          if (get3 !== void 0) {
            return typeof ret === "undefined" ? get3.call(this) : ret;
          }
          return ret;
        };
      }
    }
  }
  _property(...passedArgs) {
    let args = [];
    function addArg(property) {
      !(DEEP_EACH_REGEX.test(property) === false) && assert(`Dependent keys containing @each only work one level deep. You used the key "${property}" which is invalid. Please create an intermediary computed property or switch to using tracked properties.`, DEEP_EACH_REGEX.test(property) === false);
      args.push(property);
    }
    for (let arg of passedArgs) {
      expandProperties(arg, addArg);
    }
    this._dependentKeys = args;
  }
  get(obj, keyName) {
    let meta$1 = meta(obj);
    let tagMeta = tagMetaFor(obj);
    let propertyTag = tagFor(obj, keyName, tagMeta);
    let ret;
    let revision = meta$1.revisionFor(keyName);
    if (revision !== void 0 && validateTag(propertyTag, revision)) {
      ret = meta$1.valueFor(keyName);
    } else {
      !(this._dependentKeys === void 0 || !isDestroyed(obj)) && assert(`Attempted to access the computed ${obj}.${keyName} on a destroyed object, which is not allowed`, this._dependentKeys === void 0 || !isDestroyed(obj));
      let {
        _getter,
        _dependentKeys
      } = this;
      untrack(() => {
        ret = _getter.call(obj, keyName);
      });
      if (_dependentKeys !== void 0) {
        UPDATE_TAG(propertyTag, getChainTagsForKeys(obj, _dependentKeys, tagMeta, meta$1));
        if (true) {
          ALLOW_CYCLES.set(propertyTag, true);
        }
      }
      meta$1.setValueFor(keyName, ret);
      meta$1.setRevisionFor(keyName, valueForTag(propertyTag));
      finishLazyChains(meta$1, keyName, ret);
    }
    consumeTag(propertyTag);
    if (Array.isArray(ret)) {
      consumeTag(tagFor(ret, "[]"));
    }
    return ret;
  }
  set(obj, keyName, value) {
    if (this._readOnly) {
      this._throwReadOnlyError(obj, keyName);
    }
    !(this._setter !== void 0) && assert(`Cannot override the computed property \`${keyName}\` on ${toString(obj)}.`, this._setter !== void 0);
    let meta$1 = meta(obj);
    if (
      // ensure that we only run this once, while the component is being instantiated
      meta$1.isInitializing() && this._dependentKeys !== void 0 && this._dependentKeys.length > 0 && typeof obj[PROPERTY_DID_CHANGE] === "function" && obj.isComponent
    ) {
      !hasPropertyDidChange(obj) && assert("property did change hook is invalid", hasPropertyDidChange(obj));
      addObserver(obj, keyName, () => {
        obj[PROPERTY_DID_CHANGE](keyName);
      }, void 0, true);
    }
    let ret;
    try {
      beginPropertyChanges();
      ret = this._set(obj, keyName, value, meta$1);
      finishLazyChains(meta$1, keyName, ret);
      let tagMeta = tagMetaFor(obj);
      let propertyTag = tagFor(obj, keyName, tagMeta);
      let {
        _dependentKeys
      } = this;
      if (_dependentKeys !== void 0) {
        UPDATE_TAG(propertyTag, getChainTagsForKeys(obj, _dependentKeys, tagMeta, meta$1));
        if (true) {
          ALLOW_CYCLES.set(propertyTag, true);
        }
      }
      meta$1.setRevisionFor(keyName, valueForTag(propertyTag));
    } finally {
      endPropertyChanges();
    }
    return ret;
  }
  _throwReadOnlyError(obj, keyName) {
    throw new Error(`Cannot set read-only property "${keyName}" on object: ${inspect(obj)}`);
  }
  _set(obj, keyName, value, meta3) {
    let hadCachedValue = meta3.revisionFor(keyName) !== void 0;
    let cachedValue = meta3.valueFor(keyName);
    let ret;
    let {
      _setter
    } = this;
    setObserverSuspended(obj, keyName, true);
    try {
      ret = _setter.call(obj, keyName, value, cachedValue);
    } finally {
      setObserverSuspended(obj, keyName, false);
    }
    if (hadCachedValue && cachedValue === ret) {
      return ret;
    }
    meta3.setValueFor(keyName, ret);
    notifyPropertyChange(obj, keyName, meta3, value);
    return ret;
  }
  /* called before property is overridden */
  teardown(obj, keyName, meta3) {
    if (meta3.revisionFor(keyName) !== void 0) {
      meta3.setRevisionFor(keyName, void 0);
      meta3.setValueFor(keyName, void 0);
    }
    super.teardown(obj, keyName, meta3);
  }
};
var ComputedDecoratorImpl = class extends Function {
  /**
    Call on a computed property to set it into read-only mode. When in this
    mode the computed property will throw an error when set.
     Example:
     ```javascript
    import { computed, set } from '@ember/object';
     class Person {
      @computed().readOnly()
      get guid() {
        return 'guid-guid-guid';
      }
    }
     let person = new Person();
    set(person, 'guid', 'new-guid'); // will throw an exception
    ```
     Classic Class Example:
     ```javascript
    import EmberObject, { computed } from '@ember/object';
     let Person = EmberObject.extend({
      guid: computed(function() {
        return 'guid-guid-guid';
      }).readOnly()
    });
     let person = Person.create();
    person.set('guid', 'new-guid'); // will throw an exception
    ```
     @method readOnly
    @return {ComputedProperty} this
    @chainable
    @public
  */
  readOnly() {
    let desc = descriptorForDecorator(this);
    !!(desc._setter && desc._setter !== desc._getter) && assert("Computed properties that define a setter using the new syntax cannot be read-only", !(desc._setter && desc._setter !== desc._getter));
    desc._readOnly = true;
    return this;
  }
  /**
    In some cases, you may want to annotate computed properties with additional
    metadata about how they function or what values they operate on. For example,
    computed property functions may close over variables that are then no longer
    available for introspection. You can pass a hash of these values to a
    computed property.
     Example:
     ```javascript
    import { computed } from '@ember/object';
    import Person from 'my-app/utils/person';
     class Store {
      @computed().meta({ type: Person })
      get person() {
        let personId = this.personId;
        return Person.create({ id: personId });
      }
    }
    ```
     Classic Class Example:
     ```javascript
    import { computed } from '@ember/object';
    import Person from 'my-app/utils/person';
     const Store = EmberObject.extend({
      person: computed(function() {
        let personId = this.get('personId');
        return Person.create({ id: personId });
      }).meta({ type: Person })
    });
    ```
     The hash that you pass to the `meta()` function will be saved on the
    computed property descriptor under the `_meta` key. Ember runtime
    exposes a public API for retrieving these values from classes,
    via the `metaForProperty()` function.
     @method meta
    @param {Object} meta
    @chainable
    @public
  */
  meta(meta3) {
    let prop = descriptorForDecorator(this);
    if (arguments.length === 0) {
      return prop._meta || {};
    } else {
      prop._meta = meta3;
      return this;
    }
  }
  // TODO: Remove this when we can provide alternatives in the ecosystem to
  // addons such as ember-macro-helpers that use it.
  /** @internal */
  get _getter() {
    return descriptorForDecorator(this)._getter;
  }
  // TODO: Refactor this, this is an internal API only
  /** @internal */
  set enumerable(value) {
    descriptorForDecorator(this).enumerable = value;
  }
};
function computed(...args) {
  !!(isElementDescriptor(args.slice(0, 3)) && args.length === 5 && args[4] === true) && assert(`@computed can only be used directly as a native decorator. If you're using tracked in classic classes, add parenthesis to call it like a function: computed()`, !(isElementDescriptor(args.slice(0, 3)) && args.length === 5 && args[4] === true));
  if (isElementDescriptor(args)) {
    let decorator = makeComputedDecorator(new ComputedProperty([]), ComputedDecoratorImpl);
    return decorator(args[0], args[1], args[2]);
  }
  return makeComputedDecorator(new ComputedProperty(args), ComputedDecoratorImpl);
}
function defineProperty(obj, keyName, desc, data, _meta) {
  let meta$1 = _meta === void 0 ? meta(obj) : _meta;
  let previousDesc = descriptorForProperty(obj, keyName, meta$1);
  let wasDescriptor = previousDesc !== void 0;
  if (wasDescriptor) {
    previousDesc.teardown(obj, keyName, meta$1);
  }
  if (isClassicDecorator(desc)) {
    defineDecorator(obj, keyName, desc, meta$1);
  } else if (desc === null || desc === void 0) {
    defineValue(obj, keyName, data, wasDescriptor, true);
  } else {
    Object.defineProperty(obj, keyName, desc);
  }
  if (!meta$1.isPrototypeMeta(obj)) {
    revalidateObservers(obj);
  }
}
function defineDecorator(obj, keyName, desc, meta3) {
  let propertyDesc;
  if (true) {
    propertyDesc = desc(obj, keyName, void 0, meta3, true);
  } else {
    propertyDesc = desc(obj, keyName, void 0, meta3);
  }
  Object.defineProperty(obj, keyName, propertyDesc);
  return desc;
}
function defineValue(obj, keyName, value, wasDescriptor, enumerable = true) {
  if (wasDescriptor === true || enumerable === false) {
    Object.defineProperty(obj, keyName, {
      configurable: true,
      enumerable,
      writable: true,
      value
    });
  } else {
    if (true) {
      setWithMandatorySetter(obj, keyName, value);
    } else {
      obj[keyName] = value;
    }
  }
  return value;
}
var firstDotIndexCache = new Cache(1e3, (key) => key.indexOf("."));
function isPath(path) {
  return typeof path === "string" && firstDotIndexCache.get(path) !== -1;
}
var PROXY_CONTENT = symbol("PROXY_CONTENT");
var getPossibleMandatoryProxyValue;
if (true) {
  getPossibleMandatoryProxyValue = function getPossibleMandatoryProxyValue2(obj, keyName) {
    let content = obj[PROXY_CONTENT];
    if (content === void 0) {
      return obj[keyName];
    } else {
      return Reflect.get(content, keyName, obj);
    }
  };
}
function hasUnknownProperty(val) {
  return typeof val === "object" && val !== null && typeof val.unknownProperty === "function";
}
function get(obj, keyName) {
  !(arguments.length === 2) && assert(`Get must be called with two arguments; an object and a property key`, arguments.length === 2);
  !(obj !== void 0 && obj !== null) && assert(`Cannot call get with '${keyName}' on an undefined object.`, obj !== void 0 && obj !== null);
  !(typeof keyName === "string" || typeof keyName === "number" && !isNaN(keyName)) && assert(`The key provided to get must be a string or number, you passed ${keyName}`, typeof keyName === "string" || typeof keyName === "number" && !isNaN(keyName));
  !(typeof keyName !== "string" || keyName.lastIndexOf("this.", 0) !== 0) && assert(`'this' in paths is not supported`, typeof keyName !== "string" || keyName.lastIndexOf("this.", 0) !== 0);
  return isPath(keyName) ? _getPath(obj, keyName) : _getProp(obj, keyName);
}
function _getProp(obj, keyName) {
  if (obj == null) {
    return;
  }
  let value;
  if (typeof obj === "object" || typeof obj === "function") {
    if (true) {
      value = getPossibleMandatoryProxyValue(obj, keyName);
    } else {
      value = obj[keyName];
    }
    if (value === void 0 && typeof obj === "object" && !(keyName in obj) && hasUnknownProperty(obj)) {
      value = obj.unknownProperty(keyName);
    }
    if (isTracking()) {
      consumeTag(tagFor(obj, keyName));
      if (Array.isArray(value) || isEmberArray(value)) {
        consumeTag(tagFor(value, "[]"));
      }
    }
  } else {
    value = obj[keyName];
  }
  return value;
}
function _getPath(obj, path, forSet) {
  let parts = typeof path === "string" ? path.split(".") : path;
  for (let part of parts) {
    if (obj === void 0 || obj === null || obj.isDestroyed) {
      return void 0;
    }
    if (forSet && (part === "__proto__" || part === "constructor")) {
      return;
    }
    obj = _getProp(obj, part);
  }
  return obj;
}
_getProp("foo", "a");
_getProp("foo", 1);
_getProp({}, "a");
_getProp({}, 1);
_getProp({
  unknownProperty() {
  }
}, "a");
_getProp({
  unknownProperty() {
  }
}, 1);
get({}, "foo");
get({}, "foo.bar");
var fakeProxy = {};
setProxy(fakeProxy);
track(() => _getProp({}, "a"));
track(() => _getProp({}, 1));
track(() => _getProp({
  a: []
}, "a"));
track(() => _getProp({
  a: fakeProxy
}, "a"));
var Libraries = class {
  _registry;
  _coreLibIndex;
  constructor() {
    this._registry = [];
    this._coreLibIndex = 0;
  }
  _getLibraryByName(name) {
    let libs = this._registry;
    for (let lib of libs) {
      if (lib.name === name) {
        return lib;
      }
    }
    return void 0;
  }
  register(name, version, isCoreLibrary) {
    let index = this._registry.length;
    if (!this._getLibraryByName(name)) {
      if (isCoreLibrary) {
        index = this._coreLibIndex++;
      }
      this._registry.splice(index, 0, {
        name,
        version
      });
    } else {
      warn2(`Library "${name}" is already registered with Ember.`, false, {
        id: "ember-metal.libraries-register"
      });
    }
  }
  registerCoreLibrary(name, version) {
    this.register(name, version, true);
  }
  deRegister(name) {
    let lib = this._getLibraryByName(name);
    let index;
    if (lib) {
      index = this._registry.indexOf(lib);
      this._registry.splice(index, 1);
    }
  }
};
if (true) {
  Libraries.prototype.logVersions = function() {
    let libs = this._registry;
    let nameLengths = libs.map((item) => get(item, "name.length"));
    !(nameLengths instanceof Array && nameLengths.every((n) => typeof n === "number")) && assert("nameLengths is number array", nameLengths instanceof Array && nameLengths.every((n) => typeof n === "number"));
    let maxNameLength = Math.max.apply(null, nameLengths);
    debug("-------------------------------");
    for (let lib of libs) {
      let spaces = new Array(maxNameLength - lib.name.length + 1).join(" ");
      debug([lib.name, spaces, " : ", lib.version].join(""));
    }
    debug("-------------------------------");
  };
}
var LIBRARIES = new Libraries();
LIBRARIES.registerCoreLibrary("Ember", Version);
var DEBUG_INJECTION_FUNCTIONS;
if (true) {
  DEBUG_INJECTION_FUNCTIONS = /* @__PURE__ */ new WeakMap();
}
function inject(type, ...args) {
  !(typeof type === "string") && assert("a string type must be provided to inject", typeof type === "string");
  let elementDescriptor;
  let name;
  if (isElementDescriptor(args)) {
    elementDescriptor = args;
  } else if (typeof args[0] === "string") {
    name = args[0];
  }
  let getInjection = function(propertyName) {
    let owner = getOwner2(this) || this.container;
    !Boolean(owner) && assert(`Attempting to lookup an injected property on an object without a container, ensure that the object was instantiated via a container.`, Boolean(owner));
    return owner.lookup(`${type}:${name || propertyName}`);
  };
  if (true) {
    DEBUG_INJECTION_FUNCTIONS.set(getInjection, {
      type,
      name
    });
  }
  let decorator = computed({
    get: getInjection,
    set(keyName, value) {
      defineProperty(this, keyName, null, value);
    }
  });
  if (elementDescriptor) {
    return decorator(elementDescriptor[0], elementDescriptor[1], elementDescriptor[2]);
  } else {
    return decorator;
  }
}
function tracked(...args) {
  !!(isElementDescriptor(args.slice(0, 3)) && args.length === 5 && args[4] === true) && assert(`@tracked can only be used directly as a native decorator. If you're using tracked in classic classes, add parenthesis to call it like a function: tracked()`, !(isElementDescriptor(args.slice(0, 3)) && args.length === 5 && args[4] === true));
  if (!isElementDescriptor(args)) {
    let propertyDesc = args[0];
    !(args.length === 0 || typeof propertyDesc === "object" && propertyDesc !== null) && assert(`tracked() may only receive an options object containing 'value' or 'initializer', received ${propertyDesc}`, args.length === 0 || typeof propertyDesc === "object" && propertyDesc !== null);
    if (propertyDesc) {
      let keys = Object.keys(propertyDesc);
      !(keys.length <= 1 && (keys[0] === void 0 || keys[0] === "value" || keys[0] === "initializer")) && assert(`The options object passed to tracked() may only contain a 'value' or 'initializer' property, not both. Received: [${keys}]`, keys.length <= 1 && (keys[0] === void 0 || keys[0] === "value" || keys[0] === "initializer"));
      !(!("initializer" in propertyDesc) || typeof propertyDesc.initializer === "function") && assert(`The initializer passed to tracked must be a function. Received ${propertyDesc.initializer}`, !("initializer" in propertyDesc) || typeof propertyDesc.initializer === "function");
    }
    let initializer = propertyDesc ? propertyDesc.initializer : void 0;
    let value = propertyDesc ? propertyDesc.value : void 0;
    let decorator = function(target, key, _desc, _meta, isClassicDecorator2) {
      !isClassicDecorator2 && assert(`You attempted to set a default value for ${key} with the @tracked({ value: 'default' }) syntax. You can only use this syntax with classic classes. For native classes, you can use class initializers: @tracked field = 'default';`, isClassicDecorator2);
      let fieldDesc = {
        initializer: initializer || (() => value)
      };
      return descriptorForField([target, key, fieldDesc]);
    };
    setClassicDecorator(decorator);
    return decorator;
  }
  return descriptorForField(args);
}
if (true) {
  setClassicDecorator(tracked);
}
function descriptorForField([target, key, desc]) {
  !(!desc || !desc.value && !desc.get && !desc.set) && assert(`You attempted to use @tracked on ${key}, but that element is not a class field. @tracked is only usable on class fields. Native getters and setters will autotrack add any tracked fields they encounter, so there is no need mark getters and setters with @tracked.`, !desc || !desc.value && !desc.get && !desc.set);
  let {
    getter,
    setter
  } = trackedData(key, desc ? desc.initializer : void 0);
  function get3() {
    let value = getter(this);
    if (Array.isArray(value) || isEmberArray(value)) {
      consumeTag(tagFor(value, "[]"));
    }
    return value;
  }
  function set2(newValue) {
    setter(this, newValue);
    dirtyTagFor(this, SELF_TAG);
  }
  let newDesc = {
    enumerable: true,
    configurable: true,
    isTracked: true,
    get: get3,
    set: set2
  };
  COMPUTED_SETTERS.add(set2);
  meta(target).writeDescriptors(key, new TrackedDescriptor(get3, set2));
  return newDesc;
}
var TrackedDescriptor = class {
  constructor(_get, _set) {
    this._get = _get;
    this._set = _set;
    CHAIN_PASS_THROUGH.add(this);
  }
  get(obj) {
    return this._get.call(obj);
  }
  set(obj, _key, value) {
    this._set.call(obj, value);
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/property_set-n9lAuzYY.js
function set(obj, keyName, value, tolerant) {
  !(arguments.length === 3 || arguments.length === 4) && assert(`Set must be called with three or four arguments; an object, a property key, a value and tolerant true/false`, arguments.length === 3 || arguments.length === 4);
  !(obj && typeof obj === "object" || typeof obj === "function") && assert(`Cannot call set with '${keyName}' on an undefined object.`, obj && typeof obj === "object" || typeof obj === "function");
  !(typeof keyName === "string" || typeof keyName === "number" && !isNaN(keyName)) && assert(`The key provided to set must be a string or number, you passed ${keyName}`, typeof keyName === "string" || typeof keyName === "number" && !isNaN(keyName));
  !(typeof keyName !== "string" || keyName.lastIndexOf("this.", 0) !== 0) && assert(`'this' in paths is not supported`, typeof keyName !== "string" || keyName.lastIndexOf("this.", 0) !== 0);
  if (obj.isDestroyed) {
    !tolerant && assert(`calling set on destroyed object: ${toString(obj)}.${keyName} = ${toString(value)}`, tolerant);
    return value;
  }
  return isPath(keyName) ? _setPath(obj, keyName, value, tolerant) : _setProp(obj, keyName, value);
}
function _setProp(obj, keyName, value) {
  let descriptor = lookupDescriptor(obj, keyName);
  if (descriptor !== null && COMPUTED_SETTERS.has(descriptor.set)) {
    obj[keyName] = value;
    return value;
  }
  let currentValue;
  if (true) {
    currentValue = getPossibleMandatoryProxyValue(obj, keyName);
  } else {
    currentValue = obj[keyName];
  }
  if (currentValue === void 0 && "object" === typeof obj && !(keyName in obj) && typeof obj.setUnknownProperty === "function") {
    obj.setUnknownProperty(keyName, value);
  } else {
    if (true) {
      setWithMandatorySetter(obj, keyName, value);
    } else {
      obj[keyName] = value;
    }
    if (currentValue !== value) {
      notifyPropertyChange(obj, keyName);
    }
  }
  return value;
}
function _setPath(root, path, value, tolerant) {
  let parts = path.split(".");
  let keyName = parts.pop();
  !(keyName.trim().length > 0) && assert("Property set failed: You passed an empty path", keyName.trim().length > 0);
  let newRoot = _getPath(root, parts, true);
  if (newRoot !== null && newRoot !== void 0) {
    return set(newRoot, keyName, value);
  } else if (!tolerant) {
    throw new Error(`Property set failed: object in path "${parts.join(".")}" could not be found.`);
  }
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/set_properties-D2_u0phU.js
function getProperties(obj, keys) {
  let ret = {};
  let propertyNames;
  let i = 1;
  if (arguments.length === 2 && Array.isArray(keys)) {
    i = 0;
    propertyNames = arguments[1];
  } else {
    propertyNames = Array.from(arguments);
  }
  for (; i < propertyNames.length; i++) {
    let name = propertyNames[i];
    ret[name] = get(obj, name);
  }
  return ret;
}
function setProperties(obj, properties) {
  if (properties === null || typeof properties !== "object") {
    return properties;
  }
  changeProperties(() => {
    let props = Object.keys(properties);
    for (let propertyName of props) {
      set(obj, propertyName, properties[propertyName]);
    }
  });
  return properties;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/name-BVdprEDX.js
var NAMES = /* @__PURE__ */ new WeakMap();
function setName(obj, name) {
  if (isObject(obj)) NAMES.set(obj, name);
}
function getName(obj) {
  return NAMES.get(obj);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/namespace_search-Dh_YNV5f.js
var hasOwnProperty = Object.prototype.hasOwnProperty;
var searchDisabled = false;
var flags = {
  _set: 0,
  _unprocessedNamespaces: false,
  get unprocessedNamespaces() {
    return this._unprocessedNamespaces;
  },
  set unprocessedNamespaces(v) {
    this._set++;
    this._unprocessedNamespaces = v;
  }
};
var unprocessedMixins = false;
var NAMESPACES = [];
var NAMESPACES_BY_ID = /* @__PURE__ */ Object.create(null);
function addNamespace(namespace) {
  flags.unprocessedNamespaces = true;
  NAMESPACES.push(namespace);
}
function removeNamespace(namespace) {
  let name = getName(namespace);
  delete NAMESPACES_BY_ID[name];
  NAMESPACES.splice(NAMESPACES.indexOf(namespace), 1);
  if (name in context.lookup && namespace === context.lookup[name]) {
    context.lookup[name] = void 0;
  }
}
function findNamespaces() {
  if (!flags.unprocessedNamespaces) {
    return;
  }
  let lookup2 = context.lookup;
  let keys = Object.keys(lookup2);
  for (let key of keys) {
    if (!isUppercase(key.charCodeAt(0))) {
      continue;
    }
    let obj = tryIsNamespace(lookup2, key);
    if (obj) {
      setName(obj, key);
    }
  }
}
function findNamespace(name) {
  if (!searchDisabled) {
    processAllNamespaces();
  }
  return NAMESPACES_BY_ID[name];
}
function processNamespace(namespace) {
  _processNamespace([namespace.toString()], namespace, /* @__PURE__ */ new Set());
}
function processAllNamespaces() {
  let unprocessedNamespaces = flags.unprocessedNamespaces;
  if (unprocessedNamespaces) {
    findNamespaces();
    flags.unprocessedNamespaces = false;
  }
  if (unprocessedNamespaces || unprocessedMixins) {
    let namespaces = NAMESPACES;
    for (let namespace of namespaces) {
      processNamespace(namespace);
    }
    unprocessedMixins = false;
  }
}
function setUnprocessedMixins() {
  unprocessedMixins = true;
}
function _processNamespace(paths, root, seen) {
  let idx = paths.length;
  let id = paths.join(".");
  NAMESPACES_BY_ID[id] = root;
  setName(root, id);
  for (let key in root) {
    if (!hasOwnProperty.call(root, key)) {
      continue;
    }
    let obj = root[key];
    paths[idx] = key;
    if (obj && getName(obj) === void 0) {
      setName(obj, paths.join("."));
    } else if (obj && isNamespace(obj)) {
      if (seen.has(obj)) {
        continue;
      }
      seen.add(obj);
      _processNamespace(paths, obj, seen);
    }
  }
  paths.length = idx;
}
function isNamespace(obj) {
  return obj != null && typeof obj === "object" && obj.isNamespace;
}
function isUppercase(code) {
  return code >= 65 && code <= 90;
}
function tryIsNamespace(lookup2, prop) {
  try {
    let obj = lookup2[prop];
    return (obj !== null && typeof obj === "object" || typeof obj === "function") && obj.isNamespace && obj;
  } catch (_e) {
  }
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/mixin.js
var a_concat = Array.prototype.concat;
var {
  isArray: isArray2
} = Array;
function extractAccessors(properties) {
  if (properties !== void 0) {
    for (let key of Object.keys(properties)) {
      let desc = Object.getOwnPropertyDescriptor(properties, key);
      if (desc.get !== void 0 || desc.set !== void 0) {
        Object.defineProperty(properties, key, {
          value: nativeDescDecorator(desc)
        });
      }
    }
  }
  return properties;
}
function concatenatedMixinProperties(concatProp, props, values, base) {
  let concats = values[concatProp] || base[concatProp];
  if (props[concatProp]) {
    concats = concats ? a_concat.call(concats, props[concatProp]) : props[concatProp];
  }
  return concats;
}
function giveDecoratorSuper(key, decorator, property, descs) {
  if (property === true) {
    return decorator;
  }
  let originalGetter = property._getter;
  if (originalGetter === void 0) {
    return decorator;
  }
  let superDesc = descs[key];
  let superProperty = typeof superDesc === "function" ? descriptorForDecorator(superDesc) : superDesc;
  if (superProperty === void 0 || superProperty === true) {
    return decorator;
  }
  let superGetter = superProperty._getter;
  if (superGetter === void 0) {
    return decorator;
  }
  let get3 = wrap(originalGetter, superGetter);
  let set2;
  let originalSetter = property._setter;
  let superSetter = superProperty._setter;
  if (superSetter !== void 0) {
    if (originalSetter !== void 0) {
      set2 = wrap(originalSetter, superSetter);
    } else {
      set2 = superSetter;
    }
  } else {
    set2 = originalSetter;
  }
  if (get3 !== originalGetter || set2 !== originalSetter) {
    let dependentKeys = property._dependentKeys || [];
    let newProperty = new ComputedProperty([...dependentKeys, {
      get: get3,
      set: set2
    }]);
    newProperty._readOnly = property._readOnly;
    newProperty._meta = property._meta;
    newProperty.enumerable = property.enumerable;
    return makeComputedDecorator(newProperty, ComputedProperty);
  }
  return decorator;
}
function giveMethodSuper(key, method, values, descs) {
  if (descs[key] !== void 0) {
    return method;
  }
  let superMethod = values[key];
  if (typeof superMethod === "function") {
    return wrap(method, superMethod);
  }
  return method;
}
function simpleMakeArray(value) {
  if (!value) {
    return [];
  } else if (!Array.isArray(value)) {
    return [value];
  } else {
    return value;
  }
}
function applyConcatenatedProperties(key, value, values) {
  let baseValue = values[key];
  let ret = simpleMakeArray(baseValue).concat(simpleMakeArray(value));
  if (true) {
    if (typeof ret === "object" && ret !== null) {
      Object.freeze(ret);
    }
  }
  return ret;
}
function applyMergedProperties(key, value, values) {
  let baseValue = values[key];
  !!isArray2(value) && assert(`You passed in \`${JSON.stringify(value)}\` as the value for \`${key}\` but \`${key}\` cannot be an Array`, !isArray2(value));
  if (!baseValue) {
    return value;
  }
  let newBase = Object.assign({}, baseValue);
  let hasFunction = false;
  let props = Object.keys(value);
  for (let prop of props) {
    let propValue = value[prop];
    if (typeof propValue === "function") {
      hasFunction = true;
      newBase[prop] = giveMethodSuper(prop, propValue, baseValue, {});
    } else {
      newBase[prop] = propValue;
    }
  }
  if (hasFunction) {
    newBase._super = ROOT;
  }
  return newBase;
}
function mergeMixins(mixins, meta3, descs, values, base, keys, keysWithSuper) {
  let currentMixin;
  for (let i = 0; i < mixins.length; i++) {
    currentMixin = mixins[i];
    !(typeof currentMixin === "object" && currentMixin !== null && Object.prototype.toString.call(currentMixin) !== "[object Array]") && assert(`Expected hash or Mixin instance, got ${Object.prototype.toString.call(currentMixin)}`, typeof currentMixin === "object" && currentMixin !== null && Object.prototype.toString.call(currentMixin) !== "[object Array]");
    if (MIXINS.has(currentMixin)) {
      if (meta3.hasMixin(currentMixin)) {
        continue;
      }
      meta3.addMixin(currentMixin);
      let {
        properties,
        mixins: mixins2
      } = currentMixin;
      if (properties !== void 0) {
        mergeProps(meta3, properties, descs, values, base, keys, keysWithSuper);
      } else if (mixins2 !== void 0) {
        mergeMixins(mixins2, meta3, descs, values, base, keys, keysWithSuper);
        if (currentMixin instanceof Mixin && currentMixin._without !== void 0) {
          currentMixin._without.forEach((keyName) => {
            let index = keys.indexOf(keyName);
            if (index !== -1) {
              keys.splice(index, 1);
            }
          });
        }
      }
    } else {
      mergeProps(meta3, currentMixin, descs, values, base, keys, keysWithSuper);
    }
  }
}
function mergeProps(meta3, props, descs, values, base, keys, keysWithSuper) {
  let concats = concatenatedMixinProperties("concatenatedProperties", props, values, base);
  let mergings = concatenatedMixinProperties("mergedProperties", props, values, base);
  let propKeys = Object.keys(props);
  for (let key of propKeys) {
    let value = props[key];
    if (value === void 0) continue;
    if (keys.indexOf(key) === -1) {
      keys.push(key);
      let desc = meta3.peekDescriptors(key);
      if (desc === void 0) {
        if (!isClassicDecorator(value)) {
          let prev = values[key] = base[key];
          if (typeof prev === "function") {
            updateObserversAndListeners(base, key, prev, false);
          }
        }
      } else {
        descs[key] = desc;
        keysWithSuper.push(key);
        desc.teardown(base, key, meta3);
      }
    }
    let isFunction = typeof value === "function";
    if (isFunction) {
      let desc = descriptorForDecorator(value);
      if (desc !== void 0) {
        descs[key] = giveDecoratorSuper(key, value, desc, descs);
        values[key] = void 0;
        continue;
      }
    }
    if (concats && concats.indexOf(key) >= 0 || key === "concatenatedProperties" || key === "mergedProperties") {
      value = applyConcatenatedProperties(key, value, values);
    } else if (mergings && mergings.indexOf(key) > -1) {
      value = applyMergedProperties(key, value, values);
    } else if (isFunction) {
      value = giveMethodSuper(key, value, values, descs);
    }
    values[key] = value;
    descs[key] = void 0;
  }
}
function updateObserversAndListeners(obj, key, fn, add3) {
  let meta3 = observerListenerMetaFor(fn);
  if (meta3 === void 0) return;
  let {
    observers,
    listeners
  } = meta3;
  if (observers !== void 0) {
    let updateObserver = add3 ? addObserver : removeObserver;
    for (let path of observers.paths) {
      updateObserver(obj, path, null, key, observers.sync);
    }
  }
  if (listeners !== void 0) {
    let updateListener = add3 ? addListener : removeListener;
    for (let listener of listeners) {
      updateListener(obj, listener, null, key);
    }
  }
}
function applyMixin(obj, mixins, _hideKeys = false) {
  let descs = /* @__PURE__ */ Object.create(null);
  let values = /* @__PURE__ */ Object.create(null);
  let meta$1 = meta(obj);
  let keys = [];
  let keysWithSuper = [];
  obj._super = ROOT;
  mergeMixins(mixins, meta$1, descs, values, obj, keys, keysWithSuper);
  for (let key of keys) {
    let value = values[key];
    let desc = descs[key];
    if (value !== void 0) {
      if (typeof value === "function") {
        updateObserversAndListeners(obj, key, value, true);
      }
      defineValue(obj, key, value, keysWithSuper.indexOf(key) !== -1, !_hideKeys);
    } else if (desc !== void 0) {
      defineDecorator(obj, key, desc, meta$1);
    }
  }
  if (!meta$1.isPrototypeMeta(obj)) {
    revalidateObservers(obj);
  }
  return obj;
}
var MIXINS = /* @__PURE__ */ new WeakSet();
var Mixin = class _Mixin {
  /** @internal */
  /** @internal */
  mixins;
  /** @internal */
  properties;
  /** @internal */
  ownerConstructor;
  /** @internal */
  _without;
  /** @internal */
  constructor(mixins, properties) {
    MIXINS.add(this);
    this.properties = extractAccessors(properties);
    this.mixins = buildMixinsArray(mixins);
    this.ownerConstructor = void 0;
    this._without = void 0;
    if (true) {
      this[INIT_FACTORY] = null;
      guidFor(this);
      if (_Mixin._disableDebugSeal !== true) {
        Object.seal(this);
      }
    }
  }
  /**
    @method create
    @for @ember/object/mixin
    @static
    @param arguments*
    @public
  */
  static create(...args) {
    setUnprocessedMixins();
    let M = this;
    return new M(args, void 0);
  }
  // returns the mixins currently applied to the specified object
  // TODO: Make `mixin`
  /** @internal */
  static mixins(obj) {
    let meta3 = peekMeta(obj);
    let ret = [];
    if (meta3 === null) {
      return ret;
    }
    meta3.forEachMixins((currentMixin) => {
      if (!currentMixin.properties) {
        ret.push(currentMixin);
      }
    });
    return ret;
  }
  /**
    @method reopen
    @param arguments*
    @private
    @internal
  */
  reopen(...args) {
    if (args.length === 0) {
      return this;
    }
    if (this.properties) {
      let currentMixin = new _Mixin(void 0, this.properties);
      this.properties = void 0;
      this.mixins = [currentMixin];
    } else if (!this.mixins) {
      this.mixins = [];
    }
    this.mixins = this.mixins.concat(buildMixinsArray(args));
    return this;
  }
  /**
    @method apply
    @param obj
    @return applied object
    @private
    @internal
  */
  apply(obj, _hideKeys = false) {
    return applyMixin(obj, [this], _hideKeys);
  }
  /** @internal */
  applyPartial(obj) {
    return applyMixin(obj, [this]);
  }
  /**
    @method detect
    @param obj
    @return {Boolean}
    @private
    @internal
  */
  detect(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    if (MIXINS.has(obj)) {
      return _detect(obj, this);
    }
    let meta3 = peekMeta(obj);
    if (meta3 === null) {
      return false;
    }
    return meta3.hasMixin(this);
  }
  /** @internal */
  without(...args) {
    let ret = new _Mixin([this]);
    ret._without = args;
    return ret;
  }
  /** @internal */
  keys() {
    let keys = _keys(this);
    !keys && assert("[BUG] Missing keys for mixin!", keys);
    return keys;
  }
  /** @internal */
  toString() {
    return "(unknown mixin)";
  }
};
if (true) {
  Object.defineProperty(Mixin, "_disableDebugSeal", {
    configurable: true,
    enumerable: false,
    writable: true,
    value: false
  });
}
function buildMixinsArray(mixins) {
  let length = mixins && mixins.length || 0;
  let m = void 0;
  if (length > 0) {
    m = new Array(length);
    for (let i = 0; i < length; i++) {
      let x = mixins[i];
      !(typeof x === "object" && x !== null && Object.prototype.toString.call(x) !== "[object Array]") && assert(`Expected hash or Mixin instance, got ${Object.prototype.toString.call(x)}`, typeof x === "object" && x !== null && Object.prototype.toString.call(x) !== "[object Array]");
      if (MIXINS.has(x)) {
        m[i] = x;
      } else {
        m[i] = new Mixin(void 0, x);
      }
    }
  }
  return m;
}
if (true) {
  Object.seal(Mixin.prototype);
}
function _detect(curMixin, targetMixin, seen = /* @__PURE__ */ new Set()) {
  if (seen.has(curMixin)) {
    return false;
  }
  seen.add(curMixin);
  if (curMixin === targetMixin) {
    return true;
  }
  let mixins = curMixin.mixins;
  if (mixins) {
    return mixins.some((mixin) => _detect(mixin, targetMixin, seen));
  }
  return false;
}
function _keys(mixin, ret = /* @__PURE__ */ new Set(), seen = /* @__PURE__ */ new Set()) {
  if (seen.has(mixin)) {
    return;
  }
  seen.add(mixin);
  if (mixin.properties) {
    let props = Object.keys(mixin.properties);
    for (let prop of props) {
      ret.add(prop);
    }
  } else if (mixin.mixins) {
    mixin.mixins.forEach((x) => _keys(x, ret, seen));
  }
  return ret;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/registry_proxy.js
var RegistryProxyMixin = Mixin.create({
  __registry__: null,
  resolveRegistration(fullName) {
    !this.__registry__.isValidFullName(fullName) && assert("fullName must be a proper full name", this.__registry__.isValidFullName(fullName));
    return this.__registry__.resolve(fullName);
  },
  register: registryAlias("register"),
  unregister: registryAlias("unregister"),
  hasRegistration: registryAlias("has"),
  registeredOption: registryAlias("getOption"),
  registerOptions: registryAlias("options"),
  registeredOptions: registryAlias("getOptions"),
  registerOptionsForType: registryAlias("optionsForType"),
  registeredOptionsForType: registryAlias("getOptionsForType")
});
function registryAlias(name) {
  return function(...args) {
    return this.__registry__[name](...args);
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/error-handling/index.js
var onerror;
var onErrorTarget = {
  get onerror() {
    return onerror;
  }
};
var dispatchOverride = null;
function getDispatchOverride() {
  return dispatchOverride;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/backburner.js/index.js
var SET_TIMEOUT = setTimeout;
var NOOP = () => {
};
function buildNext(flush3) {
  if (typeof Promise === "function") {
    const autorunPromise = Promise.resolve();
    return () => autorunPromise.then(flush3);
  } else if (typeof MutationObserver === "function") {
    let iterations = 0;
    let observer = new MutationObserver(flush3);
    let node = document.createTextNode("");
    observer.observe(node, {
      characterData: true
    });
    return () => {
      iterations = ++iterations % 2;
      node.data = "" + iterations;
      return iterations;
    };
  } else {
    return () => SET_TIMEOUT(flush3, 0);
  }
}
function buildPlatform(flush3) {
  let clearNext = NOOP;
  return {
    setTimeout(fn, ms) {
      return setTimeout(fn, ms);
    },
    clearTimeout(timerId) {
      return clearTimeout(timerId);
    },
    now() {
      return Date.now();
    },
    next: buildNext(flush3),
    clearNext
  };
}
var NUMBER = /\d+/;
var TIMERS_OFFSET = 6;
function isCoercableNumber(suspect) {
  let type = typeof suspect;
  return type === "number" && suspect === suspect || type === "string" && NUMBER.test(suspect);
}
function getOnError(options) {
  return options.onError || options.onErrorTarget && options.onErrorTarget[options.onErrorMethod];
}
function findItem(target, method, collection) {
  let index = -1;
  for (let i = 0, l = collection.length; i < l; i += 4) {
    if (collection[i] === target && collection[i + 1] === method) {
      index = i;
      break;
    }
  }
  return index;
}
function findTimerItem(target, method, collection) {
  let index = -1;
  for (let i = 2, l = collection.length; i < l; i += 6) {
    if (collection[i] === target && collection[i + 1] === method) {
      index = i - 2;
      break;
    }
  }
  return index;
}
function getQueueItems(items, queueItemLength, queueItemPositionOffset = 0) {
  let queueItems = [];
  for (let i = 0; i < items.length; i += queueItemLength) {
    let maybeError = items[i + 3 + queueItemPositionOffset];
    let queueItem = {
      target: items[i + 0 + queueItemPositionOffset],
      method: items[i + 1 + queueItemPositionOffset],
      args: items[i + 2 + queueItemPositionOffset],
      stack: maybeError !== void 0 && "stack" in maybeError ? maybeError.stack : ""
    };
    queueItems.push(queueItem);
  }
  return queueItems;
}
function binarySearch(time, timers) {
  let start = 0;
  let end = timers.length - TIMERS_OFFSET;
  let middle;
  let l;
  while (start < end) {
    l = (end - start) / TIMERS_OFFSET;
    middle = start + l - l % TIMERS_OFFSET;
    if (time >= timers[middle]) {
      start = middle + TIMERS_OFFSET;
    } else {
      end = middle;
    }
  }
  return time >= timers[start] ? start + TIMERS_OFFSET : start;
}
var QUEUE_ITEM_LENGTH = 4;
var Queue = class {
  constructor(name, options = {}, globalOptions = {}) {
    this._queueBeingFlushed = [];
    this.targetQueues = /* @__PURE__ */ new Map();
    this.index = 0;
    this._queue = [];
    this.name = name;
    this.options = options;
    this.globalOptions = globalOptions;
  }
  stackFor(index) {
    if (index < this._queue.length) {
      let entry = this._queue[index * 3 + QUEUE_ITEM_LENGTH];
      if (entry) {
        return entry.stack;
      } else {
        return null;
      }
    }
  }
  flush(sync) {
    let {
      before,
      after
    } = this.options;
    let target;
    let method;
    let args;
    let errorRecordedForStack;
    this.targetQueues.clear();
    if (this._queueBeingFlushed.length === 0) {
      this._queueBeingFlushed = this._queue;
      this._queue = [];
    }
    if (before !== void 0) {
      before();
    }
    let invoke2;
    let queueItems = this._queueBeingFlushed;
    if (queueItems.length > 0) {
      let onError = getOnError(this.globalOptions);
      invoke2 = onError ? this.invokeWithOnError : this.invoke;
      for (let i = this.index; i < queueItems.length; i += QUEUE_ITEM_LENGTH) {
        this.index += QUEUE_ITEM_LENGTH;
        method = queueItems[i + 1];
        if (method !== null) {
          target = queueItems[i];
          args = queueItems[i + 2];
          errorRecordedForStack = queueItems[i + 3];
          invoke2(target, method, args, onError, errorRecordedForStack);
        }
        if (this.index !== this._queueBeingFlushed.length && this.globalOptions.mustYield && this.globalOptions.mustYield()) {
          return 1;
        }
      }
    }
    if (after !== void 0) {
      after();
    }
    this._queueBeingFlushed.length = 0;
    this.index = 0;
    if (sync !== false && this._queue.length > 0) {
      this.flush(true);
    }
  }
  hasWork() {
    return this._queueBeingFlushed.length > 0 || this._queue.length > 0;
  }
  cancel({
    target,
    method
  }) {
    let queue2 = this._queue;
    let targetQueueMap = this.targetQueues.get(target);
    if (targetQueueMap !== void 0) {
      targetQueueMap.delete(method);
    }
    let index = findItem(target, method, queue2);
    if (index > -1) {
      queue2[index + 1] = null;
      return true;
    }
    queue2 = this._queueBeingFlushed;
    index = findItem(target, method, queue2);
    if (index > -1) {
      queue2[index + 1] = null;
      return true;
    }
    return false;
  }
  push(target, method, args, stack) {
    this._queue.push(target, method, args, stack);
    return {
      queue: this,
      target,
      method
    };
  }
  pushUnique(target, method, args, stack) {
    let localQueueMap = this.targetQueues.get(target);
    if (localQueueMap === void 0) {
      localQueueMap = /* @__PURE__ */ new Map();
      this.targetQueues.set(target, localQueueMap);
    }
    let index = localQueueMap.get(method);
    if (index === void 0) {
      let queueIndex = this._queue.push(target, method, args, stack) - QUEUE_ITEM_LENGTH;
      localQueueMap.set(method, queueIndex);
    } else {
      let queue2 = this._queue;
      queue2[index + 2] = args;
      queue2[index + 3] = stack;
    }
    return {
      queue: this,
      target,
      method
    };
  }
  _getDebugInfo(debugEnabled) {
    if (debugEnabled) {
      let debugInfo = getQueueItems(this._queue, QUEUE_ITEM_LENGTH);
      return debugInfo;
    }
    return void 0;
  }
  invoke(target, method, args) {
    if (args === void 0) {
      method.call(target);
    } else {
      method.apply(target, args);
    }
  }
  invokeWithOnError(target, method, args, onError, errorRecordedForStack) {
    try {
      if (args === void 0) {
        method.call(target);
      } else {
        method.apply(target, args);
      }
    } catch (error) {
      onError(error, errorRecordedForStack);
    }
  }
};
var DeferredActionQueues = class {
  constructor(queueNames = [], options) {
    this.queues = {};
    this.queueNameIndex = 0;
    this.queueNames = queueNames;
    queueNames.reduce(function(queues, queueName) {
      queues[queueName] = new Queue(queueName, options[queueName], options);
      return queues;
    }, this.queues);
  }
  /**
   * @method schedule
   * @param {String} queueName
   * @param {Any} target
   * @param {Any} method
   * @param {Any} args
   * @param {Boolean} onceFlag
   * @param {Any} stack
   * @return queue
   */
  schedule(queueName, target, method, args, onceFlag, stack) {
    let queues = this.queues;
    let queue2 = queues[queueName];
    if (queue2 === void 0) {
      throw new Error(`You attempted to schedule an action in a queue (${queueName}) that doesn't exist`);
    }
    if (method === void 0 || method === null) {
      throw new Error(`You attempted to schedule an action in a queue (${queueName}) for a method that doesn't exist`);
    }
    this.queueNameIndex = 0;
    if (onceFlag) {
      return queue2.pushUnique(target, method, args, stack);
    } else {
      return queue2.push(target, method, args, stack);
    }
  }
  /**
   * DeferredActionQueues.flush() calls Queue.flush()
   *
   * @method flush
   * @param {Boolean} fromAutorun
   */
  flush(fromAutorun = false) {
    let queue2;
    let queueName;
    let numberOfQueues = this.queueNames.length;
    while (this.queueNameIndex < numberOfQueues) {
      queueName = this.queueNames[this.queueNameIndex];
      queue2 = this.queues[queueName];
      if (queue2.hasWork() === false) {
        this.queueNameIndex++;
        if (fromAutorun && this.queueNameIndex < numberOfQueues) {
          return 1;
        }
      } else {
        if (queue2.flush(
          false
          /* async */
        ) === 1) {
          return 1;
        }
      }
    }
  }
  /**
   * Returns debug information for the current queues.
   *
   * @method _getDebugInfo
   * @param {Boolean} debugEnabled
   * @returns {IDebugInfo | undefined}
   */
  _getDebugInfo(debugEnabled) {
    if (debugEnabled) {
      let debugInfo = {};
      let queue2;
      let queueName;
      let numberOfQueues = this.queueNames.length;
      let i = 0;
      while (i < numberOfQueues) {
        queueName = this.queueNames[i];
        queue2 = this.queues[queueName];
        debugInfo[queueName] = queue2._getDebugInfo(debugEnabled);
        i++;
      }
      return debugInfo;
    }
    return;
  }
};
function iteratorDrain(fn) {
  let iterator = fn();
  let result = iterator.next();
  while (result.done === false) {
    result.value();
    result = iterator.next();
  }
}
var noop3 = function() {
};
var DISABLE_SCHEDULE = Object.freeze([]);
function parseArgs() {
  let length = arguments.length;
  let args;
  let method;
  let target;
  if (length === 0) ;
  else if (length === 1) {
    target = null;
    method = arguments[0];
  } else {
    let argsIndex = 2;
    let methodOrTarget = arguments[0];
    let methodOrArgs = arguments[1];
    let type = typeof methodOrArgs;
    if (type === "function") {
      target = methodOrTarget;
      method = methodOrArgs;
    } else if (methodOrTarget !== null && type === "string" && methodOrArgs in methodOrTarget) {
      target = methodOrTarget;
      method = target[methodOrArgs];
    } else if (typeof methodOrTarget === "function") {
      argsIndex = 1;
      target = null;
      method = methodOrTarget;
    }
    if (length > argsIndex) {
      let len2 = length - argsIndex;
      args = new Array(len2);
      for (let i = 0; i < len2; i++) {
        args[i] = arguments[i + argsIndex];
      }
    }
  }
  return [target, method, args];
}
function parseTimerArgs() {
  let [target, method, args] = parseArgs(...arguments);
  let wait = 0;
  let length = args !== void 0 ? args.length : 0;
  if (length > 0) {
    let last = args[length - 1];
    if (isCoercableNumber(last)) {
      wait = parseInt(args.pop(), 10);
    }
  }
  return [target, method, args, wait];
}
function parseDebounceArgs() {
  let target;
  let method;
  let isImmediate;
  let args;
  let wait;
  if (arguments.length === 2) {
    method = arguments[0];
    wait = arguments[1];
    target = null;
  } else {
    [target, method, args] = parseArgs(...arguments);
    if (args === void 0) {
      wait = 0;
    } else {
      wait = args.pop();
      if (!isCoercableNumber(wait)) {
        isImmediate = wait === true;
        wait = args.pop();
      }
    }
  }
  wait = parseInt(wait, 10);
  return [target, method, args, wait, isImmediate];
}
var UUID = 0;
var beginCount = 0;
var endCount = 0;
var beginEventCount = 0;
var endEventCount = 0;
var runCount = 0;
var joinCount = 0;
var deferCount = 0;
var scheduleCount = 0;
var scheduleIterableCount = 0;
var deferOnceCount = 0;
var scheduleOnceCount = 0;
var setTimeoutCount = 0;
var laterCount = 0;
var throttleCount = 0;
var debounceCount = 0;
var cancelTimersCount = 0;
var cancelCount = 0;
var autorunsCreatedCount = 0;
var autorunsCompletedCount = 0;
var deferredActionQueuesCreatedCount = 0;
var nestedDeferredActionQueuesCreated = 0;
var Backburner = class {
  constructor(queueNames, options) {
    this.DEBUG = false;
    this.currentInstance = null;
    this.instanceStack = [];
    this._eventCallbacks = {
      end: [],
      begin: []
    };
    this._timerTimeoutId = null;
    this._timers = [];
    this._autorun = false;
    this._autorunStack = null;
    this.queueNames = queueNames;
    this.options = options || {};
    if (typeof this.options.defaultQueue === "string") {
      this._defaultQueue = this.options.defaultQueue;
    } else {
      this._defaultQueue = this.queueNames[0];
    }
    this._onBegin = this.options.onBegin || noop3;
    this._onEnd = this.options.onEnd || noop3;
    this._boundRunExpiredTimers = this._runExpiredTimers.bind(this);
    this._boundAutorunEnd = () => {
      autorunsCompletedCount++;
      if (this._autorun === false) {
        return;
      }
      this._autorun = false;
      this._autorunStack = null;
      this._end(
        true
        /* fromAutorun */
      );
    };
    let builder = this.options._buildPlatform || buildPlatform;
    this._platform = builder(this._boundAutorunEnd);
  }
  get counters() {
    return {
      begin: beginCount,
      end: endCount,
      events: {
        begin: beginEventCount,
        end: endEventCount
      },
      autoruns: {
        created: autorunsCreatedCount,
        completed: autorunsCompletedCount
      },
      run: runCount,
      join: joinCount,
      defer: deferCount,
      schedule: scheduleCount,
      scheduleIterable: scheduleIterableCount,
      deferOnce: deferOnceCount,
      scheduleOnce: scheduleOnceCount,
      setTimeout: setTimeoutCount,
      later: laterCount,
      throttle: throttleCount,
      debounce: debounceCount,
      cancelTimers: cancelTimersCount,
      cancel: cancelCount,
      loops: {
        total: deferredActionQueuesCreatedCount,
        nested: nestedDeferredActionQueuesCreated
      }
    };
  }
  get defaultQueue() {
    return this._defaultQueue;
  }
  /*
    @method begin
    @return instantiated class DeferredActionQueues
  */
  begin() {
    beginCount++;
    let options = this.options;
    let previousInstance = this.currentInstance;
    let current;
    if (this._autorun !== false) {
      current = previousInstance;
      this._cancelAutorun();
    } else {
      if (previousInstance !== null) {
        nestedDeferredActionQueuesCreated++;
        this.instanceStack.push(previousInstance);
      }
      deferredActionQueuesCreatedCount++;
      current = this.currentInstance = new DeferredActionQueues(this.queueNames, options);
      beginEventCount++;
      this._trigger("begin", current, previousInstance);
    }
    this._onBegin(current, previousInstance);
    return current;
  }
  end() {
    endCount++;
    this._end(false);
  }
  on(eventName, callback) {
    if (typeof callback !== "function") {
      throw new TypeError(`Callback must be a function`);
    }
    let callbacks = this._eventCallbacks[eventName];
    if (callbacks !== void 0) {
      callbacks.push(callback);
    } else {
      throw new TypeError(`Cannot on() event ${eventName} because it does not exist`);
    }
  }
  off(eventName, callback) {
    let callbacks = this._eventCallbacks[eventName];
    if (!eventName || callbacks === void 0) {
      throw new TypeError(`Cannot off() event ${eventName} because it does not exist`);
    }
    let callbackFound = false;
    if (callback) {
      for (let i = 0; i < callbacks.length; i++) {
        if (callbacks[i] === callback) {
          callbackFound = true;
          callbacks.splice(i, 1);
          i--;
        }
      }
    }
    if (!callbackFound) {
      throw new TypeError(`Cannot off() callback that does not exist`);
    }
  }
  run() {
    runCount++;
    let [target, method, args] = parseArgs(...arguments);
    return this._run(target, method, args);
  }
  join() {
    joinCount++;
    let [target, method, args] = parseArgs(...arguments);
    return this._join(target, method, args);
  }
  /**
   * @deprecated please use schedule instead.
   */
  defer(queueName, target, method, ...args) {
    deferCount++;
    return this.schedule(queueName, target, method, ...args);
  }
  schedule(queueName, ..._args) {
    scheduleCount++;
    let [target, method, args] = parseArgs(..._args);
    let stack = this.DEBUG ? new Error() : void 0;
    return this._ensureInstance().schedule(queueName, target, method, args, false, stack);
  }
  /*
    Defer the passed iterable of functions to run inside the specified queue.
       @method scheduleIterable
    @param {String} queueName
    @param {Iterable} an iterable of functions to execute
    @return method result
  */
  scheduleIterable(queueName, iterable) {
    scheduleIterableCount++;
    let stack = this.DEBUG ? new Error() : void 0;
    return this._ensureInstance().schedule(queueName, null, iteratorDrain, [iterable], false, stack);
  }
  /**
   * @deprecated please use scheduleOnce instead.
   */
  deferOnce(queueName, target, method, ...args) {
    deferOnceCount++;
    return this.scheduleOnce(queueName, target, method, ...args);
  }
  scheduleOnce(queueName, ..._args) {
    scheduleOnceCount++;
    let [target, method, args] = parseArgs(..._args);
    let stack = this.DEBUG ? new Error() : void 0;
    return this._ensureInstance().schedule(queueName, target, method, args, true, stack);
  }
  setTimeout() {
    setTimeoutCount++;
    return this.later(...arguments);
  }
  later() {
    laterCount++;
    let [target, method, args, wait] = parseTimerArgs(...arguments);
    return this._later(target, method, args, wait);
  }
  throttle() {
    throttleCount++;
    let [target, method, args, wait, isImmediate = true] = parseDebounceArgs(...arguments);
    let index = findTimerItem(target, method, this._timers);
    let timerId;
    if (index === -1) {
      timerId = this._later(target, method, isImmediate ? DISABLE_SCHEDULE : args, wait);
      if (isImmediate) {
        this._join(target, method, args);
      }
    } else {
      timerId = this._timers[index + 1];
      let argIndex = index + 4;
      if (this._timers[argIndex] !== DISABLE_SCHEDULE) {
        this._timers[argIndex] = args;
      }
    }
    return timerId;
  }
  debounce() {
    debounceCount++;
    let [target, method, args, wait, isImmediate = false] = parseDebounceArgs(...arguments);
    let _timers = this._timers;
    let index = findTimerItem(target, method, _timers);
    let timerId;
    if (index === -1) {
      timerId = this._later(target, method, isImmediate ? DISABLE_SCHEDULE : args, wait);
      if (isImmediate) {
        this._join(target, method, args);
      }
    } else {
      let executeAt = this._platform.now() + wait;
      let argIndex = index + 4;
      if (_timers[argIndex] === DISABLE_SCHEDULE) {
        args = DISABLE_SCHEDULE;
      }
      timerId = _timers[index + 1];
      let i = binarySearch(executeAt, _timers);
      if (index + TIMERS_OFFSET === i) {
        _timers[index] = executeAt;
        _timers[argIndex] = args;
      } else {
        let stack = this._timers[index + 5];
        this._timers.splice(i, 0, executeAt, timerId, target, method, args, stack);
        this._timers.splice(index, TIMERS_OFFSET);
      }
      if (index === 0) {
        this._reinstallTimerTimeout();
      }
    }
    return timerId;
  }
  cancelTimers() {
    cancelTimersCount++;
    this._clearTimerTimeout();
    this._timers = [];
    this._cancelAutorun();
  }
  hasTimers() {
    return this._timers.length > 0 || this._autorun;
  }
  cancel(timer) {
    cancelCount++;
    if (timer === null || timer === void 0) {
      return false;
    }
    let timerType = typeof timer;
    if (timerType === "number") {
      return this._cancelLaterTimer(timer);
    } else if (timerType === "object" && timer.queue && timer.method) {
      return timer.queue.cancel(timer);
    }
    return false;
  }
  ensureInstance() {
    this._ensureInstance();
  }
  /**
   * Returns debug information related to the current instance of Backburner
   *
   * @method getDebugInfo
   * @returns {Object | undefined} Will return and Object containing debug information if
   * the DEBUG flag is set to true on the current instance of Backburner, else undefined.
   */
  getDebugInfo() {
    if (this.DEBUG) {
      return {
        autorun: this._autorunStack,
        counters: this.counters,
        timers: getQueueItems(this._timers, TIMERS_OFFSET, 2),
        instanceStack: [this.currentInstance, ...this.instanceStack].map((deferredActionQueue) => deferredActionQueue && deferredActionQueue._getDebugInfo(this.DEBUG))
      };
    }
    return void 0;
  }
  _end(fromAutorun) {
    let currentInstance = this.currentInstance;
    let nextInstance = null;
    if (currentInstance === null) {
      throw new Error(`end called without begin`);
    }
    let finallyAlreadyCalled = false;
    let result;
    try {
      result = currentInstance.flush(fromAutorun);
    } finally {
      if (!finallyAlreadyCalled) {
        finallyAlreadyCalled = true;
        if (result === 1) {
          const plannedNextQueue = this.queueNames[currentInstance.queueNameIndex];
          this._scheduleAutorun(plannedNextQueue);
        } else {
          this.currentInstance = null;
          if (this.instanceStack.length > 0) {
            nextInstance = this.instanceStack.pop();
            this.currentInstance = nextInstance;
          }
          this._trigger("end", currentInstance, nextInstance);
          this._onEnd(currentInstance, nextInstance);
        }
      }
    }
  }
  _join(target, method, args) {
    if (this.currentInstance === null) {
      return this._run(target, method, args);
    }
    if (target === void 0 && args === void 0) {
      return method();
    } else {
      return method.apply(target, args);
    }
  }
  _run(target, method, args) {
    let onError = getOnError(this.options);
    this.begin();
    if (onError) {
      try {
        return method.apply(target, args);
      } catch (error) {
        onError(error);
      } finally {
        this.end();
      }
    } else {
      try {
        return method.apply(target, args);
      } finally {
        this.end();
      }
    }
  }
  _cancelAutorun() {
    if (this._autorun) {
      this._platform.clearNext();
      this._autorun = false;
      this._autorunStack = null;
    }
  }
  _later(target, method, args, wait) {
    let stack = this.DEBUG ? new Error() : void 0;
    let executeAt = this._platform.now() + wait;
    let id = UUID++;
    if (this._timers.length === 0) {
      this._timers.push(executeAt, id, target, method, args, stack);
      this._installTimerTimeout();
    } else {
      let i = binarySearch(executeAt, this._timers);
      this._timers.splice(i, 0, executeAt, id, target, method, args, stack);
      this._reinstallTimerTimeout();
    }
    return id;
  }
  _cancelLaterTimer(timer) {
    for (let i = 1; i < this._timers.length; i += TIMERS_OFFSET) {
      if (this._timers[i] === timer) {
        this._timers.splice(i - 1, TIMERS_OFFSET);
        if (i === 1) {
          this._reinstallTimerTimeout();
        }
        return true;
      }
    }
    return false;
  }
  /**
   Trigger an event. Supports up to two arguments. Designed around
   triggering transition events from one run loop instance to the
   next, which requires an argument for the  instance and then
   an argument for the next instance.
      @private
   @method _trigger
   @param {String} eventName
   @param {any} arg1
   @param {any} arg2
   */
  _trigger(eventName, arg1, arg2) {
    let callbacks = this._eventCallbacks[eventName];
    if (callbacks !== void 0) {
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](arg1, arg2);
      }
    }
  }
  _runExpiredTimers() {
    this._timerTimeoutId = null;
    if (this._timers.length > 0) {
      this.begin();
      this._scheduleExpiredTimers();
      this.end();
    }
  }
  _scheduleExpiredTimers() {
    let timers = this._timers;
    let i = 0;
    let l = timers.length;
    let defaultQueue = this._defaultQueue;
    let n = this._platform.now();
    for (; i < l; i += TIMERS_OFFSET) {
      let executeAt = timers[i];
      if (executeAt > n) {
        break;
      }
      let args = timers[i + 4];
      if (args !== DISABLE_SCHEDULE) {
        let target = timers[i + 2];
        let method = timers[i + 3];
        let stack = timers[i + 5];
        this.currentInstance.schedule(defaultQueue, target, method, args, false, stack);
      }
    }
    timers.splice(0, i);
    this._installTimerTimeout();
  }
  _reinstallTimerTimeout() {
    this._clearTimerTimeout();
    this._installTimerTimeout();
  }
  _clearTimerTimeout() {
    if (this._timerTimeoutId === null) {
      return;
    }
    this._platform.clearTimeout(this._timerTimeoutId);
    this._timerTimeoutId = null;
  }
  _installTimerTimeout() {
    if (this._timers.length === 0) {
      return;
    }
    let minExpiresAt = this._timers[0];
    let n = this._platform.now();
    let wait = Math.max(0, minExpiresAt - n);
    this._timerTimeoutId = this._platform.setTimeout(this._boundRunExpiredTimers, wait);
  }
  _ensureInstance() {
    let currentInstance = this.currentInstance;
    if (currentInstance === null) {
      this._autorunStack = this.DEBUG ? new Error() : void 0;
      currentInstance = this.begin();
      this._scheduleAutorun(this.queueNames[0]);
    }
    return currentInstance;
  }
  _scheduleAutorun(plannedNextQueue) {
    autorunsCreatedCount++;
    const next = this._platform.next;
    const flush3 = this.options.flush;
    if (flush3) {
      flush3(plannedNextQueue, next);
    } else {
      next();
    }
    this._autorun = true;
  }
};
Backburner.Queue = Queue;
Backburner.buildPlatform = buildPlatform;
Backburner.buildNext = buildNext;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/runloop/index.js
var currentRunLoop = null;
function _getCurrentRunLoop() {
  return currentRunLoop;
}
function onBegin(current) {
  currentRunLoop = current;
}
function onEnd(_current, next) {
  currentRunLoop = next;
  flushAsyncObservers(schedule);
}
function flush(queueName, next) {
  if (queueName === "render" || queueName === _rsvpErrorQueue) {
    flushAsyncObservers(schedule);
  }
  next();
}
var _rsvpErrorQueue = `${Math.random()}${Date.now()}`.replace(".", "");
var _queues = [
  "actions",
  // used in router transitions to prevent unnecessary loading state entry
  // if all context promises resolve on the 'actions' queue first
  "routerTransitions",
  "render",
  "afterRender",
  "destroy",
  // used to re-throw unhandled RSVP rejection errors specifically in this
  // position to avoid breaking anything rendered in the other sections
  _rsvpErrorQueue
];
var _backburner = new Backburner(_queues, {
  defaultQueue: "actions",
  onBegin,
  onEnd,
  onErrorTarget,
  onErrorMethod: "onerror",
  flush
});
function run(...args) {
  return _backburner.run(...args);
}
function join(methodOrTarget, methodOrArg, ...additionalArgs) {
  return _backburner.join(methodOrTarget, methodOrArg, ...additionalArgs);
}
function bind(...curried) {
  !(function(methodOrTarget, methodOrArg) {
    let length = arguments.length;
    if (length === 0) {
      return false;
    } else if (length === 1) {
      return typeof methodOrTarget === "function";
    } else {
      return typeof methodOrArg === "function" || // second argument is a function
      methodOrTarget !== null && typeof methodOrArg === "string" && methodOrArg in methodOrTarget || // second argument is the name of a method in first argument
      typeof methodOrTarget === "function";
    }
  })(...curried) && assert("could not find a suitable method to bind", (function(methodOrTarget, methodOrArg) {
    let length = arguments.length;
    if (length === 0) {
      return false;
    } else if (length === 1) {
      return typeof methodOrTarget === "function";
    } else {
      return typeof methodOrArg === "function" || methodOrTarget !== null && typeof methodOrArg === "string" && methodOrArg in methodOrTarget || typeof methodOrTarget === "function";
    }
  })(...curried));
  return (...args) => join(...curried.concat(args));
}
function schedule(...args) {
  return _backburner.schedule(...args);
}
function once(...args) {
  return _backburner.scheduleOnce("actions", ...args);
}
function scheduleOnce(...args) {
  return _backburner.scheduleOnce(...args);
}
function cancel(timer) {
  return _backburner.cancel(timer);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/container_proxy.js
var ContainerProxyMixin = Mixin.create({
  /**
   The container stores state.
    @private
   @property {Ember.Container} __container__
   */
  __container__: null,
  ownerInjection() {
    return this.__container__.ownerInjection();
  },
  lookup(fullName, options) {
    return this.__container__.lookup(fullName, options);
  },
  destroy() {
    let container = this.__container__;
    if (container) {
      join(() => {
        container.destroy();
        schedule("destroy", container, "finalizeDestroy");
      });
    }
    this._super();
  },
  factoryFor(fullName) {
    return this.__container__.factoryFor(fullName);
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/comparable.js
var Comparable = Mixin.create({
  /**
    __Required.__ You must implement this method to apply this mixin.
     Override to return the result of the comparison of the two parameters. The
    compare method should return:
     - `-1` if `a < b`
    - `0` if `a == b`
    - `1` if `a > b`
     Default implementation raises an exception.
     @method compare
    @param a {Object} the first object to compare
    @param b {Object} the second object to compare
    @return {Number} the result of the comparison
    @private
  */
  compare: null
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/action_handler.js
var ActionHandler = Mixin.create({
  mergedProperties: ["actions"],
  /**
    The collection of functions, keyed by name, available on this
    `ActionHandler` as action targets.
     These functions will be invoked when a matching `{{action}}` is triggered
    from within a template and the application's current route is this route.
     Actions can also be invoked from other parts of your application
    via `ActionHandler#send`.
     The `actions` hash will inherit action handlers from
    the `actions` hash defined on extended parent classes
    or mixins rather than just replace the entire hash, e.g.:
     ```app/mixins/can-display-banner.js
    import Mixin from '@ember/object/mixin';
     export default Mixin.create({
      actions: {
        displayBanner(msg) {
          // ...
        }
      }
    });
    ```
     ```app/routes/welcome.js
    import Route from '@ember/routing/route';
    import CanDisplayBanner from '../mixins/can-display-banner';
     export default Route.extend(CanDisplayBanner, {
      actions: {
        playMusic() {
          // ...
        }
      }
    });
     // `WelcomeRoute`, when active, will be able to respond
    // to both actions, since the actions hash is merged rather
    // then replaced when extending mixins / parent classes.
    this.send('displayBanner');
    this.send('playMusic');
    ```
     Within a Controller, Route or Component's action handler,
    the value of the `this` context is the Controller, Route or
    Component object:
     ```app/routes/song.js
    import Route from '@ember/routing/route';
     export default Route.extend({
      actions: {
        myAction() {
          this.controllerFor("song");
          this.transitionTo("other.route");
          ...
        }
      }
    });
    ```
     It is also possible to call `this._super(...arguments)` from within an
    action handler if it overrides a handler defined on a parent
    class or mixin:
     Take for example the following routes:
     ```app/mixins/debug-route.js
    import Mixin from '@ember/object/mixin';
     export default Mixin.create({
      actions: {
        debugRouteInformation() {
          console.debug("It's a-me, console.debug!");
        }
      }
    });
    ```
     ```app/routes/annoying-debug.js
    import Route from '@ember/routing/route';
    import DebugRoute from '../mixins/debug-route';
     export default Route.extend(DebugRoute, {
      actions: {
        debugRouteInformation() {
          // also call the debugRouteInformation of mixed in DebugRoute
          this._super(...arguments);
           // show additional annoyance
          window.alert(...);
        }
      }
    });
    ```
     ## Bubbling
     By default, an action will stop bubbling once a handler defined
    on the `actions` hash handles it. To continue bubbling the action,
    you must return `true` from the handler:
     ```app/router.js
    Router.map(function() {
      this.route("album", function() {
        this.route("song");
      });
    });
    ```
     ```app/routes/album.js
    import Route from '@ember/routing/route';
     export default Route.extend({
      actions: {
        startPlaying: function() {
        }
      }
    });
    ```
     ```app/routes/album-song.js
    import Route from '@ember/routing/route';
     export default Route.extend({
      actions: {
        startPlaying() {
          // ...
           if (actionShouldAlsoBeTriggeredOnParentRoute) {
            return true;
          }
        }
      }
    });
    ```
     @property actions
    @type Object
    @default null
    @public
  */
  /**
    Triggers a named action on the `ActionHandler`. Any parameters
    supplied after the `actionName` string will be passed as arguments
    to the action target function.
     If the `ActionHandler` has its `target` property set, actions may
    bubble to the `target`. Bubbling happens when an `actionName` can
    not be found in the `ActionHandler`'s `actions` hash or if the
    action target function returns `true`.
     Example
     ```app/routes/welcome.js
    import Route from '@ember/routing/route';
     export default Route.extend({
      actions: {
        playTheme() {
          this.send('playMusic', 'theme.mp3');
        },
        playMusic(track) {
          // ...
        }
      }
    });
    ```
     @method send
    @param {String} actionName The action to trigger
    @param {*} context a context to send with the action
    @public
  */
  send(actionName, ...args) {
    !(!this.isDestroying && !this.isDestroyed) && assert(`Attempted to call .send() with the action '${actionName}' on the destroyed object '${this}'.`, !this.isDestroying && !this.isDestroyed);
    if (this.actions && this.actions[actionName]) {
      let shouldBubble = this.actions[actionName].apply(this, args) === true;
      if (!shouldBubble) {
        return;
      }
    }
    let target = get(this, "target");
    if (target) {
      !(typeof target.send === "function") && assert(`The \`target\` for ${this} (${target}) does not have a \`send\` method`, typeof target.send === "function");
      target.send(...arguments);
    }
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/-proxy.js
function contentFor(proxy) {
  let content = get(proxy, "content");
  UPDATE_TAG(tagForObject(proxy), tagForObject(content));
  return content;
}
function customTagForProxy(proxy, key, addMandatorySetter) {
  !isProxy(proxy) && assert("Expected a proxy", isProxy(proxy));
  let meta3 = tagMetaFor(proxy);
  let tag = tagFor(proxy, key, meta3);
  if (true) {
    tag._propertyKey = key;
  }
  if (key in proxy) {
    if (addMandatorySetter) {
      !setupMandatorySetter && assert("[BUG] setupMandatorySetter should be set when debugging", setupMandatorySetter);
      setupMandatorySetter(tag, proxy, key);
    }
    return tag;
  } else {
    let tags = [tag, tagFor(proxy, "content", meta3)];
    let content = contentFor(proxy);
    if (isObject(content)) {
      tags.push(tagForProperty(content, key, addMandatorySetter));
    }
    return combine(tags);
  }
}
var ProxyMixin = Mixin.create({
  /**
    The object whose properties will be forwarded.
     @property content
    @type {unknown}
    @default null
    @public
  */
  content: null,
  init() {
    this._super(...arguments);
    setProxy(this);
    tagForObject(this);
    setCustomTagFor(this, customTagForProxy);
  },
  willDestroy() {
    this.set("content", null);
    this._super(...arguments);
  },
  isTruthy: computed("content", function() {
    return Boolean(get(this, "content"));
  }),
  unknownProperty(key) {
    let content = contentFor(this);
    return content ? get(content, key) : void 0;
  },
  setUnknownProperty(key, value) {
    let m = meta(this);
    if (m.isInitializing() || m.isPrototypeMeta(this)) {
      defineProperty(this, key, null, value);
      return value;
    }
    let content = contentFor(this);
    !content && assert(`Cannot delegate set('${key}', ${value}) to the 'content' property of object proxy ${this}: its 'content' is undefined.`, content);
    return set(content, key, value);
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/enumerable/index.js
var Enumerable = Mixin.create();

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/enumerable/mutable.js
var MutableEnumerable = Mixin.create(Enumerable);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/mixins/target_action_support.js
var TargetActionSupport = Mixin.create({
  target: null,
  action: null,
  actionContext: null,
  actionContextObject: computed("actionContext", function() {
    let actionContext = get(this, "actionContext");
    if (typeof actionContext === "string") {
      let value = get(this, actionContext);
      if (value === void 0) {
        value = get(context.lookup, actionContext);
      }
      return value;
    } else {
      return actionContext;
    }
  }),
  /**
  Send an `action` with an `actionContext` to a `target`. The action, actionContext
  and target will be retrieved from properties of the object. For example:
   ```javascript
  import { alias } from '@ember/object/computed';
   App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {
    target: alias('controller'),
    action: 'save',
    actionContext: alias('context'),
    click() {
      this.triggerAction(); // Sends the `save` action, along with the current context
                            // to the current controller
    }
  });
  ```
   The `target`, `action`, and `actionContext` can be provided as properties of
  an optional object argument to `triggerAction` as well.
   ```javascript
  App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {
    click() {
      this.triggerAction({
        action: 'save',
        target: this.get('controller'),
        actionContext: this.get('context')
      }); // Sends the `save` action, along with the current context
          // to the current controller
    }
  });
  ```
   The `actionContext` defaults to the object you are mixing `TargetActionSupport` into.
  But `target` and `action` must be specified either as properties or with the argument
  to `triggerAction`, or a combination:
   ```javascript
  import { alias } from '@ember/object/computed';
   App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {
    target: alias('controller'),
    click() {
      this.triggerAction({
        action: 'save'
      }); // Sends the `save` action, along with a reference to `this`,
          // to the current controller
    }
  });
  ```
   @method triggerAction
  @param opts {Object} (optional, with the optional keys action, target and/or actionContext)
  @return {Boolean} true if the action was sent successfully and did not return false
  @private
  */
  triggerAction(opts = {}) {
    let {
      action: action2,
      target,
      actionContext
    } = opts;
    action2 = action2 || get(this, "action");
    target = target || getTarget(this);
    if (actionContext === void 0) {
      actionContext = get(this, "actionContextObject") || this;
    }
    let context2 = Array.isArray(actionContext) ? actionContext : [actionContext];
    if (target && action2) {
      let ret;
      if (isSendable(target)) {
        ret = target.send(action2, ...context2);
      } else {
        !(typeof target[action2] === "function") && assert(`The action '${action2}' did not exist on ${target}`, typeof target[action2] === "function");
        ret = target[action2](...context2);
      }
      if (ret !== false) {
        return true;
      }
    }
    return false;
  }
});
function isSendable(obj) {
  return obj != null && typeof obj === "object" && typeof obj.send === "function";
}
function getTarget(instance) {
  let target = get(instance, "target");
  if (target) {
    if (typeof target === "string") {
      let value = get(instance, target);
      if (value === void 0) {
        value = get(context.lookup, target);
      }
      return value;
    } else {
      return target;
    }
  }
  if (instance._target) {
    return instance._target;
  }
  return null;
}
if (true) {
  Object.seal(TargetActionSupport);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/rsvp-ziM3qQyS.js
function callbacksFor(object) {
  let callbacks = object._promiseCallbacks;
  if (!callbacks) {
    callbacks = object._promiseCallbacks = {};
  }
  return callbacks;
}
var EventTarget = {
  /**
    `EventTarget.mixin` extends an object with EventTarget methods. For
    Example:
     ```javascript
    import EventTarget from 'rsvp';
     let object = {};
     EventTarget.mixin(object);
     object.on('finished', function(event) {
      // handle event
    });
     object.trigger('finished', { detail: value });
    ```
     `EventTarget.mixin` also works with prototypes:
     ```javascript
    import EventTarget from 'rsvp';
     let Person = function() {};
    EventTarget.mixin(Person.prototype);
     let yehuda = new Person();
    let tom = new Person();
     yehuda.on('poke', function(event) {
      console.log('Yehuda says OW');
    });
     tom.on('poke', function(event) {
      console.log('Tom says OW');
    });
     yehuda.trigger('poke');
    tom.trigger('poke');
    ```
     @method mixin
    @for rsvp
    @private
    @param {Object} object object to extend with EventTarget methods
  */
  mixin(object) {
    object.on = this.on;
    object.off = this.off;
    object.trigger = this.trigger;
    object._promiseCallbacks = void 0;
    return object;
  },
  /**
    Registers a callback to be executed when `eventName` is triggered
     ```javascript
    object.on('event', function(eventInfo){
      // handle the event
    });
     object.trigger('event');
    ```
     @method on
    @for EventTarget
    @private
    @param {String} eventName name of the event to listen for
    @param {Function} callback function to be called when the event is triggered.
  */
  on(eventName, callback) {
    if (typeof callback !== "function") {
      throw new TypeError("Callback must be a function");
    }
    let allCallbacks = callbacksFor(this);
    let callbacks = allCallbacks[eventName];
    if (!callbacks) {
      callbacks = allCallbacks[eventName] = [];
    }
    if (callbacks.indexOf(callback) === -1) {
      callbacks.push(callback);
    }
  },
  /**
    You can use `off` to stop firing a particular callback for an event:
     ```javascript
    function doStuff() { // do stuff! }
    object.on('stuff', doStuff);
     object.trigger('stuff'); // doStuff will be called
     // Unregister ONLY the doStuff callback
    object.off('stuff', doStuff);
    object.trigger('stuff'); // doStuff will NOT be called
    ```
     If you don't pass a `callback` argument to `off`, ALL callbacks for the
    event will not be executed when the event fires. For example:
     ```javascript
    let callback1 = function(){};
    let callback2 = function(){};
     object.on('stuff', callback1);
    object.on('stuff', callback2);
     object.trigger('stuff'); // callback1 and callback2 will be executed.
     object.off('stuff');
    object.trigger('stuff'); // callback1 and callback2 will not be executed!
    ```
     @method off
    @for rsvp
    @private
    @param {String} eventName event to stop listening to
    @param {Function} [callback] optional argument. If given, only the function
    given will be removed from the event's callback queue. If no `callback`
    argument is given, all callbacks will be removed from the event's callback
    queue.
  */
  off(eventName, callback) {
    let allCallbacks = callbacksFor(this);
    if (!callback) {
      allCallbacks[eventName] = [];
      return;
    }
    let callbacks = allCallbacks[eventName];
    let index = callbacks.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  },
  /**
    Use `trigger` to fire custom events. For example:
     ```javascript
    object.on('foo', function(){
      console.log('foo event happened!');
    });
    object.trigger('foo');
    // 'foo event happened!' logged to the console
    ```
     You can also pass a value as a second argument to `trigger` that will be
    passed as an argument to all event listeners for the event:
     ```javascript
    object.on('foo', function(value){
      console.log(value.name);
    });
     object.trigger('foo', { name: 'bar' });
    // 'bar' logged to the console
    ```
     @method trigger
    @for rsvp
    @private
    @param {String} eventName name of the event to be triggered
    @param {*} [options] optional value to be passed to any event handlers for
    the given `eventName`
  */
  trigger(eventName, options, label) {
    let allCallbacks = callbacksFor(this);
    let callbacks = allCallbacks[eventName];
    if (callbacks) {
      let callback;
      for (let i = 0; i < callbacks.length; i++) {
        callback = callbacks[i];
        callback(options, label);
      }
    }
  }
};
var config = {
  instrument: false
};
EventTarget["mixin"](config);
function configure(name, value) {
  if (arguments.length === 2) {
    config[name] = value;
  } else {
    return config[name];
  }
}
var queue$1 = [];
function scheduleFlush$1() {
  setTimeout(() => {
    for (let i = 0; i < queue$1.length; i++) {
      let entry = queue$1[i];
      let payload = entry.payload;
      payload.guid = payload.key + payload.id;
      payload.childGuid = payload.key + payload.childId;
      if (payload.error) {
        payload.stack = payload.error.stack;
      }
      config["trigger"](entry.name, entry.payload);
    }
    queue$1.length = 0;
  }, 50);
}
function instrument(eventName, promise, child) {
  if (1 === queue$1.push({
    name: eventName,
    payload: {
      key: promise._guidKey,
      id: promise._id,
      eventName,
      detail: promise._result,
      childId: child && child._id,
      label: promise._label,
      timeStamp: Date.now(),
      error: config["instrument-with-stack"] ? new Error(promise._label) : null
    }
  })) {
    scheduleFlush$1();
  }
}
function resolve$2(object, label) {
  let Constructor = this;
  if (object && typeof object === "object" && object.constructor === Constructor) {
    return object;
  }
  let promise = new Constructor(noop4, label);
  resolve$1(promise, object);
  return promise;
}
function withOwnPromise() {
  return new TypeError("A promises callback cannot return that same promise.");
}
function objectOrFunction(x) {
  let type = typeof x;
  return x !== null && (type === "object" || type === "function");
}
function noop4() {
}
var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;
function tryThen(then2, value, fulfillmentHandler, rejectionHandler) {
  try {
    then2.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}
function handleForeignThenable(promise, thenable, then2) {
  config.async((promise2) => {
    let sealed = false;
    let error = tryThen(then2, thenable, (value) => {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable === value) {
        fulfill(promise2, value);
      } else {
        resolve$1(promise2, value);
      }
    }, (reason) => {
      if (sealed) {
        return;
      }
      sealed = true;
      reject$2(promise2, reason);
    }, "Settle: " + (promise2._label || " unknown promise"));
    if (!sealed && error) {
      sealed = true;
      reject$2(promise2, error);
    }
  }, promise);
}
function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    thenable._onError = null;
    reject$2(promise, thenable._result);
  } else {
    subscribe(thenable, void 0, (value) => {
      if (thenable === value) {
        fulfill(promise, value);
      } else {
        resolve$1(promise, value);
      }
    }, (reason) => reject$2(promise, reason));
  }
}
function handleMaybeThenable(promise, maybeThenable, then$1) {
  let isOwnThenable = maybeThenable.constructor === promise.constructor && then$1 === then && promise.constructor.resolve === resolve$2;
  if (isOwnThenable) {
    handleOwnThenable(promise, maybeThenable);
  } else if (typeof then$1 === "function") {
    handleForeignThenable(promise, maybeThenable, then$1);
  } else {
    fulfill(promise, maybeThenable);
  }
}
function resolve$1(promise, value) {
  if (promise === value) {
    fulfill(promise, value);
  } else if (objectOrFunction(value)) {
    let then2;
    try {
      then2 = value.then;
    } catch (error) {
      reject$2(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then2);
  } else {
    fulfill(promise, value);
  }
}
function publishRejection(promise) {
  if (promise._onError) {
    promise._onError(promise._result);
  }
  publish(promise);
}
function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._result = value;
  promise._state = FULFILLED;
  if (promise._subscribers.length === 0) {
    if (config.instrument) {
      instrument("fulfilled", promise);
    }
  } else {
    config.async(publish, promise);
  }
}
function reject$2(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;
  config.async(publishRejection, promise);
}
function subscribe(parent, child, onFulfillment, onRejection) {
  let subscribers = parent._subscribers;
  let length = subscribers.length;
  parent._onError = null;
  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED] = onRejection;
  if (length === 0 && parent._state) {
    config.async(publish, parent);
  }
}
function publish(promise) {
  let subscribers = promise._subscribers;
  let settled = promise._state;
  if (config.instrument) {
    instrument(settled === FULFILLED ? "fulfilled" : "rejected", promise);
  }
  if (subscribers.length === 0) {
    return;
  }
  let child, callback, result = promise._result;
  for (let i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];
    if (child) {
      invokeCallback(settled, child, callback, result);
    } else {
      callback(result);
    }
  }
  promise._subscribers.length = 0;
}
function invokeCallback(state, promise, callback, result) {
  let hasCallback = typeof callback === "function";
  let value, succeeded = true, error;
  if (hasCallback) {
    try {
      value = callback(result);
    } catch (e) {
      succeeded = false;
      error = e;
    }
  } else {
    value = result;
  }
  if (promise._state !== PENDING) ;
  else if (value === promise) {
    reject$2(promise, withOwnPromise());
  } else if (succeeded === false) {
    reject$2(promise, error);
  } else if (hasCallback) {
    resolve$1(promise, value);
  } else if (state === FULFILLED) {
    fulfill(promise, value);
  } else if (state === REJECTED) {
    reject$2(promise, value);
  }
}
function initializePromise(promise, resolver) {
  let resolved = false;
  try {
    resolver((value) => {
      if (resolved) {
        return;
      }
      resolved = true;
      resolve$1(promise, value);
    }, (reason) => {
      if (resolved) {
        return;
      }
      resolved = true;
      reject$2(promise, reason);
    });
  } catch (e) {
    reject$2(promise, e);
  }
}
function then(onFulfillment, onRejection, label) {
  let parent = this;
  let state = parent._state;
  if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {
    config.instrument && instrument("chained", parent, parent);
    return parent;
  }
  parent._onError = null;
  let child = new parent.constructor(noop4, label);
  let result = parent._result;
  config.instrument && instrument("chained", parent, child);
  if (state === PENDING) {
    subscribe(parent, child, onFulfillment, onRejection);
  } else {
    let callback = state === FULFILLED ? onFulfillment : onRejection;
    config.async(() => invokeCallback(state, child, callback, result));
  }
  return child;
}
var Enumerator = class {
  constructor(Constructor, input, abortOnReject, label) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop4, label);
    this._abortOnReject = abortOnReject;
    this._isUsingOwnPromise = Constructor === Promise$1;
    this._isUsingOwnResolve = Constructor.resolve === resolve$2;
    this._init(...arguments);
  }
  _init(Constructor, input) {
    let len2 = input.length || 0;
    this.length = len2;
    this._remaining = len2;
    this._result = new Array(len2);
    this._enumerate(input);
  }
  _enumerate(input) {
    let length = this.length;
    let promise = this.promise;
    for (let i = 0; promise._state === PENDING && i < length; i++) {
      this._eachEntry(input[i], i, true);
    }
    this._checkFullfillment();
  }
  _checkFullfillment() {
    if (this._remaining === 0) {
      let result = this._result;
      fulfill(this.promise, result);
      this._result = null;
    }
  }
  _settleMaybeThenable(entry, i, firstPass) {
    let c = this._instanceConstructor;
    if (this._isUsingOwnResolve) {
      let then$1, error, succeeded = true;
      try {
        then$1 = entry.then;
      } catch (e) {
        succeeded = false;
        error = e;
      }
      if (then$1 === then && entry._state !== PENDING) {
        entry._onError = null;
        this._settledAt(entry._state, i, entry._result, firstPass);
      } else if (typeof then$1 !== "function") {
        this._settledAt(FULFILLED, i, entry, firstPass);
      } else if (this._isUsingOwnPromise) {
        let promise = new c(noop4);
        if (succeeded === false) {
          reject$2(promise, error);
        } else {
          handleMaybeThenable(promise, entry, then$1);
          this._willSettleAt(promise, i, firstPass);
        }
      } else {
        this._willSettleAt(new c((resolve3) => resolve3(entry)), i, firstPass);
      }
    } else {
      this._willSettleAt(c.resolve(entry), i, firstPass);
    }
  }
  _eachEntry(entry, i, firstPass) {
    if (entry !== null && typeof entry === "object") {
      this._settleMaybeThenable(entry, i, firstPass);
    } else {
      this._setResultAt(FULFILLED, i, entry, firstPass);
    }
  }
  _settledAt(state, i, value, firstPass) {
    let promise = this.promise;
    if (promise._state === PENDING) {
      if (this._abortOnReject && state === REJECTED) {
        reject$2(promise, value);
      } else {
        this._setResultAt(state, i, value, firstPass);
        this._checkFullfillment();
      }
    }
  }
  _setResultAt(state, i, value, firstPass) {
    this._remaining--;
    this._result[i] = value;
  }
  _willSettleAt(promise, i, firstPass) {
    subscribe(promise, void 0, (value) => this._settledAt(FULFILLED, i, value, firstPass), (reason) => this._settledAt(REJECTED, i, reason, firstPass));
  }
};
function setSettledResult(state, i, value) {
  this._remaining--;
  if (state === FULFILLED) {
    this._result[i] = {
      state: "fulfilled",
      value
    };
  } else {
    this._result[i] = {
      state: "rejected",
      reason: value
    };
  }
}
function all$1(entries, label) {
  if (!Array.isArray(entries)) {
    return this.reject(new TypeError("Promise.all must be called with an array"), label);
  }
  return new Enumerator(this, entries, true, label).promise;
}
function race$1(entries, label) {
  let Constructor = this;
  let promise = new Constructor(noop4, label);
  if (!Array.isArray(entries)) {
    reject$2(promise, new TypeError("Promise.race must be called with an array"));
    return promise;
  }
  for (let i = 0; promise._state === PENDING && i < entries.length; i++) {
    subscribe(Constructor.resolve(entries[i]), void 0, (value) => resolve$1(promise, value), (reason) => reject$2(promise, reason));
  }
  return promise;
}
function reject$1(reason, label) {
  let Constructor = this;
  let promise = new Constructor(noop4, label);
  reject$2(promise, reason);
  return promise;
}
var guidKey = "rsvp_" + Date.now() + "-";
var counter = 0;
function needsResolver() {
  throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
}
function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}
var Promise$1 = class Promise2 {
  constructor(resolver, label) {
    this._id = counter++;
    this._label = label;
    this._state = void 0;
    this._result = void 0;
    this._subscribers = [];
    config.instrument && instrument("created", this);
    if (noop4 !== resolver) {
      typeof resolver !== "function" && needsResolver();
      this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
    }
  }
  _onError(reason) {
    config.after(() => {
      if (this._onError) {
        config.trigger("error", reason, this._label);
      }
    });
  }
  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn\'t find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */
  catch(onRejection, label) {
    return this.then(void 0, onRejection, label);
  }
  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuthor();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuthor();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @param {String} [label] optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */
  finally(callback, label) {
    let promise = this;
    let constructor = promise.constructor;
    if (typeof callback === "function") {
      return promise.then((value) => constructor.resolve(callback()).then(() => value), (reason) => constructor.resolve(callback()).then(() => {
        throw reason;
      }));
    }
    return promise.then(callback, callback);
  }
};
Promise$1.cast = resolve$2;
Promise$1.all = all$1;
Promise$1.race = race$1;
Promise$1.resolve = resolve$2;
Promise$1.reject = reject$1;
Promise$1.prototype._guidKey = guidKey;
Promise$1.prototype.then = then;
function makeObject(_, argumentNames) {
  let obj = {};
  let length = _.length;
  let args = new Array(length);
  for (let x = 0; x < length; x++) {
    args[x] = _[x];
  }
  for (let i = 0; i < argumentNames.length; i++) {
    let name = argumentNames[i];
    obj[name] = args[i + 1];
  }
  return obj;
}
function arrayResult(_) {
  let length = _.length;
  let args = new Array(length - 1);
  for (let i = 1; i < length; i++) {
    args[i - 1] = _[i];
  }
  return args;
}
function wrapThenable(then2, promise) {
  return {
    then(onFulFillment, onRejection) {
      return then2.call(promise, onFulFillment, onRejection);
    }
  };
}
function denodeify(nodeFunc, options) {
  let fn = function() {
    let l = arguments.length;
    let args = new Array(l + 1);
    let promiseInput = false;
    for (let i = 0; i < l; ++i) {
      let arg = arguments[i];
      if (!promiseInput) {
        if (arg !== null && typeof arg === "object") {
          if (arg.constructor === Promise$1) {
            promiseInput = true;
          } else {
            try {
              promiseInput = arg.then;
            } catch (error) {
              let p = new Promise$1(noop4);
              reject$2(p, error);
              return p;
            }
          }
        } else {
          promiseInput = false;
        }
        if (promiseInput && promiseInput !== true) {
          arg = wrapThenable(promiseInput, arg);
        }
      }
      args[i] = arg;
    }
    let promise = new Promise$1(noop4);
    args[l] = function(err, val) {
      if (err) {
        reject$2(promise, err);
      } else if (options === void 0) {
        resolve$1(promise, val);
      } else if (options === true) {
        resolve$1(promise, arrayResult(arguments));
      } else if (Array.isArray(options)) {
        resolve$1(promise, makeObject(arguments, options));
      } else {
        resolve$1(promise, val);
      }
    };
    if (promiseInput) {
      return handlePromiseInput(promise, args, nodeFunc, this);
    } else {
      return handleValueInput(promise, args, nodeFunc, this);
    }
  };
  fn.__proto__ = nodeFunc;
  return fn;
}
function handleValueInput(promise, args, nodeFunc, self2) {
  try {
    nodeFunc.apply(self2, args);
  } catch (error) {
    reject$2(promise, error);
  }
  return promise;
}
function handlePromiseInput(promise, args, nodeFunc, self2) {
  return Promise$1.all(args).then((args2) => handleValueInput(promise, args2, nodeFunc, self2));
}
function all(array, label) {
  return Promise$1.all(array, label);
}
var AllSettled = class extends Enumerator {
  constructor(Constructor, entries, label) {
    super(Constructor, entries, false, label);
  }
};
AllSettled.prototype._setResultAt = setSettledResult;
function allSettled(entries, label) {
  if (!Array.isArray(entries)) {
    return Promise$1.reject(new TypeError("Promise.allSettled must be called with an array"), label);
  }
  return new AllSettled(Promise$1, entries, label).promise;
}
function race(array, label) {
  return Promise$1.race(array, label);
}
var PromiseHash = class extends Enumerator {
  constructor(Constructor, object, abortOnReject = true, label) {
    super(Constructor, object, abortOnReject, label);
  }
  _init(Constructor, object) {
    this._result = {};
    this._enumerate(object);
  }
  _enumerate(input) {
    let keys = Object.keys(input);
    let length = keys.length;
    let promise = this.promise;
    this._remaining = length;
    let key, val;
    for (let i = 0; promise._state === PENDING && i < length; i++) {
      key = keys[i];
      val = input[key];
      this._eachEntry(val, key, true);
    }
    this._checkFullfillment();
  }
};
function hash(object, label) {
  return Promise$1.resolve(object, label).then(function(object2) {
    if (object2 === null || typeof object2 !== "object") {
      throw new TypeError("Promise.hash must be called with an object");
    }
    return new PromiseHash(Promise$1, object2, label).promise;
  });
}
var HashSettled = class extends PromiseHash {
  constructor(Constructor, object, label) {
    super(Constructor, object, false, label);
  }
};
HashSettled.prototype._setResultAt = setSettledResult;
function hashSettled(object, label) {
  return Promise$1.resolve(object, label).then(function(object2) {
    if (object2 === null || typeof object2 !== "object") {
      throw new TypeError("hashSettled must be called with an object");
    }
    return new HashSettled(Promise$1, object2, false, label).promise;
  });
}
function rethrow(reason) {
  setTimeout(() => {
    throw reason;
  });
  throw reason;
}
function defer(label) {
  let deferred3 = {
    resolve: void 0,
    reject: void 0
  };
  deferred3.promise = new Promise$1((resolve3, reject2) => {
    deferred3.resolve = resolve3;
    deferred3.reject = reject2;
  }, label);
  return deferred3;
}
var MapEnumerator = class extends Enumerator {
  constructor(Constructor, entries, mapFn, label) {
    super(Constructor, entries, true, label, mapFn);
  }
  _init(Constructor, input, bool, label, mapFn) {
    let len2 = input.length || 0;
    this.length = len2;
    this._remaining = len2;
    this._result = new Array(len2);
    this._mapFn = mapFn;
    this._enumerate(input);
  }
  _setResultAt(state, i, value, firstPass) {
    if (firstPass) {
      try {
        this._eachEntry(this._mapFn(value, i), i, false);
      } catch (error) {
        this._settledAt(REJECTED, i, error, false);
      }
    } else {
      this._remaining--;
      this._result[i] = value;
    }
  }
};
function map(promises, mapFn, label) {
  if (typeof mapFn !== "function") {
    return Promise$1.reject(new TypeError("map expects a function as a second argument"), label);
  }
  return Promise$1.resolve(promises, label).then(function(promises2) {
    if (!Array.isArray(promises2)) {
      throw new TypeError("map must be called with an array");
    }
    return new MapEnumerator(Promise$1, promises2, mapFn, label).promise;
  });
}
function resolve2(value, label) {
  return Promise$1.resolve(value, label);
}
function reject(reason, label) {
  return Promise$1.reject(reason, label);
}
var EMPTY_OBJECT = {};
var FilterEnumerator = class extends MapEnumerator {
  _checkFullfillment() {
    if (this._remaining === 0 && this._result !== null) {
      let result = this._result.filter((val) => val !== EMPTY_OBJECT);
      fulfill(this.promise, result);
      this._result = null;
    }
  }
  _setResultAt(state, i, value, firstPass) {
    if (firstPass) {
      this._result[i] = value;
      let val, succeeded = true;
      try {
        val = this._mapFn(value, i);
      } catch (error) {
        succeeded = false;
        this._settledAt(REJECTED, i, error, false);
      }
      if (succeeded) {
        this._eachEntry(val, i, false);
      }
    } else {
      this._remaining--;
      if (!value) {
        this._result[i] = EMPTY_OBJECT;
      }
    }
  }
};
function filter(promises, filterFn, label) {
  if (typeof filterFn !== "function") {
    return Promise$1.reject(new TypeError("filter expects function as a second argument"), label);
  }
  return Promise$1.resolve(promises, label).then(function(promises2) {
    if (!Array.isArray(promises2)) {
      throw new TypeError("filter must be called with an array");
    }
    return new FilterEnumerator(Promise$1, promises2, filterFn, label).promise;
  });
}
var len = 0;
var vertxNext;
function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    scheduleFlush();
  }
}
var browserWindow = typeof window !== "undefined" ? window : void 0;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
function useNextTick() {
  let nextTick = process.nextTick;
  let version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
  if (Array.isArray(version) && version[1] === "0" && version[2] === "10") {
    nextTick = setImmediate;
  }
  return () => nextTick(flush2);
}
function useVertxTimer() {
  if (typeof vertxNext !== "undefined") {
    return function() {
      vertxNext(flush2);
    };
  }
  return useSetTimeout();
}
function useMutationObserver() {
  let iterations = 0;
  let observer = new BrowserMutationObserver(flush2);
  let node = document.createTextNode("");
  observer.observe(node, {
    characterData: true
  });
  return () => node.data = iterations = ++iterations % 2;
}
function useMessageChannel() {
  let channel = new MessageChannel();
  channel.port1.onmessage = flush2;
  return () => channel.port2.postMessage(0);
}
function useSetTimeout() {
  return () => setTimeout(flush2, 1);
}
var queue = new Array(1e3);
function flush2() {
  for (let i = 0; i < len; i += 2) {
    let callback = queue[i];
    let arg = queue[i + 1];
    callback(arg);
    queue[i] = void 0;
    queue[i + 1] = void 0;
  }
  len = 0;
}
function attemptVertex() {
  try {
    const vertx = Function("return this")().require("vertx");
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}
var scheduleFlush;
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === void 0 && typeof window.require === "function") {
  scheduleFlush = attemptVertex();
} else {
  scheduleFlush = useSetTimeout();
}
config.async = asap;
config.after = (cb) => setTimeout(cb, 0);
var cast = resolve2;
var async = (callback, arg) => config.async(callback, arg);
function on() {
  config.on(...arguments);
}
function off() {
  config.off(...arguments);
}
if (typeof window !== "undefined" && typeof window["__PROMISE_INSTRUMENTATION__"] === "object") {
  let callbacks = window["__PROMISE_INSTRUMENTATION__"];
  configure("instrument", true);
  for (let eventName in callbacks) {
    if (callbacks.hasOwnProperty(eventName)) {
      on(eventName, callbacks[eventName]);
    }
  }
}
var RSVP = {
  asap,
  cast,
  Promise: Promise$1,
  EventTarget,
  all,
  allSettled,
  race,
  hash,
  hashSettled,
  rethrow,
  defer,
  denodeify,
  configure,
  on,
  off,
  resolve: resolve2,
  reject,
  map,
  async,
  filter
};
var RSVP$1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  EventTarget,
  Promise: Promise$1,
  all,
  allSettled,
  asap,
  async,
  cast,
  configure,
  default: RSVP,
  defer,
  denodeify,
  filter,
  hash,
  hashSettled,
  map,
  off,
  on,
  race,
  reject,
  resolve: resolve2,
  rethrow
}, Symbol.toStringTag, {
  value: "Module"
}));

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/runtime/lib/ext/rsvp.js
configure("async", (callback, promise) => {
  _backburner.schedule("actions", null, callback, promise);
});
configure("after", (cb) => {
  _backburner.schedule(_rsvpErrorQueue, null, cb);
});
on("error", onerrorDefault);
function onerrorDefault(reason) {
  let error = errorFor(reason);
  if (error) {
    let overrideDispatch = getDispatchOverride();
    if (overrideDispatch) {
      overrideDispatch(error);
    } else {
      throw error;
    }
  }
}
function errorFor(reason) {
  if (!reason) return;
  let withErrorThrown = reason;
  if (withErrorThrown.errorThrown) {
    return unwrapErrorThrown(withErrorThrown);
  }
  let withName = reason;
  if (withName.name === "UnrecognizedURLError") {
    assert(`The URL '${withName.message}' did not match any routes in your application`, false);
    return;
  }
  if (reason.name === "TransitionAborted") {
    return;
  }
  return reason;
}
function unwrapErrorThrown(reason) {
  let error = reason.errorThrown;
  if (typeof error === "string") {
    error = new Error(error);
  }
  Object.defineProperty(error, "__reason_with_error_thrown__", {
    value: reason,
    enumerable: false
  });
  return error;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/array/lib/make-array.js
var {
  isArray: isArray3
} = Array;
function makeArray(obj) {
  if (obj === null || obj === void 0) {
    return [];
  }
  return isArray3(obj) ? obj : [obj];
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/core.js
function hasSetUnknownProperty(val) {
  return typeof val === "object" && val !== null && typeof val.setUnknownProperty === "function";
}
function hasToStringExtension(val) {
  return typeof val === "object" && val !== null && typeof val.toStringExtension === "function";
}
var reopen = Mixin.prototype.reopen;
var wasApplied = /* @__PURE__ */ new WeakSet();
var prototypeMixinMap = /* @__PURE__ */ new WeakMap();
var initCalled = true ? /* @__PURE__ */ new WeakSet() : void 0;
var destroyCalled = /* @__PURE__ */ new Set();
function ensureDestroyCalled(instance) {
  if (!destroyCalled.has(instance)) {
    instance.destroy();
  }
}
function initialize(obj, properties) {
  let m = meta(obj);
  if (properties !== void 0) {
    !(typeof properties === "object" && properties !== null) && assert("EmberObject.create only accepts objects.", typeof properties === "object" && properties !== null);
    !!(properties instanceof Mixin) && assert("EmberObject.create no longer supports mixing in other definitions, use .extend & .create separately instead.", !(properties instanceof Mixin));
    let concatenatedProperties = obj.concatenatedProperties;
    let mergedProperties = obj.mergedProperties;
    let keyNames = Object.keys(properties);
    for (let keyName of keyNames) {
      let value = properties[keyName];
      !!isClassicDecorator(value) && assert("EmberObject.create no longer supports defining computed properties. Define computed properties using extend() or reopen() before calling create().", !isClassicDecorator(value));
      !!(typeof value === "function" && value.toString().indexOf("._super") !== -1) && assert("EmberObject.create no longer supports defining methods that call _super.", !(typeof value === "function" && value.toString().indexOf("._super") !== -1));
      !!(keyName === "actions" && ActionHandler.detect(obj)) && assert("`actions` must be provided at extend time, not at create time, when Ember.ActionHandler is used (i.e. views, controllers & routes).", !(keyName === "actions" && ActionHandler.detect(obj)));
      let possibleDesc = descriptorForProperty(obj, keyName, m);
      let isDescriptor = possibleDesc !== void 0;
      if (!isDescriptor) {
        if (concatenatedProperties !== void 0 && concatenatedProperties.length > 0 && concatenatedProperties.includes(keyName)) {
          let baseValue = obj[keyName];
          if (baseValue) {
            value = makeArray(baseValue).concat(value);
          } else {
            value = makeArray(value);
          }
        }
        if (mergedProperties !== void 0 && mergedProperties.length > 0 && mergedProperties.includes(keyName)) {
          let baseValue = obj[keyName];
          value = Object.assign({}, baseValue, value);
        }
      }
      if (isDescriptor) {
        possibleDesc.set(obj, keyName, value);
      } else if (hasSetUnknownProperty(obj) && !(keyName in obj)) {
        obj.setUnknownProperty(keyName, value);
      } else {
        if (true) {
          defineProperty(obj, keyName, null, value, m);
        } else {
          obj[keyName] = value;
        }
      }
    }
  }
  if (true) {
    initCalled.add(obj);
  }
  obj.init(properties);
  m.unsetInitializing();
  let observerEvents = m.observerEvents();
  if (observerEvents !== void 0) {
    for (let i = 0; i < observerEvents.length; i++) {
      activateObserver(obj, observerEvents[i].event, observerEvents[i].sync);
    }
  }
  sendEvent(obj, "init", void 0, void 0, m);
}
var CoreObject = class {
  /** @internal */
  [OWNER];
  constructor(owner) {
    this[OWNER] = owner;
    this.constructor.proto();
    let self2;
    if (hasUnknownProperty(this)) {
      let messageFor = (obj, property) => {
        return `You attempted to access the \`${String(property)}\` property (of ${obj}).
Since Ember 3.1, this is usually fine as you no longer need to use \`.get()\`
to access computed properties. However, in this case, the object in question
is a special kind of Ember object (a proxy). Therefore, it is still necessary
to use \`.get('${String(property)}')\` in this case.

If you encountered this error because of third-party code that you don't control,
there is more information at https://github.com/emberjs/ember.js/issues/16148, and
you can help us improve this error message by telling us more about what happened in
this situation.`;
      };
      self2 = new Proxy(this, {
        get(target, property, receiver) {
          if (property === PROXY_CONTENT) {
            return target;
          } else if (
            // init called will be set on the proxy, not the target, so get with the receiver
            !initCalled.has(receiver) || typeof property === "symbol" || isInternalSymbol(property) || property === "toJSON" || property === "toString" || property === "toStringExtension" || property === "didDefineProperty" || property === "willWatchProperty" || property === "didUnwatchProperty" || property === "didAddListener" || property === "didRemoveListener" || property === "isDescriptor" || property === "_onLookup" || property in target
          ) {
            return Reflect.get(target, property, receiver);
          }
          let value = target.unknownProperty.call(receiver, property);
          if (typeof value !== "function") {
            !(value === void 0 || value === null) && assert(messageFor(receiver, property), value === void 0 || value === null);
          }
        }
      });
    } else {
      self2 = this;
    }
    const destroyable = self2;
    registerDestructor(self2, ensureDestroyCalled, true);
    registerDestructor(self2, () => destroyable.willDestroy());
    let m = meta(self2);
    m.setInitializing();
    if (self2 !== this) {
      return self2;
    }
  }
  reopen(...args) {
    applyMixin(this, args);
    return this;
  }
  /**
    An overridable method called when objects are instantiated. By default,
    does nothing unless it is overridden during class definition.
     Example:
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend({
      init() {
        alert(`Name is ${this.get('name')}`);
      }
    });
     let steve = Person.create({
      name: 'Steve'
    });
     // alerts 'Name is Steve'.
    ```
     NOTE: If you do override `init` for a framework class like `Component`
    from `@ember/component`, be sure to call `this._super(...arguments)`
    in your `init` declaration!
    If you don't, Ember may not have an opportunity to
    do important setup work, and you'll see strange behavior in your
    application.
     @method init
    @public
  */
  init(_properties) {
  }
  /**
    Defines the properties that will be concatenated from the superclass
    (instead of overridden).
     By default, when you extend an Ember class a property defined in
    the subclass overrides a property with the same name that is defined
    in the superclass. However, there are some cases where it is preferable
    to build up a property's value by combining the superclass' property
    value with the subclass' value. An example of this in use within Ember
    is the `classNames` property of `Component` from `@ember/component`.
     Here is some sample code showing the difference between a concatenated
    property and a normal one:
     ```javascript
    import EmberObject from '@ember/object';
     const Bar = EmberObject.extend({
      // Configure which properties to concatenate
      concatenatedProperties: ['concatenatedProperty'],
       someNonConcatenatedProperty: ['bar'],
      concatenatedProperty: ['bar']
    });
     const FooBar = Bar.extend({
      someNonConcatenatedProperty: ['foo'],
      concatenatedProperty: ['foo']
    });
     let fooBar = FooBar.create();
    fooBar.get('someNonConcatenatedProperty'); // ['foo']
    fooBar.get('concatenatedProperty'); // ['bar', 'foo']
    ```
     This behavior extends to object creation as well. Continuing the
    above example:
     ```javascript
    let fooBar = FooBar.create({
      someNonConcatenatedProperty: ['baz'],
      concatenatedProperty: ['baz']
    })
    fooBar.get('someNonConcatenatedProperty'); // ['baz']
    fooBar.get('concatenatedProperty'); // ['bar', 'foo', 'baz']
    ```
     Adding a single property that is not an array will just add it in the array:
     ```javascript
    let fooBar = FooBar.create({
      concatenatedProperty: 'baz'
    })
    view.get('concatenatedProperty'); // ['bar', 'foo', 'baz']
    ```
     Using the `concatenatedProperties` property, we can tell Ember to mix the
    content of the properties.
     In `Component` the `classNames`, `classNameBindings` and
    `attributeBindings` properties are concatenated.
     This feature is available for you to use throughout the Ember object model,
    although typical app developers are likely to use it infrequently. Since
    it changes expectations about behavior of properties, you should properly
    document its usage in each individual concatenated property (to not
    mislead your users to think they can override the property in a subclass).
     @property concatenatedProperties
    @type Array
    @default null
    @public
  */
  /**
    Defines the properties that will be merged from the superclass
    (instead of overridden).
     By default, when you extend an Ember class a property defined in
    the subclass overrides a property with the same name that is defined
    in the superclass. However, there are some cases where it is preferable
    to build up a property's value by merging the superclass property value
    with the subclass property's value. An example of this in use within Ember
    is the `queryParams` property of routes.
     Here is some sample code showing the difference between a merged
    property and a normal one:
     ```javascript
    import EmberObject from '@ember/object';
     const Bar = EmberObject.extend({
      // Configure which properties are to be merged
      mergedProperties: ['mergedProperty'],
       someNonMergedProperty: {
        nonMerged: 'superclass value of nonMerged'
      },
      mergedProperty: {
        page: { replace: false },
        limit: { replace: true }
      }
    });
     const FooBar = Bar.extend({
      someNonMergedProperty: {
        completelyNonMerged: 'subclass value of nonMerged'
      },
      mergedProperty: {
        limit: { replace: false }
      }
    });
     let fooBar = FooBar.create();
     fooBar.get('someNonMergedProperty');
    // => { completelyNonMerged: 'subclass value of nonMerged' }
    //
    // Note the entire object, including the nonMerged property of
    // the superclass object, has been replaced
     fooBar.get('mergedProperty');
    // => {
    //   page: {replace: false},
    //   limit: {replace: false}
    // }
    //
    // Note the page remains from the superclass, and the
    // `limit` property's value of `false` has been merged from
    // the subclass.
    ```
     This behavior is not available during object `create` calls. It is only
    available at `extend` time.
     In `Route` the `queryParams` property is merged.
     This feature is available for you to use throughout the Ember object model,
    although typical app developers are likely to use it infrequently. Since
    it changes expectations about behavior of properties, you should properly
    document its usage in each individual merged property (to not
    mislead your users to think they can override the property in a subclass).
     @property mergedProperties
    @type Array
    @default null
    @public
  */
  /**
    Destroyed object property flag.
     if this property is `true` the observers and bindings were already
    removed by the effect of calling the `destroy()` method.
     @property isDestroyed
    @default false
    @public
  */
  get isDestroyed() {
    return isDestroyed(this);
  }
  set isDestroyed(_value) {
    assert(`You cannot set \`${this}.isDestroyed\` directly, please use \`.destroy()\`.`, false);
  }
  /**
    Destruction scheduled flag. The `destroy()` method has been called.
     The object stays intact until the end of the run loop at which point
    the `isDestroyed` flag is set.
     @property isDestroying
    @default false
    @public
  */
  get isDestroying() {
    return isDestroying(this);
  }
  set isDestroying(_value) {
    assert(`You cannot set \`${this}.isDestroying\` directly, please use \`.destroy()\`.`, false);
  }
  /**
    Destroys an object by setting the `isDestroyed` flag and removing its
    metadata, which effectively destroys observers and bindings.
     If you try to set a property on a destroyed object, an exception will be
    raised.
     Note that destruction is scheduled for the end of the run loop and does not
    happen immediately.  It will set an isDestroying flag immediately.
     @method destroy
    @return {EmberObject} receiver
    @public
  */
  destroy() {
    destroyCalled.add(this);
    try {
      destroy(this);
    } finally {
      destroyCalled.delete(this);
    }
    return this;
  }
  /**
    Override to implement teardown.
     @method willDestroy
    @public
  */
  willDestroy() {
  }
  /**
    Returns a string representation which attempts to provide more information
    than Javascript's `toString` typically does, in a generic way for all Ember
    objects.
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend();
    person = Person.create();
    person.toString(); //=> "<Person:ember1024>"
    ```
     If the object's class is not defined on an Ember namespace, it will
    indicate it is a subclass of the registered superclass:
     ```javascript
    const Student = Person.extend();
    let student = Student.create();
    student.toString(); //=> "<(subclass of Person):ember1025>"
    ```
     If the method `toStringExtension` is defined, its return value will be
    included in the output.
     ```javascript
    const Teacher = Person.extend({
      toStringExtension() {
        return this.get('fullName');
      }
    });
    teacher = Teacher.create();
    teacher.toString(); //=> "<Teacher:ember1026:Tom Dale>"
    ```
     @method toString
    @return {String} string representation
    @public
  */
  toString() {
    let extension = hasToStringExtension(this) ? `:${this.toStringExtension()}` : "";
    return `<${getFactoryFor(this) || "(unknown)"}:${guidFor(this)}${extension}>`;
  }
  /**
    Creates a new subclass.
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend({
      say(thing) {
        alert(thing);
       }
    });
    ```
     This defines a new subclass of EmberObject: `Person`. It contains one method: `say()`.
     You can also create a subclass from any existing class by calling its `extend()` method.
    For example, you might want to create a subclass of Ember's built-in `Component` class:
     ```javascript
    import Component from '@ember/component';
     const PersonComponent = Component.extend({
      tagName: 'li',
      classNameBindings: ['isAdministrator']
    });
    ```
     When defining a subclass, you can override methods but still access the
    implementation of your parent class by calling the special `_super()` method:
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend({
      say(thing) {
        let name = this.get('name');
        alert(`${name} says: ${thing}`);
      }
    });
     const Soldier = Person.extend({
      say(thing) {
        this._super(`${thing}, sir!`);
      },
      march(numberOfHours) {
        alert(`${this.get('name')} marches for ${numberOfHours} hours.`);
      }
    });
     let yehuda = Soldier.create({
      name: 'Yehuda Katz'
    });
     yehuda.say('Yes');  // alerts "Yehuda Katz says: Yes, sir!"
    ```
     The `create()` on line #17 creates an *instance* of the `Soldier` class.
    The `extend()` on line #8 creates a *subclass* of `Person`. Any instance
    of the `Person` class will *not* have the `march()` method.
     You can also pass `Mixin` classes to add additional properties to the subclass.
     ```javascript
    import EmberObject from '@ember/object';
    import Mixin from '@ember/object/mixin';
     const Person = EmberObject.extend({
      say(thing) {
        alert(`${this.get('name')} says: ${thing}`);
      }
    });
     const SingingMixin = Mixin.create({
      sing(thing) {
        alert(`${this.get('name')} sings: la la la ${thing}`);
      }
    });
     const BroadwayStar = Person.extend(SingingMixin, {
      dance() {
        alert(`${this.get('name')} dances: tap tap tap tap `);
      }
    });
    ```
     The `BroadwayStar` class contains three methods: `say()`, `sing()`, and `dance()`.
     @method extend
    @static
    @for @ember/object
    @param {Mixin} [mixins]* One or more Mixin classes
    @param {Object} [arguments]* Object containing values to use within the new class
    @public
  */
  static extend(...mixins) {
    let Class = class extends this {
    };
    reopen.apply(Class.PrototypeMixin, mixins);
    return Class;
  }
  /**
    Creates an instance of a class. Accepts either no arguments, or an object
    containing values to initialize the newly instantiated object with.
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend({
      helloWorld() {
        alert(`Hi, my name is ${this.get('name')}`);
      }
    });
     let tom = Person.create({
      name: 'Tom Dale'
    });
     tom.helloWorld(); // alerts "Hi, my name is Tom Dale".
    ```
     `create` will call the `init` function if defined during
    `AnyObject.extend`
     If no arguments are passed to `create`, it will not set values to the new
    instance during initialization:
     ```javascript
    let noName = Person.create();
    noName.helloWorld(); // alerts undefined
    ```
     NOTE: For performance reasons, you cannot declare methods or computed
    properties during `create`. You should instead declare methods and computed
    properties when using `extend`.
     @method create
    @for @ember/object
    @static
    @param [arguments]*
    @public
  */
  static create(...args) {
    let props = args[0];
    let instance;
    if (props !== void 0) {
      instance = new this(getOwner2(props));
      let factory = getFactoryFor(props);
      setFactoryFor(instance, factory);
    } else {
      instance = new this();
    }
    if (args.length <= 1) {
      initialize(instance, props);
    } else {
      initialize(instance, flattenProps.apply(this, args));
    }
    return instance;
  }
  /**
    Augments a constructor's prototype with additional
    properties and functions:
     ```javascript
    import EmberObject from '@ember/object';
     const MyObject = EmberObject.extend({
      name: 'an object'
    });
     o = MyObject.create();
    o.get('name'); // 'an object'
     MyObject.reopen({
      say(msg) {
        console.log(msg);
      }
    });
     o2 = MyObject.create();
    o2.say('hello'); // logs "hello"
     o.say('goodbye'); // logs "goodbye"
    ```
     To add functions and properties to the constructor itself,
    see `reopenClass`
     @method reopen
    @for @ember/object
    @static
    @public
  */
  static reopen(...args) {
    this.willReopen();
    reopen.apply(this.PrototypeMixin, args);
    return this;
  }
  static willReopen() {
    let p = this.prototype;
    if (wasApplied.has(p)) {
      wasApplied.delete(p);
      if (prototypeMixinMap.has(this)) {
        prototypeMixinMap.set(this, Mixin.create(this.PrototypeMixin));
      }
    }
  }
  /**
    Augments a constructor's own properties and functions:
     ```javascript
    import EmberObject from '@ember/object';
     const MyObject = EmberObject.extend({
      name: 'an object'
    });
     MyObject.reopenClass({
      canBuild: false
    });
     MyObject.canBuild; // false
    o = MyObject.create();
    ```
     In other words, this creates static properties and functions for the class.
    These are only available on the class and not on any instance of that class.
     ```javascript
    import EmberObject from '@ember/object';
     const Person = EmberObject.extend({
      name: '',
      sayHello() {
        alert(`Hello. My name is ${this.get('name')}`);
      }
    });
     Person.reopenClass({
      species: 'Homo sapiens',
       createPerson(name) {
        return Person.create({ name });
      }
    });
     let tom = Person.create({
      name: 'Tom Dale'
    });
    let yehuda = Person.createPerson('Yehuda Katz');
     tom.sayHello(); // "Hello. My name is Tom Dale"
    yehuda.sayHello(); // "Hello. My name is Yehuda Katz"
    alert(Person.species); // "Homo sapiens"
    ```
     Note that `species` and `createPerson` are *not* valid on the `tom` and `yehuda`
    variables. They are only valid on `Person`.
     To add functions and properties to instances of
    a constructor by extending the constructor's prototype
    see `reopen`
     @method reopenClass
    @for @ember/object
    @static
    @public
  */
  static reopenClass(...mixins) {
    applyMixin(this, mixins);
    return this;
  }
  static detect(obj) {
    if ("function" !== typeof obj) {
      return false;
    }
    while (obj) {
      if (obj === this) {
        return true;
      }
      obj = obj.superclass;
    }
    return false;
  }
  static detectInstance(obj) {
    return obj instanceof this;
  }
  /**
    In some cases, you may want to annotate computed properties with additional
    metadata about how they function or what values they operate on. For
    example, computed property functions may close over variables that are then
    no longer available for introspection.
     You can pass a hash of these values to a computed property like this:
     ```javascript
    import { computed } from '@ember/object';
     person: computed(function() {
      let personId = this.get('personId');
      return Person.create({ id: personId });
    }).meta({ type: Person })
    ```
     Once you've done this, you can retrieve the values saved to the computed
    property from your class like this:
     ```javascript
    MyClass.metaForProperty('person');
    ```
     This will return the original hash that was passed to `meta()`.
     @static
    @method metaForProperty
    @param key {String} property name
    @private
  */
  static metaForProperty(key) {
    let proto = this.proto();
    let possibleDesc = descriptorForProperty(proto, key);
    !(possibleDesc !== void 0) && assert(`metaForProperty() could not find a computed property with key '${key}'.`, possibleDesc !== void 0);
    return possibleDesc._meta || {};
  }
  /**
    Iterate over each computed property for the class, passing its name
    and any associated metadata (see `metaForProperty`) to the callback.
     @static
    @method eachComputedProperty
    @param {Function} callback
    @param {Object} binding
    @private
  */
  static eachComputedProperty(callback, binding = this) {
    this.proto();
    let empty = {};
    meta(this.prototype).forEachDescriptors((name, descriptor) => {
      if (descriptor.enumerable) {
        let meta3 = descriptor._meta || empty;
        callback.call(binding, name, meta3);
      }
    });
  }
  static get PrototypeMixin() {
    let prototypeMixin = prototypeMixinMap.get(this);
    if (prototypeMixin === void 0) {
      prototypeMixin = Mixin.create();
      prototypeMixin.ownerConstructor = this;
      prototypeMixinMap.set(this, prototypeMixin);
    }
    return prototypeMixin;
  }
  static get superclass() {
    let c = Object.getPrototypeOf(this);
    return c !== Function.prototype ? c : void 0;
  }
  static proto() {
    let p = this.prototype;
    if (!wasApplied.has(p)) {
      wasApplied.add(p);
      let parent = this.superclass;
      if (parent) {
        parent.proto();
      }
      if (prototypeMixinMap.has(this)) {
        this.PrototypeMixin.apply(p);
      }
    }
    return p;
  }
  static toString() {
    return `<${getFactoryFor(this) || "(unknown)"}:constructor>`;
  }
  static isClass = true;
  static isMethod = false;
  static _onLookup;
  static _lazyInjections;
};
function flattenProps(...props) {
  let initProperties = {};
  for (let properties of props) {
    !!(properties instanceof Mixin) && assert("EmberObject.create no longer supports mixing in other definitions, use .extend & .create separately instead.", !(properties instanceof Mixin));
    let keyNames = Object.keys(properties);
    for (let j = 0, k = keyNames.length; j < k; j++) {
      let keyName = keyNames[j];
      let value = properties[keyName];
      initProperties[keyName] = value;
    }
  }
  return initProperties;
}
if (true) {
  CoreObject._onLookup = function injectedPropertyAssertion(debugContainerKey) {
    let [type] = debugContainerKey.split(":");
    let proto = this.proto();
    for (let key in proto) {
      let desc = descriptorForProperty(proto, key);
      if (desc && DEBUG_INJECTION_FUNCTIONS.has(desc._getter)) {
        !(type === "controller" || DEBUG_INJECTION_FUNCTIONS.get(desc._getter).type !== "controller") && assert(`Defining \`${key}\` as an injected controller property on a non-controller (\`${debugContainerKey}\`) is not allowed.`, type === "controller" || DEBUG_INJECTION_FUNCTIONS.get(desc._getter).type !== "controller");
      }
    }
  };
  CoreObject._lazyInjections = function() {
    let injections = {};
    let proto = this.proto();
    let key;
    let desc;
    for (key in proto) {
      desc = descriptorForProperty(proto, key);
      if (desc && DEBUG_INJECTION_FUNCTIONS.has(desc._getter)) {
        let {
          namespace,
          source,
          type,
          name
        } = DEBUG_INJECTION_FUNCTIONS.get(desc._getter);
        injections[key] = {
          namespace,
          source,
          specifier: `${type}:${name || key}`
        };
      }
    }
    return injections;
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/observable.js
var Observable = Mixin.create({
  get(keyName) {
    return get(this, keyName);
  },
  getProperties(...args) {
    return getProperties(this, ...args);
  },
  set(keyName, value) {
    return set(this, keyName, value);
  },
  setProperties(hash2) {
    return setProperties(this, hash2);
  },
  /**
    Begins a grouping of property changes.
     You can use this method to group property changes so that notifications
    will not be sent until the changes are finished. If you plan to make a
    large number of changes to an object at one time, you should call this
    method at the beginning of the changes to begin deferring change
    notifications. When you are done making changes, call
    `endPropertyChanges()` to deliver the deferred change notifications and end
    deferring.
     @method beginPropertyChanges
    @return {Observable}
    @private
  */
  beginPropertyChanges() {
    beginPropertyChanges();
    return this;
  },
  /**
    Ends a grouping of property changes.
     You can use this method to group property changes so that notifications
    will not be sent until the changes are finished. If you plan to make a
    large number of changes to an object at one time, you should call
    `beginPropertyChanges()` at the beginning of the changes to defer change
    notifications. When you are done making changes, call this method to
    deliver the deferred change notifications and end deferring.
     @method endPropertyChanges
    @return {Observable}
    @private
  */
  endPropertyChanges() {
    endPropertyChanges();
    return this;
  },
  notifyPropertyChange(keyName) {
    notifyPropertyChange(this, keyName);
    return this;
  },
  addObserver(key, target, method, sync) {
    addObserver(this, key, target, method, sync);
    return this;
  },
  removeObserver(key, target, method, sync) {
    removeObserver(this, key, target, method, sync);
    return this;
  },
  /**
    Returns `true` if the object currently has observers registered for a
    particular key. You can use this method to potentially defer performing
    an expensive action until someone begins observing a particular property
    on the object.
     @method hasObserverFor
    @param {String} key Key to check
    @return {Boolean}
    @private
  */
  hasObserverFor(key) {
    return hasListeners(this, `${key}:change`);
  },
  incrementProperty(keyName, increment = 1) {
    !(!isNaN(parseFloat(String(increment))) && isFinite(increment)) && assert("Must pass a numeric value to incrementProperty", !isNaN(parseFloat(String(increment))) && isFinite(increment));
    return set(this, keyName, (parseFloat(get(this, keyName)) || 0) + increment);
  },
  decrementProperty(keyName, decrement = 1) {
    !((typeof decrement === "number" || !isNaN(parseFloat(decrement))) && isFinite(decrement)) && assert("Must pass a numeric value to decrementProperty", (typeof decrement === "number" || !isNaN(parseFloat(decrement))) && isFinite(decrement));
    return set(this, keyName, (get(this, keyName) || 0) - decrement);
  },
  toggleProperty(keyName) {
    return set(this, keyName, !get(this, keyName));
  },
  cacheFor(keyName) {
    let meta3 = peekMeta(this);
    return meta3 !== null ? meta3.valueFor(keyName) : void 0;
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/index.js
var EmberObject = class extends CoreObject.extend(Observable) {
  get _debugContainerKey() {
    let factory = getFactoryFor(this);
    return factory !== void 0 && factory.fullName;
  }
};
var BINDINGS_MAP = /* @__PURE__ */ new WeakMap();
function hasProto(obj) {
  return obj != null && obj.constructor !== void 0 && typeof obj.constructor.proto === "function";
}
function setupAction(target, key, actionFn) {
  if (hasProto(target)) {
    target.constructor.proto();
  }
  if (!Object.prototype.hasOwnProperty.call(target, "actions")) {
    let parentActions = target.actions;
    target.actions = parentActions ? Object.assign({}, parentActions) : {};
  }
  !(target.actions != null) && assert("[BUG] Somehow the target doesn't have actions!", target.actions != null);
  target.actions[key] = actionFn;
  return {
    get() {
      let bindings = BINDINGS_MAP.get(this);
      if (bindings === void 0) {
        bindings = /* @__PURE__ */ new Map();
        BINDINGS_MAP.set(this, bindings);
      }
      let fn = bindings.get(actionFn);
      if (fn === void 0) {
        fn = actionFn.bind(this);
        bindings.set(actionFn, fn);
      }
      return fn;
    }
  };
}
function action(...args) {
  let actionFn;
  if (!isElementDescriptor(args)) {
    actionFn = args[0];
    let decorator = function(target2, key2, _desc, _meta, isClassicDecorator2) {
      !isClassicDecorator2 && assert("The @action decorator may only be passed a method when used in classic classes. You should decorate methods directly in native classes", isClassicDecorator2);
      !(typeof actionFn === "function") && assert("The action() decorator must be passed a method when used in classic classes", typeof actionFn === "function");
      return setupAction(target2, key2, actionFn);
    };
    setClassicDecorator(decorator);
    return decorator;
  }
  let [target, key, desc] = args;
  actionFn = desc?.value;
  !(typeof actionFn === "function") && assert("The @action decorator must be applied to methods when used in native classes", typeof actionFn === "function");
  return setupAction(target, key, actionFn);
}
setClassicDecorator(action);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/owner/index.js
var getOwner3 = getOwner2;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/cache.js
var BucketCache = class {
  cache;
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
  }
  has(bucketKey) {
    return this.cache.has(bucketKey);
  }
  stash(bucketKey, key, value) {
    let bucket = this.cache.get(bucketKey);
    if (bucket === void 0) {
      bucket = /* @__PURE__ */ new Map();
      this.cache.set(bucketKey, bucket);
    }
    bucket.set(key, value);
  }
  lookup(bucketKey, prop, defaultValue) {
    if (!this.has(bucketKey)) {
      return defaultValue;
    }
    let bucket = this.cache.get(bucketKey);
    if (bucket.has(prop)) {
      return bucket.get(prop);
    } else {
      return defaultValue;
    }
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/dsl.js
var uuid2 = 0;
function isCallback(value) {
  return typeof value === "function";
}
function isOptions(value) {
  return value !== null && typeof value === "object";
}
var DSLImpl = class _DSLImpl {
  parent;
  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types
  matches;
  enableLoadingSubstates;
  explicitIndex = false;
  options;
  constructor(name = null, options) {
    this.parent = name;
    this.enableLoadingSubstates = Boolean(options && options.enableLoadingSubstates);
    this.matches = [];
    this.options = options;
  }
  route(name, _options, _callback) {
    let options;
    let callback = null;
    let dummyErrorRoute = `/_unused_dummy_error_path_route_${name}/:error`;
    if (isCallback(_options)) {
      !(arguments.length === 2) && assert("Unexpected arguments", arguments.length === 2);
      options = {};
      callback = _options;
    } else if (isCallback(_callback)) {
      !(arguments.length === 3) && assert("Unexpected arguments", arguments.length === 3);
      !isOptions(_options) && assert("Unexpected arguments", isOptions(_options));
      options = _options;
      callback = _callback;
    } else {
      options = _options || {};
    }
    !(() => {
      if (options.overrideNameAssertion === true) {
        return true;
      }
      return ["basic", "application"].indexOf(name) === -1;
    })() && assert(`'${name}' cannot be used as a route name.`, (() => {
      if (options.overrideNameAssertion === true) {
        return true;
      }
      return ["basic", "application"].indexOf(name) === -1;
    })());
    !(name.indexOf(":") === -1) && assert(`'${name}' is not a valid route name. It cannot contain a ':'. You may want to use the 'path' option instead.`, name.indexOf(":") === -1);
    if (this.enableLoadingSubstates) {
      createRoute(this, `${name}_loading`, {
        resetNamespace: options.resetNamespace
      });
      createRoute(this, `${name}_error`, {
        resetNamespace: options.resetNamespace,
        path: dummyErrorRoute
      });
    }
    if (callback) {
      let fullName = getFullName(this, name, options.resetNamespace);
      let dsl = new _DSLImpl(fullName, this.options);
      createRoute(dsl, "loading");
      createRoute(dsl, "error", {
        path: dummyErrorRoute
      });
      callback.call(dsl);
      createRoute(this, name, options, dsl.generate());
    } else {
      createRoute(this, name, options);
    }
  }
  push(url, name, callback, serialize) {
    let parts = name.split(".");
    if (this.options.engineInfo) {
      let localFullName = name.slice(this.options.engineInfo.fullName.length + 1);
      let routeInfo = Object.assign({
        localFullName
      }, this.options.engineInfo);
      if (serialize) {
        routeInfo.serializeMethod = serialize;
      }
      this.options.addRouteForEngine(name, routeInfo);
    } else if (serialize) {
      throw new Error(`Defining a route serializer on route '${name}' outside an Engine is not allowed.`);
    }
    if (url === "" || url === "/" || parts[parts.length - 1] === "index") {
      this.explicitIndex = true;
    }
    this.matches.push(url, name, callback);
  }
  generate() {
    let dslMatches = this.matches;
    if (!this.explicitIndex) {
      this.route("index", {
        path: "/"
      });
    }
    return (match2) => {
      for (let i = 0; i < dslMatches.length; i += 3) {
        match2(dslMatches[i]).to(dslMatches[i + 1], dslMatches[i + 2]);
      }
    };
  }
  mount(_name, options = {}) {
    let engineRouteMap = this.options.resolveRouteMap(_name);
    let name = _name;
    if (options.as) {
      name = options.as;
    }
    let fullName = getFullName(this, name, options.resetNamespace);
    let engineInfo = {
      name: _name,
      instanceId: uuid2++,
      mountPoint: fullName,
      fullName
    };
    let path = options.path;
    if (typeof path !== "string") {
      path = `/${name}`;
    }
    let callback;
    let dummyErrorRoute = `/_unused_dummy_error_path_route_${name}/:error`;
    if (engineRouteMap) {
      let shouldResetEngineInfo = false;
      let oldEngineInfo = this.options.engineInfo;
      if (oldEngineInfo) {
        shouldResetEngineInfo = true;
        this.options.engineInfo = engineInfo;
      }
      let optionsForChild = Object.assign({
        engineInfo
      }, this.options);
      let childDSL = new _DSLImpl(fullName, optionsForChild);
      createRoute(childDSL, "loading");
      createRoute(childDSL, "error", {
        path: dummyErrorRoute
      });
      engineRouteMap.class.call(childDSL);
      callback = childDSL.generate();
      if (shouldResetEngineInfo) {
        this.options.engineInfo = oldEngineInfo;
      }
    }
    let localFullName = "application";
    let routeInfo = Object.assign({
      localFullName
    }, engineInfo);
    if (this.enableLoadingSubstates) {
      let substateName = `${name}_loading`;
      let localFullName2 = `application_loading`;
      let routeInfo2 = Object.assign({
        localFullName: localFullName2
      }, engineInfo);
      createRoute(this, substateName, {
        resetNamespace: options.resetNamespace
      });
      this.options.addRouteForEngine(substateName, routeInfo2);
      substateName = `${name}_error`;
      localFullName2 = `application_error`;
      routeInfo2 = Object.assign({
        localFullName: localFullName2
      }, engineInfo);
      createRoute(this, substateName, {
        resetNamespace: options.resetNamespace,
        path: dummyErrorRoute
      });
      this.options.addRouteForEngine(substateName, routeInfo2);
    }
    this.options.addRouteForEngine(fullName, routeInfo);
    this.push(path, fullName, callback);
  }
};
function canNest(dsl) {
  return dsl.parent !== "application";
}
function getFullName(dsl, name, resetNamespace) {
  if (canNest(dsl) && resetNamespace !== true) {
    return `${dsl.parent}.${name}`;
  } else {
    return name;
  }
}
function createRoute(dsl, name, options = {}, callback) {
  let fullName = getFullName(dsl, name, options.resetNamespace);
  if (typeof options.path !== "string") {
    options.path = `/${name}`;
  }
  dsl.push(options.path, fullName, callback, options.serialize);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/engine/lib/engine-parent.js
var ENGINE_PARENT = Symbol("ENGINE_PARENT");
function getEngineParent(engine) {
  return engine[ENGINE_PARENT];
}
function setEngineParent(engine, parent) {
  engine[ENGINE_PARENT] = parent;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/engine/instance.js
var EngineInstance = class extends EmberObject.extend(RegistryProxyMixin, ContainerProxyMixin) {
  /**
   @private
   @method setupRegistry
   @param {Registry} registry
   @param {BootOptions} options
   */
  // This is effectively an "abstract" method: it defines the contract a
  // subclass (e.g. `ApplicationInstance`) must follow to implement this
  // behavior, but an `EngineInstance` has no behavior of its own here.
  static setupRegistry(_registry, _options) {
  }
  /**
    The base `Engine` for which this is an instance.
     @property {Engine} engine
    @private
  */
  [ENGINE_PARENT];
  _booted = false;
  init(properties) {
    super.init(properties);
    guidFor(this);
    this.base ??= this.application;
    let registry = this.__registry__ = new Registry({
      fallback: this.base.__registry__
    });
    this.__container__ = registry.container({
      owner: this
    });
    this._booted = false;
  }
  _bootPromise = null;
  /**
    Initialize the `EngineInstance` and return a promise that resolves
    with the instance itself when the boot process is complete.
     The primary task here is to run any registered instance initializers.
     See the documentation on `BootOptions` for the options it takes.
     @public
    @method boot
    @param options {Object}
    @return {Promise<EngineInstance,Error>}
  */
  boot(options) {
    if (this._bootPromise) {
      return this._bootPromise;
    }
    this._bootPromise = new RSVP$1.Promise((resolve3) => {
      resolve3(this._bootSync(options));
    });
    return this._bootPromise;
  }
  /**
    Unfortunately, a lot of existing code assumes booting an instance is
    synchronous  specifically, a lot of tests assume the last call to
    `app.advanceReadiness()` or `app.reset()` will result in a new instance
    being fully-booted when the current runloop completes.
     We would like new code (like the `visit` API) to stop making this
    assumption, so we created the asynchronous version above that returns a
    promise. But until we have migrated all the code, we would have to expose
    this method for use *internally* in places where we need to boot an instance
    synchronously.
     @private
  */
  _bootSync(options) {
    if (this._booted) {
      return this;
    }
    !getEngineParent(this) && assert("An engine instance's parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.", getEngineParent(this));
    this.cloneParentDependencies();
    this.setupRegistry(options);
    this.base.runInstanceInitializers(this);
    this._booted = true;
    return this;
  }
  setupRegistry(options = this.__container__.lookup("-environment:main")) {
    this.constructor.setupRegistry(this.__registry__, options);
  }
  /**
   Unregister a factory.
    Overrides `RegistryProxy#unregister` in order to clear any cached instances
   of the unregistered factory.
    @public
   @method unregister
   @param {String} fullName
   */
  unregister(fullName) {
    this.__container__.reset(fullName);
    this.__registry__.unregister(fullName);
  }
  /**
    Build a new `EngineInstance` that's a child of this instance.
     Engines must be registered by name with their parent engine
    (or application).
     @private
    @method buildChildEngineInstance
    @param name {String} the registered name of the engine.
    @param options {Object} options provided to the engine instance.
    @return {EngineInstance,Error}
  */
  buildChildEngineInstance(name, options = {}) {
    let ChildEngine = this.lookup(`engine:${name}`);
    if (!ChildEngine) {
      throw new Error(`You attempted to mount the engine '${name}', but it is not registered with its parent.`);
    }
    let engineInstance = ChildEngine.buildInstance(options);
    setEngineParent(engineInstance, this);
    return engineInstance;
  }
  /**
    Clone dependencies shared between an engine instance and its parent.
     @private
    @method cloneParentDependencies
  */
  cloneParentDependencies() {
    const parent = getEngineParent(this);
    !parent && assert("expected parent", parent);
    let registrations = ["route:basic", "service:-routing"];
    registrations.forEach((key) => {
      let registration = parent.resolveRegistration(key);
      !isFactory(registration) && assert("expected registration to be a factory", isFactory(registration));
      this.register(key, registration);
    });
    let env = parent.lookup("-environment:main");
    this.register("-environment:main", env, {
      instantiate: false
    });
    let singletons = ["router:main", privatize`-bucket-cache:main`, "-view-registry:main", `renderer:-dom`, "service:-document"];
    if (env["isInteractive"]) {
      singletons.push("event_dispatcher:main");
    }
    singletons.forEach((key) => {
      let singleton = parent.lookup(key);
      this.register(key, singleton, {
        instantiate: false
      });
    });
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/route-recognizer/index.js
var createObject = Object.create;
function createMap() {
  var map3 = createObject(null);
  map3["__"] = void 0;
  delete map3["__"];
  return map3;
}
var Target = function Target2(path, matcher, delegate) {
  this.path = path;
  this.matcher = matcher;
  this.delegate = delegate;
};
Target.prototype.to = function to(target, callback) {
  var delegate = this.delegate;
  if (delegate && delegate.willAddRoute) {
    target = delegate.willAddRoute(this.matcher.target, target);
  }
  this.matcher.add(this.path, target);
  if (callback) {
    if (callback.length === 0) {
      throw new Error("You must have an argument in the function passed to `to`");
    }
    this.matcher.addChild(this.path, target, callback, this.delegate);
  }
};
var Matcher = function Matcher2(target) {
  this.routes = createMap();
  this.children = createMap();
  this.target = target;
};
Matcher.prototype.add = function add(path, target) {
  this.routes[path] = target;
};
Matcher.prototype.addChild = function addChild(path, target, callback, delegate) {
  var matcher = new Matcher(target);
  this.children[path] = matcher;
  var match2 = generateMatch(path, matcher, delegate);
  if (delegate && delegate.contextEntered) {
    delegate.contextEntered(target, match2);
  }
  callback(match2);
};
function generateMatch(startingPath, matcher, delegate) {
  function match2(path, callback) {
    var fullPath = startingPath + path;
    if (callback) {
      callback(generateMatch(fullPath, matcher, delegate));
    } else {
      return new Target(fullPath, matcher, delegate);
    }
  }
  return match2;
}
function addRoute(routeArray, path, handler) {
  var len2 = 0;
  for (var i = 0; i < routeArray.length; i++) {
    len2 += routeArray[i].path.length;
  }
  path = path.substr(len2);
  var route = {
    path,
    handler
  };
  routeArray.push(route);
}
function eachRoute(baseRoute, matcher, callback, binding) {
  var routes = matcher.routes;
  var paths = Object.keys(routes);
  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    var routeArray = baseRoute.slice();
    addRoute(routeArray, path, routes[path]);
    var nested = matcher.children[path];
    if (nested) {
      eachRoute(routeArray, nested, callback, binding);
    } else {
      callback.call(binding, routeArray);
    }
  }
}
var map2 = function(callback, addRouteCallback) {
  var matcher = new Matcher();
  callback(generateMatch("", matcher, this.delegate));
  eachRoute([], matcher, function(routes) {
    if (addRouteCallback) {
      addRouteCallback(this, routes);
    } else {
      this.add(routes);
    }
  }, this);
};
function normalizePath(path) {
  return path.split("/").map(normalizeSegment).join("/");
}
var SEGMENT_RESERVED_CHARS = /%|\//g;
function normalizeSegment(segment) {
  if (segment.length < 3 || segment.indexOf("%") === -1) {
    return segment;
  }
  return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);
}
var PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;
function encodePathSegment(str) {
  return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);
}
var escapeRegex = /(\/|\.|\*|\+|\?|\||\(|\)|\[|\]|\{|\}|\\)/g;
var isArray4 = Array.isArray;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function getParam(params, key) {
  if (typeof params !== "object" || params === null) {
    throw new Error("You must pass an object as the second argument to `generate`.");
  }
  if (!hasOwnProperty2.call(params, key)) {
    throw new Error("You must provide param `" + key + "` to `generate`.");
  }
  var value = params[key];
  var str = typeof value === "string" ? value : "" + value;
  if (str.length === 0) {
    throw new Error("You must provide a param `" + key + "`.");
  }
  return str;
}
var eachChar = [];
eachChar[
  0
  /* Static */
] = function(segment, currentState) {
  var state = currentState;
  var value = segment.value;
  for (var i = 0; i < value.length; i++) {
    var ch = value.charCodeAt(i);
    state = state.put(ch, false, false);
  }
  return state;
};
eachChar[
  1
  /* Dynamic */
] = function(_, currentState) {
  return currentState.put(47, true, true);
};
eachChar[
  2
  /* Star */
] = function(_, currentState) {
  return currentState.put(-1, false, true);
};
eachChar[
  4
  /* Epsilon */
] = function(_, currentState) {
  return currentState;
};
var regex = [];
regex[
  0
  /* Static */
] = function(segment) {
  return segment.value.replace(escapeRegex, "\\$1");
};
regex[
  1
  /* Dynamic */
] = function() {
  return "([^/]+)";
};
regex[
  2
  /* Star */
] = function() {
  return "(.+)";
};
regex[
  4
  /* Epsilon */
] = function() {
  return "";
};
var generate = [];
generate[
  0
  /* Static */
] = function(segment) {
  return segment.value;
};
generate[
  1
  /* Dynamic */
] = function(segment, params) {
  var value = getParam(params, segment.value);
  if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {
    return encodePathSegment(value);
  } else {
    return value;
  }
};
generate[
  2
  /* Star */
] = function(segment, params) {
  return getParam(params, segment.value);
};
generate[
  4
  /* Epsilon */
] = function() {
  return "";
};
var EmptyObject = Object.freeze({});
var EmptyArray = Object.freeze([]);
function parse(segments, route, types) {
  if (route.length > 0 && route.charCodeAt(0) === 47) {
    route = route.substr(1);
  }
  var parts = route.split("/");
  var names = void 0;
  var shouldDecodes = void 0;
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    var flags2 = 0;
    var type = 0;
    if (part === "") {
      type = 4;
    } else if (part.charCodeAt(0) === 58) {
      type = 1;
    } else if (part.charCodeAt(0) === 42) {
      type = 2;
    } else {
      type = 0;
    }
    flags2 = 2 << type;
    if (flags2 & 12) {
      part = part.slice(1);
      names = names || [];
      names.push(part);
      shouldDecodes = shouldDecodes || [];
      shouldDecodes.push((flags2 & 4) !== 0);
    }
    if (flags2 & 14) {
      types[type]++;
    }
    segments.push({
      type,
      value: normalizeSegment(part)
    });
  }
  return {
    names: names || EmptyArray,
    shouldDecodes: shouldDecodes || EmptyArray
  };
}
function isEqualCharSpec(spec, char, negate) {
  return spec.char === char && spec.negate === negate;
}
var State = function State2(states, id, char, negate, repeat) {
  this.states = states;
  this.id = id;
  this.char = char;
  this.negate = negate;
  this.nextStates = repeat ? id : null;
  this.pattern = "";
  this._regex = void 0;
  this.handlers = void 0;
  this.types = void 0;
};
State.prototype.regex = function regex$1() {
  if (!this._regex) {
    this._regex = new RegExp(this.pattern);
  }
  return this._regex;
};
State.prototype.get = function get2(char, negate) {
  var this$1$1 = this;
  var nextStates = this.nextStates;
  if (nextStates === null) {
    return;
  }
  if (isArray4(nextStates)) {
    for (var i = 0; i < nextStates.length; i++) {
      var child = this$1$1.states[nextStates[i]];
      if (isEqualCharSpec(child, char, negate)) {
        return child;
      }
    }
  } else {
    var child$1 = this.states[nextStates];
    if (isEqualCharSpec(child$1, char, negate)) {
      return child$1;
    }
  }
};
State.prototype.put = function put(char, negate, repeat) {
  var state;
  if (state = this.get(char, negate)) {
    return state;
  }
  var states = this.states;
  state = new State(states, states.length, char, negate, repeat);
  states[states.length] = state;
  if (this.nextStates == null) {
    this.nextStates = state.id;
  } else if (isArray4(this.nextStates)) {
    this.nextStates.push(state.id);
  } else {
    this.nextStates = [this.nextStates, state.id];
  }
  return state;
};
State.prototype.match = function match(ch) {
  var this$1$1 = this;
  var nextStates = this.nextStates;
  if (!nextStates) {
    return [];
  }
  var returned = [];
  if (isArray4(nextStates)) {
    for (var i = 0; i < nextStates.length; i++) {
      var child = this$1$1.states[nextStates[i]];
      if (isMatch(child, ch)) {
        returned.push(child);
      }
    }
  } else {
    var child$1 = this.states[nextStates];
    if (isMatch(child$1, ch)) {
      returned.push(child$1);
    }
  }
  return returned;
};
function isMatch(spec, char) {
  return spec.negate ? spec.char !== char && spec.char !== -1 : spec.char === char || spec.char === -1;
}
function sortSolutions(states) {
  return states.sort(function(a, b) {
    var ref = a.types || [0, 0, 0];
    var astatics = ref[0];
    var adynamics = ref[1];
    var astars = ref[2];
    var ref$1 = b.types || [0, 0, 0];
    var bstatics = ref$1[0];
    var bdynamics = ref$1[1];
    var bstars = ref$1[2];
    if (astars !== bstars) {
      return astars - bstars;
    }
    if (astars) {
      if (astatics !== bstatics) {
        return bstatics - astatics;
      }
      if (adynamics !== bdynamics) {
        return bdynamics - adynamics;
      }
    }
    if (adynamics !== bdynamics) {
      return adynamics - bdynamics;
    }
    if (astatics !== bstatics) {
      return bstatics - astatics;
    }
    return 0;
  });
}
function recognizeChar(states, ch) {
  var nextStates = [];
  for (var i = 0, l = states.length; i < l; i++) {
    var state = states[i];
    nextStates = nextStates.concat(state.match(ch));
  }
  return nextStates;
}
var RecognizeResults = function RecognizeResults2(queryParams) {
  this.length = 0;
  this.queryParams = queryParams || {};
};
RecognizeResults.prototype.splice = Array.prototype.splice;
RecognizeResults.prototype.slice = Array.prototype.slice;
RecognizeResults.prototype.push = Array.prototype.push;
function findHandler(state, originalPath, queryParams) {
  var handlers = state.handlers;
  var regex2 = state.regex();
  if (!regex2 || !handlers) {
    throw new Error("state not initialized");
  }
  var captures = originalPath.match(regex2);
  var currentCapture = 1;
  var result = new RecognizeResults(queryParams);
  result.length = handlers.length;
  for (var i = 0; i < handlers.length; i++) {
    var handler = handlers[i];
    var names = handler.names;
    var shouldDecodes = handler.shouldDecodes;
    var params = EmptyObject;
    var isDynamic = false;
    if (names !== EmptyArray && shouldDecodes !== EmptyArray) {
      for (var j = 0; j < names.length; j++) {
        isDynamic = true;
        var name = names[j];
        var capture = captures && captures[currentCapture++];
        if (params === EmptyObject) {
          params = {};
        }
        if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {
          params[name] = capture && decodeURIComponent(capture);
        } else {
          params[name] = capture;
        }
      }
    }
    result[i] = {
      handler: handler.handler,
      params,
      isDynamic
    };
  }
  return result;
}
function decodeQueryParamPart(part) {
  part = part.replace(/\+/gm, "%20");
  var result;
  try {
    result = decodeURIComponent(part);
  } catch (error) {
    result = "";
  }
  return result;
}
var RouteRecognizer = function RouteRecognizer2() {
  this.names = createMap();
  var states = [];
  var state = new State(states, 0, -1, true, false);
  states[0] = state;
  this.states = states;
  this.rootState = state;
};
RouteRecognizer.prototype.add = function add2(routes, options) {
  var currentState = this.rootState;
  var pattern = "^";
  var types = [0, 0, 0];
  var handlers = new Array(routes.length);
  var allSegments = [];
  var isEmpty = true;
  var j = 0;
  for (var i = 0; i < routes.length; i++) {
    var route = routes[i];
    var ref = parse(allSegments, route.path, types);
    var names = ref.names;
    var shouldDecodes = ref.shouldDecodes;
    for (; j < allSegments.length; j++) {
      var segment = allSegments[j];
      if (segment.type === 4) {
        continue;
      }
      isEmpty = false;
      currentState = currentState.put(47, false, false);
      pattern += "/";
      currentState = eachChar[segment.type](segment, currentState);
      pattern += regex[segment.type](segment);
    }
    handlers[i] = {
      handler: route.handler,
      names,
      shouldDecodes
    };
  }
  if (isEmpty) {
    currentState = currentState.put(47, false, false);
    pattern += "/";
  }
  currentState.handlers = handlers;
  currentState.pattern = pattern + "$";
  currentState.types = types;
  var name;
  if (typeof options === "object" && options !== null && options.as) {
    name = options.as;
  }
  if (name) {
    this.names[name] = {
      segments: allSegments,
      handlers
    };
  }
};
RouteRecognizer.prototype.handlersFor = function handlersFor(name) {
  var route = this.names[name];
  if (!route) {
    throw new Error("There is no route named " + name);
  }
  var result = new Array(route.handlers.length);
  for (var i = 0; i < route.handlers.length; i++) {
    var handler = route.handlers[i];
    result[i] = handler;
  }
  return result;
};
RouteRecognizer.prototype.hasRoute = function hasRoute(name) {
  return !!this.names[name];
};
RouteRecognizer.prototype.generate = function generate$1(name, params) {
  var route = this.names[name];
  var output = "";
  if (!route) {
    throw new Error("There is no route named " + name);
  }
  var segments = route.segments;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment.type === 4) {
      continue;
    }
    output += "/";
    output += generate[segment.type](segment, params);
  }
  if (output.charAt(0) !== "/") {
    output = "/" + output;
  }
  if (params && params.queryParams) {
    output += this.generateQueryString(params.queryParams);
  }
  return output;
};
RouteRecognizer.prototype.generateQueryString = function generateQueryString(params) {
  var pairs = [];
  var keys = Object.keys(params);
  keys.sort();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = params[key];
    if (value == null) {
      continue;
    }
    var pair = encodeURIComponent(key);
    if (isArray4(value)) {
      for (var j = 0; j < value.length; j++) {
        var arrayPair = key + "[]=" + encodeURIComponent(value[j]);
        pairs.push(arrayPair);
      }
    } else {
      pair += "=" + encodeURIComponent(value);
      pairs.push(pair);
    }
  }
  if (pairs.length === 0) {
    return "";
  }
  return "?" + pairs.join("&");
};
RouteRecognizer.prototype.parseQueryString = function parseQueryString(queryString) {
  var pairs = queryString.split("&");
  var queryParams = {};
  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i].split("="), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray7 = false, value = void 0;
    if (pair.length === 1) {
      value = "true";
    } else {
      if (keyLength > 2 && key.slice(keyLength - 2) === "[]") {
        isArray7 = true;
        key = key.slice(0, keyLength - 2);
        if (!queryParams[key]) {
          queryParams[key] = [];
        }
      }
      value = pair[1] ? decodeQueryParamPart(pair[1]) : "";
    }
    if (isArray7) {
      queryParams[key].push(value);
    } else {
      queryParams[key] = value;
    }
  }
  return queryParams;
};
RouteRecognizer.prototype.recognize = function recognize(path) {
  var results;
  var states = [this.rootState];
  var queryParams = {};
  var isSlashDropped = false;
  var hashStart = path.indexOf("#");
  if (hashStart !== -1) {
    path = path.substr(0, hashStart);
  }
  var queryStart = path.indexOf("?");
  if (queryStart !== -1) {
    var queryString = path.substr(queryStart + 1, path.length);
    path = path.substr(0, queryStart);
    queryParams = this.parseQueryString(queryString);
  }
  if (path.charAt(0) !== "/") {
    path = "/" + path;
  }
  var originalPath = path;
  if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {
    path = normalizePath(path);
  } else {
    path = decodeURI(path);
    originalPath = decodeURI(originalPath);
  }
  var pathLen = path.length;
  if (pathLen > 1 && path.charAt(pathLen - 1) === "/") {
    path = path.substr(0, pathLen - 1);
    originalPath = originalPath.substr(0, originalPath.length - 1);
    isSlashDropped = true;
  }
  for (var i = 0; i < path.length; i++) {
    states = recognizeChar(states, path.charCodeAt(i));
    if (!states.length) {
      break;
    }
  }
  var solutions = [];
  for (var i$1 = 0; i$1 < states.length; i$1++) {
    if (states[i$1].handlers) {
      solutions.push(states[i$1]);
    }
  }
  states = sortSolutions(solutions);
  var state = solutions[0];
  if (state && state.handlers) {
    if (isSlashDropped && state.pattern && state.pattern.slice(-5) === "(.+)$") {
      originalPath = originalPath + "/";
    }
    results = findHandler(state, originalPath, queryParams);
  }
  return results;
};
RouteRecognizer.VERSION = "0.3.4";
RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS = true;
RouteRecognizer.Normalizer = {
  normalizeSegment,
  normalizePath,
  encodePathSegment
};
RouteRecognizer.prototype.map = map2;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/unrecognized-url-error-Csk7hcJF.js
function buildTransitionAborted() {
  let error = new Error("TransitionAborted");
  error.name = "TransitionAborted";
  error.code = "TRANSITION_ABORTED";
  return error;
}
function isTransitionAborted(maybeError) {
  return typeof maybeError === "object" && maybeError !== null && maybeError.code === "TRANSITION_ABORTED";
}
function isAbortable(maybeAbortable) {
  return typeof maybeAbortable === "object" && maybeAbortable !== null && typeof maybeAbortable.isAborted === "boolean";
}
function throwIfAborted(maybe) {
  if (isAbortable(maybe) && maybe.isAborted) {
    throw buildTransitionAborted();
  }
}
var slice = Array.prototype.slice;
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
function isPromise(p) {
  return p !== null && typeof p === "object" && typeof p.then === "function";
}
function merge(hash2, other) {
  for (let prop in other) {
    if (hasOwnProperty3.call(other, prop)) {
      hash2[prop] = other[prop];
    }
  }
}
function extractQueryParams(array) {
  let len2 = array && array.length, head, queryParams;
  if (len2 && len2 > 0) {
    let obj = array[len2 - 1];
    if (isQueryParamsContainer(obj)) {
      queryParams = obj.queryParams;
      head = slice.call(array, 0, len2 - 1);
      return [head, queryParams];
    }
  }
  return [array, null];
}
function isQueryParamsContainer(obj) {
  if (obj && typeof obj === "object") {
    let cast2 = obj;
    return "queryParams" in cast2 && Object.keys(cast2.queryParams).every((k) => typeof k === "string");
  }
  return false;
}
function coerceQueryParamsToString(queryParams) {
  for (let key in queryParams) {
    let val = queryParams[key];
    if (typeof val === "number") {
      queryParams[key] = "" + val;
    } else if (Array.isArray(val)) {
      for (let i = 0, l = val.length; i < l; i++) {
        val[i] = "" + val[i];
      }
    }
  }
}
function log(router, ...args) {
  if (!router.log) {
    return;
  }
  if (args.length === 2) {
    let [sequence, msg] = args;
    router.log("Transition #" + sequence + ": " + msg);
  } else {
    let [msg] = args;
    router.log(msg);
  }
}
function isParam(object) {
  return typeof object === "string" || object instanceof String || typeof object === "number" || object instanceof Number;
}
function forEach(array, callback) {
  for (let i = 0, l = array.length; i < l && callback(array[i]) !== false; i++) {
  }
}
function getChangelist(oldObject, newObject) {
  let key;
  let results = {
    all: {},
    changed: {},
    removed: {}
  };
  merge(results.all, newObject);
  let didChange = false;
  coerceQueryParamsToString(oldObject);
  coerceQueryParamsToString(newObject);
  for (key in oldObject) {
    if (hasOwnProperty3.call(oldObject, key)) {
      if (!hasOwnProperty3.call(newObject, key)) {
        didChange = true;
        results.removed[key] = oldObject[key];
      }
    }
  }
  for (key in newObject) {
    if (hasOwnProperty3.call(newObject, key)) {
      let oldElement = oldObject[key];
      let newElement = newObject[key];
      if (isArray5(oldElement) && isArray5(newElement)) {
        if (oldElement.length !== newElement.length) {
          results.changed[key] = newObject[key];
          didChange = true;
        } else {
          for (let i = 0, l = oldElement.length; i < l; i++) {
            if (oldElement[i] !== newElement[i]) {
              results.changed[key] = newObject[key];
              didChange = true;
            }
          }
        }
      } else if (oldObject[key] !== newObject[key]) {
        results.changed[key] = newObject[key];
        didChange = true;
      }
    }
  }
  return didChange ? results : void 0;
}
function isArray5(obj) {
  return Array.isArray(obj);
}
function promiseLabel(label) {
  return "Router: " + label;
}
var STATE_SYMBOL = `__STATE__-2619860001345920-3322w3`;
var PARAMS_SYMBOL = `__PARAMS__-261986232992830203-23323`;
var QUERY_PARAMS_SYMBOL = `__QPS__-2619863929824844-32323`;
var REDIRECT_DESTINATION_SYMBOL = `__RDS__-2619863929824844-32323`;
var Transition = class _Transition {
  constructor(router, intent, state, error = void 0, previousTransition = void 0) {
    this.from = null;
    this.to = void 0;
    this.isAborted = false;
    this.isActive = true;
    this.urlMethod = "update";
    this.resolveIndex = 0;
    this.queryParamsOnly = false;
    this.isTransition = true;
    this.isCausedByAbortingTransition = false;
    this.isCausedByInitialTransition = false;
    this.isCausedByAbortingReplaceTransition = false;
    this._visibleQueryParams = {};
    this.isIntermediate = false;
    this[STATE_SYMBOL] = state || router.state;
    this.intent = intent;
    this.router = router;
    this.data = intent && intent.data || {};
    this.resolvedModels = {};
    this[QUERY_PARAMS_SYMBOL] = {};
    this.promise = void 0;
    this.error = void 0;
    this[PARAMS_SYMBOL] = {};
    this.routeInfos = [];
    this.targetName = void 0;
    this.pivotHandler = void 0;
    this.sequence = -1;
    if (true) {
      let error2 = new Error(`Transition creation stack`);
      this.debugCreationStack = () => error2.stack;
      this.debugAbortStack = () => void 0;
      this.debugPreviousTransition = previousTransition;
    }
    if (error) {
      this.promise = Promise$1.reject(error);
      this.error = error;
      return;
    }
    this.isCausedByAbortingTransition = !!previousTransition;
    this.isCausedByInitialTransition = !!previousTransition && (previousTransition.isCausedByInitialTransition || previousTransition.sequence === 0);
    this.isCausedByAbortingReplaceTransition = !!previousTransition && previousTransition.urlMethod === "replace" && (!previousTransition.isCausedByAbortingTransition || previousTransition.isCausedByAbortingReplaceTransition);
    if (state) {
      this[PARAMS_SYMBOL] = state.params;
      this[QUERY_PARAMS_SYMBOL] = state.queryParams;
      this.routeInfos = state.routeInfos;
      let len2 = state.routeInfos.length;
      if (len2) {
        this.targetName = state.routeInfos[len2 - 1].name;
      }
      for (let i = 0; i < len2; ++i) {
        let handlerInfo = state.routeInfos[i];
        if (!handlerInfo.isResolved) {
          break;
        }
        this.pivotHandler = handlerInfo.route;
      }
      this.sequence = router.currentSequence++;
      this.promise = state.resolve(this).catch((result) => {
        let error2 = this.router.transitionDidError(result, this);
        throw error2;
      }, promiseLabel("Handle Abort"));
    } else {
      this.promise = Promise$1.resolve(this[STATE_SYMBOL]);
      this[PARAMS_SYMBOL] = {};
    }
  }
  /**
    The Transition's internal promise. Calling `.then` on this property
    is that same as calling `.then` on the Transition object itself, but
    this property is exposed for when you want to pass around a
    Transition's promise, but not the Transition object itself, since
    Transition object can be externally `abort`ed, while the promise
    cannot.
       @property promise
    @type {Object}
    @public
   */
  /**
    Custom state can be stored on a Transition's `data` object.
    This can be useful for decorating a Transition within an earlier
    hook and shared with a later hook. Properties set on `data` will
    be copied to new transitions generated by calling `retry` on this
    transition.
       @property data
    @type {Object}
    @public
   */
  /**
    A standard promise hook that resolves if the transition
    succeeds and rejects if it fails/redirects/aborts.
       Forwards to the internal `promise` property which you can
    use in situations where you want to pass around a thenable,
    but not the Transition itself.
       @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
    @public
   */
  then(onFulfilled, onRejected, label) {
    return this.promise.then(onFulfilled, onRejected, label);
  }
  /**
       Forwards to the internal `promise` property which you can
    use in situations where you want to pass around a thennable,
    but not the Transition itself.
       @method catch
    @param {Function} onRejection
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
    @public
   */
  catch(onRejection, label) {
    return this.promise.catch(onRejection, label);
  }
  /**
       Forwards to the internal `promise` property which you can
    use in situations where you want to pass around a thenable,
    but not the Transition itself.
       @method finally
    @param {Function} callback
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
    @public
   */
  finally(callback, label) {
    return this.promise.finally(callback, label);
  }
  /**
    Aborts the Transition. Note you can also implicitly abort a transition
    by initiating another transition while a previous one is underway.
       @method abort
    @return {Transition} this transition
    @public
   */
  abort() {
    this.rollback();
    let transition = new _Transition(this.router, void 0, void 0, void 0);
    transition.to = this.from;
    transition.from = this.from;
    transition.isAborted = true;
    this.router.routeWillChange(transition);
    this.router.routeDidChange(transition);
    return this;
  }
  rollback() {
    if (!this.isAborted) {
      log(this.router, this.sequence, this.targetName + ": transition was aborted");
      if (true) {
        let error = new Error(`Transition aborted stack`);
        this.debugAbortStack = () => error.stack;
      }
      if (this.intent !== void 0 && this.intent !== null) {
        this.intent.preTransitionState = this.router.state;
      }
      this.isAborted = true;
      this.isActive = false;
      this.router.activeTransition = void 0;
    }
  }
  redirect(newTransition) {
    this[REDIRECT_DESTINATION_SYMBOL] = newTransition;
    this.rollback();
    this.router.routeWillChange(newTransition);
  }
  /**
       Retries a previously-aborted transition (making sure to abort the
    transition if it's still active). Returns a new transition that
    represents the new attempt to transition.
       @method retry
    @return {Transition} new transition
    @public
   */
  retry() {
    this.abort();
    let newTransition = this.router.transitionByIntent(this.intent, false);
    if (this.urlMethod !== null) {
      newTransition.method(this.urlMethod);
    }
    return newTransition;
  }
  /**
       Sets the URL-changing method to be employed at the end of a
    successful transition. By default, a new Transition will just
    use `updateURL`, but passing 'replace' to this method will
    cause the URL to update using 'replaceWith' instead. Omitting
    a parameter will disable the URL change, allowing for transitions
    that don't update the URL at completion (this is also used for
    handleURL, since the URL has already changed before the
    transition took place).
       @method method
    @param {String} method the type of URL-changing method to use
      at the end of a transition. Accepted values are 'replace',
      falsy values, or any other non-falsy value (which is
      interpreted as an updateURL transition).
       @return {Transition} this transition
    @public
   */
  method(method) {
    this.urlMethod = method;
    return this;
  }
  // Alias 'trigger' as 'send'
  send(ignoreFailure = false, _name, err, transition, handler) {
    this.trigger(ignoreFailure, _name, err, transition, handler);
  }
  /**
       Fires an event on the current list of resolved/resolving
    handlers within this transition. Useful for firing events
    on route hierarchies that haven't fully been entered yet.
       Note: This method is also aliased as `send`
       @method trigger
    @param {Boolean} [ignoreFailure=false] a boolean specifying whether unhandled events throw an error
    @param {String} name the name of the event to fire
    @public
   */
  trigger(ignoreFailure = false, name, ...args) {
    if (typeof ignoreFailure === "string") {
      name = ignoreFailure;
      ignoreFailure = false;
    }
    this.router.triggerEvent(this[STATE_SYMBOL].routeInfos.slice(0, this.resolveIndex + 1), ignoreFailure, name, args);
  }
  /**
    Transitions are aborted and their promises rejected
    when redirects occur; this method returns a promise
    that will follow any redirects that occur and fulfill
    with the value fulfilled by any redirecting transitions
    that occur.
       @method followRedirects
    @return {Promise} a promise that fulfills with the same
      value that the final redirecting transition fulfills with
    @public
   */
  followRedirects() {
    return this.promise.catch((reason) => {
      if (this[REDIRECT_DESTINATION_SYMBOL]) {
        return this[REDIRECT_DESTINATION_SYMBOL].followRedirects();
      }
      return Promise$1.reject(reason);
    });
  }
  toString() {
    return "Transition (sequence " + this.sequence + ")";
  }
  /**
    @private
   */
  log(message) {
    log(this.router, this.sequence, message);
  }
};
function logAbort(transition) {
  log(transition.router, transition.sequence, "detected abort.");
  return buildTransitionAborted();
}
function isTransition(obj) {
  return typeof obj === "object" && obj instanceof Transition && obj.isTransition;
}
function prepareResult(obj) {
  if (isTransition(obj)) {
    return null;
  }
  return obj;
}
var UnrecognizedURLError = (function() {
  UnrecognizedURLError2.prototype = Object.create(Error.prototype);
  UnrecognizedURLError2.prototype.constructor = UnrecognizedURLError2;
  function UnrecognizedURLError2(message) {
    let error = Error.call(this, message);
    this.name = "UnrecognizedURLError";
    this.message = message || "UnrecognizedURL";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, UnrecognizedURLError2);
    } else {
      this.stack = error.stack;
    }
  }
  return UnrecognizedURLError2;
})();

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/utils.js
var ALL_PERIODS_REGEX = /\./g;
function extractRouteArgs(args) {
  args = args.slice();
  let possibleOptions = args[args.length - 1];
  let queryParams;
  if (isRouteOptions(possibleOptions)) {
    args.pop();
    queryParams = possibleOptions.queryParams;
  } else {
    queryParams = {};
  }
  let routeName;
  if (typeof args[0] === "string") {
    routeName = args.shift();
    !(typeof routeName === "string") && assert("routeName is a string", typeof routeName === "string");
  }
  let models = args;
  return {
    routeName,
    models,
    queryParams
  };
}
function getActiveTargetName(router) {
  let routeInfos = router.activeTransition ? router.activeTransition[STATE_SYMBOL].routeInfos : router.state.routeInfos;
  let lastRouteInfo = routeInfos[routeInfos.length - 1];
  !lastRouteInfo && assert("has last route info", lastRouteInfo);
  return lastRouteInfo.name;
}
function stashParamNames(router, routeInfos) {
  if (routeInfos["_namesStashed"]) {
    return;
  }
  let routeInfo = routeInfos[routeInfos.length - 1];
  !routeInfo && assert("has route info", routeInfo);
  let targetRouteName = routeInfo.name;
  let recogHandlers = router._routerMicrolib.recognizer.handlersFor(targetRouteName);
  let dynamicParent;
  for (let i = 0; i < routeInfos.length; ++i) {
    let routeInfo2 = routeInfos[i];
    !routeInfo2 && assert("has route info", routeInfo2);
    let names = recogHandlers[i].names;
    if (names.length) {
      dynamicParent = routeInfo2;
    }
    routeInfo2["_names"] = names;
    let route = routeInfo2.route;
    route._stashNames(routeInfo2, dynamicParent);
  }
  routeInfos["_namesStashed"] = true;
}
function _calculateCacheValuePrefix(prefix, part) {
  let prefixParts = prefix.split(".");
  let currPrefix = "";
  for (let i = 0; i < prefixParts.length; i++) {
    let currPart = prefixParts.slice(0, i + 1).join(".");
    if (part.indexOf(currPart) !== 0) {
      break;
    }
    currPrefix = currPart;
  }
  return currPrefix;
}
function calculateCacheKey(prefix, parts = [], values) {
  let suffixes = "";
  for (let part of parts) {
    let cacheValuePrefix = _calculateCacheValuePrefix(prefix, part);
    let value;
    if (values) {
      if (cacheValuePrefix && cacheValuePrefix in values) {
        let partRemovedPrefix = part.indexOf(cacheValuePrefix) === 0 ? part.substring(cacheValuePrefix.length + 1) : part;
        value = get(values[cacheValuePrefix], partRemovedPrefix);
      } else {
        value = get(values, part);
      }
    }
    suffixes += `::${part}:${value}`;
  }
  return prefix + suffixes.replace(ALL_PERIODS_REGEX, "-");
}
function normalizeControllerQueryParams(queryParams) {
  let qpMap = {};
  for (let queryParam of queryParams) {
    accumulateQueryParamDescriptors(queryParam, qpMap);
  }
  return qpMap;
}
function accumulateQueryParamDescriptors(_desc, accum) {
  let desc = typeof _desc === "string" ? {
    [_desc]: {
      as: null
    }
  } : _desc;
  for (let key in desc) {
    if (!Object.prototype.hasOwnProperty.call(desc, key)) {
      return;
    }
    let _singleDesc = desc[key];
    let singleDesc = typeof _singleDesc === "string" ? {
      as: _singleDesc
    } : _singleDesc;
    let partialVal = accum[key] || {
      as: null,
      scope: "model"
    };
    let val = {
      ...partialVal,
      ...singleDesc
    };
    accum[key] = val;
  }
}
function resemblesURL(str) {
  return typeof str === "string" && (str === "" || str[0] === "/");
}
function prefixRouteNameArg(route, args) {
  let routeName;
  let owner = getOwner2(route);
  !(owner instanceof EngineInstance) && assert("Expected route to have EngineInstance as owner", owner instanceof EngineInstance);
  let prefix = owner.mountPoint;
  if (owner.routable && typeof args[0] === "string") {
    routeName = args[0];
    if (resemblesURL(routeName)) {
      throw new Error("Programmatic transitions by URL cannot be used within an Engine. Please use the route name instead.");
    } else {
      routeName = `${prefix}.${routeName}`;
      args[0] = routeName;
    }
  }
  return args;
}
function shallowEqual(a, b) {
  let aCount = 0;
  let bCount = 0;
  for (let kA in a) {
    if (Object.prototype.hasOwnProperty.call(a, kA)) {
      if (a[kA] !== b[kA]) {
        return false;
      }
      aCount++;
    }
  }
  for (let kB in b) {
    if (Object.prototype.hasOwnProperty.call(b, kB)) {
      bCount++;
    }
  }
  return aCount === bCount;
}
function isRouteOptions(value) {
  if (value && typeof value === "object") {
    let qps = value.queryParams;
    if (qps && typeof qps === "object") {
      return Object.keys(qps).every((k) => typeof k === "string");
    }
  }
  return false;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/router_state.js
var RouterState = class {
  router;
  emberRouter;
  routerJsState;
  constructor(emberRouter, router, routerJsState) {
    this.emberRouter = emberRouter;
    this.router = router;
    this.routerJsState = routerJsState;
  }
  isActiveIntent(routeName, models, queryParams) {
    let state = this.routerJsState;
    if (!this.router.isActiveIntent(routeName, models, void 0, state)) {
      return false;
    }
    if (queryParams !== void 0 && Object.keys(queryParams).length > 0) {
      let visibleQueryParams = Object.assign({}, queryParams);
      this.emberRouter._prepareQueryParams(routeName, models, visibleQueryParams);
      return shallowEqual(visibleQueryParams, state.queryParams);
    }
    return true;
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/array-CVk-fNjW.js
function arrayContentWillChange(array, startIdx, removeAmt, addAmt) {
  if (startIdx === void 0) {
    startIdx = 0;
    removeAmt = addAmt = -1;
  } else {
    if (removeAmt === void 0) {
      removeAmt = -1;
    }
    if (addAmt === void 0) {
      addAmt = -1;
    }
  }
  sendEvent(array, "@array:before", [array, startIdx, removeAmt, addAmt]);
  return array;
}
function arrayContentDidChange(array, startIdx, removeAmt, addAmt, notify = true) {
  if (startIdx === void 0) {
    startIdx = 0;
    removeAmt = addAmt = -1;
  } else {
    if (removeAmt === void 0) {
      removeAmt = -1;
    }
    if (addAmt === void 0) {
      addAmt = -1;
    }
  }
  let meta3 = peekMeta(array);
  if (notify) {
    if (addAmt < 0 || removeAmt < 0 || addAmt - removeAmt !== 0) {
      notifyPropertyChange(array, "length", meta3);
    }
    notifyPropertyChange(array, "[]", meta3);
  }
  sendEvent(array, "@array:change", [array, startIdx, removeAmt, addAmt]);
  if (meta3 !== null) {
    let length = array.length;
    let addedAmount = addAmt === -1 ? 0 : addAmt;
    let removedAmount = removeAmt === -1 ? 0 : removeAmt;
    let delta = addedAmount - removedAmount;
    let previousLength = length - delta;
    let normalStartIdx = startIdx < 0 ? previousLength + startIdx : startIdx;
    if (meta3.revisionFor("firstObject") !== void 0 && normalStartIdx === 0) {
      notifyPropertyChange(array, "firstObject", meta3);
    }
    if (meta3.revisionFor("lastObject") !== void 0) {
      let previousLastIndex = previousLength - 1;
      let lastAffectedIndex = normalStartIdx + removedAmount;
      if (previousLastIndex < lastAffectedIndex) {
        notifyPropertyChange(array, "lastObject", meta3);
      }
    }
  }
  return array;
}
var EMPTY_ARRAY = Object.freeze([]);
function isMutableArray(obj) {
  return obj != null && typeof obj.replace === "function";
}
function replace(array, start, deleteCount, items = EMPTY_ARRAY) {
  if (isMutableArray(array)) {
    array.replace(start, deleteCount, items);
  } else {
    !Array.isArray(array) && assert("Can only replace content of a native array or MutableArray", Array.isArray(array));
    replaceInNativeArray(array, start, deleteCount, items);
  }
}
var CHUNK_SIZE = 6e4;
function replaceInNativeArray(array, start, deleteCount, items) {
  arrayContentWillChange(array, start, deleteCount, items.length);
  if (items.length <= CHUNK_SIZE) {
    array.splice(start, deleteCount, ...items);
  } else {
    array.splice(start, deleteCount);
    for (let i = 0; i < items.length; i += CHUNK_SIZE) {
      let chunk = items.slice(i, i + CHUNK_SIZE);
      array.splice(start + i, 0, ...chunk);
    }
  }
  arrayContentDidChange(array, start, deleteCount, items.length);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/utils/lib/type-of.js
var TYPE_MAP = {
  "[object Boolean]": "boolean",
  "[object Number]": "number",
  "[object String]": "string",
  "[object Function]": "function",
  "[object AsyncFunction]": "function",
  "[object Array]": "array",
  "[object Date]": "date",
  "[object RegExp]": "regexp",
  "[object Object]": "object",
  "[object FileList]": "filelist"
};
var {
  toString: toString2
} = Object.prototype;
function typeOf(item) {
  if (item === null) {
    return "null";
  }
  if (item === void 0) {
    return "undefined";
  }
  let ret = TYPE_MAP[toString2.call(item)] || "object";
  if (ret === "function") {
    if (CoreObject.detect(item)) {
      ret = "class";
    }
  } else if (ret === "object") {
    if (item instanceof Error) {
      ret = "error";
    } else if (item instanceof CoreObject) {
      ret = "instance";
    } else if (item instanceof Date) {
      ret = "date";
    }
  }
  return ret;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/utils/lib/compare.js
var TYPE_ORDER = {
  undefined: 0,
  null: 1,
  boolean: 2,
  number: 3,
  string: 4,
  array: 5,
  object: 6,
  instance: 7,
  function: 8,
  class: 9,
  date: 10,
  regexp: 11,
  filelist: 12,
  error: 13
};
function spaceship(a, b) {
  return Math.sign(a - b);
}
function compare(v, w) {
  if (v === w) {
    return 0;
  }
  let type1 = typeOf(v);
  let type2 = typeOf(w);
  if (type1 === "instance" && isComparable(v) && v.constructor.compare) {
    return v.constructor.compare(v, w);
  }
  if (type2 === "instance" && isComparable(w) && w.constructor.compare) {
    return w.constructor.compare(w, v) * -1;
  }
  let res = spaceship(TYPE_ORDER[type1], TYPE_ORDER[type2]);
  if (res !== 0) {
    return res;
  }
  switch (type1) {
    case "boolean":
      !(typeof v === "boolean" && typeof w === "boolean") && assert("both are boolean", typeof v === "boolean" && typeof w === "boolean");
      return spaceship(Number(v), Number(w));
    case "number":
      !(typeof v === "number" && typeof w === "number") && assert("both are numbers", typeof v === "number" && typeof w === "number");
      return spaceship(v, w);
    case "string":
      !(typeof v === "string" && typeof w === "string") && assert("both are strings", typeof v === "string" && typeof w === "string");
      return spaceship(v.localeCompare(w), 0);
    case "array": {
      !(Array.isArray(v) && Array.isArray(w)) && assert("both are arrays", Array.isArray(v) && Array.isArray(w));
      let vLen = v.length;
      let wLen = w.length;
      let len2 = Math.min(vLen, wLen);
      for (let i = 0; i < len2; i++) {
        let r = compare(v[i], w[i]);
        if (r !== 0) {
          return r;
        }
      }
      return spaceship(vLen, wLen);
    }
    case "instance":
      if (isComparable(v) && v.compare) {
        return v.compare(v, w);
      }
      return 0;
    case "date":
      !(v instanceof Date && w instanceof Date) && assert("both are dates", v instanceof Date && w instanceof Date);
      return spaceship(v.getTime(), w.getTime());
    default:
      return 0;
  }
}
function isComparable(value) {
  return Comparable.detect(value);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/array/index.js
var EMPTY_ARRAY2 = Object.freeze([]);
var identityFunction = (item) => item;
function uniqBy(array, keyOrFunc = identityFunction) {
  !isArray6(array) && assert(`first argument passed to \`uniqBy\` should be array`, isArray6(array));
  let ret = A();
  let seen = /* @__PURE__ */ new Set();
  let getter = typeof keyOrFunc === "function" ? keyOrFunc : (item) => get(item, keyOrFunc);
  array.forEach((item) => {
    let val = getter(item);
    if (!seen.has(val)) {
      seen.add(val);
      ret.push(item);
    }
  });
  return ret;
}
function iter(...args) {
  let valueProvided = args.length === 2;
  let [key, value] = args;
  return valueProvided ? (item) => value === get(item, key) : (item) => Boolean(get(item, key));
}
function findIndex(array, predicate, startAt) {
  let len2 = array.length;
  for (let index = startAt; index < len2; index++) {
    let item = objectAt(array, index);
    if (predicate(item, index, array)) {
      return index;
    }
  }
  return -1;
}
function find(array, callback, target = null) {
  let predicate = callback.bind(target);
  let index = findIndex(array, predicate, 0);
  return index === -1 ? void 0 : objectAt(array, index);
}
function any(array, callback, target = null) {
  let predicate = callback.bind(target);
  return findIndex(array, predicate, 0) !== -1;
}
function every(array, callback, target = null) {
  let cb = callback.bind(target);
  let predicate = (item, index, array2) => !cb(item, index, array2);
  return findIndex(array, predicate, 0) === -1;
}
function indexOf(array, val, startAt = 0, withNaNCheck) {
  let len2 = array.length;
  if (startAt < 0) {
    startAt += len2;
  }
  let predicate = withNaNCheck && val !== val ? (item) => item !== item : (item) => item === val;
  return findIndex(array, predicate, startAt);
}
function removeAt(array, index, len2) {
  !(index > -1 && index < array.length) && assert(`\`removeAt\` index provided is out of range`, index > -1 && index < array.length);
  replace(array, index, len2 ?? 1, EMPTY_ARRAY2);
  return array;
}
function insertAt(array, index, item) {
  !(index > -1 && index <= array.length) && assert(`\`insertAt\` index provided is out of range`, index > -1 && index <= array.length);
  replace(array, index, 0, [item]);
  return item;
}
function isArray6(obj) {
  if (typeof obj === "object" && obj !== null) {
    let possibleProxyContent = obj[PROXY_CONTENT];
    if (possibleProxyContent !== void 0) {
      obj = possibleProxyContent;
    }
  }
  if (!obj || obj.setInterval) {
    return false;
  }
  if (Array.isArray(obj) || EmberArray.detect(obj)) {
    return true;
  }
  let type = typeOf(obj);
  if ("array" === type) {
    return true;
  }
  let length = obj.length;
  if (typeof length === "number" && length === length && "object" === type) {
    return true;
  }
  return false;
}
function nonEnumerableComputed(callback) {
  let property = computed(callback);
  property.enumerable = false;
  return property;
}
function mapBy(key) {
  return this.map((next) => get(next, key));
}
var EmberArray = Mixin.create(Enumerable, {
  init() {
    this._super(...arguments);
    setEmberArray(this);
  },
  objectsAt(indexes) {
    return indexes.map((idx) => objectAt(this, idx));
  },
  "[]": nonEnumerableComputed({
    get() {
      return this;
    },
    set(_key, value) {
      this.replace(0, this.length, value);
      return this;
    }
  }),
  firstObject: nonEnumerableComputed(function() {
    return objectAt(this, 0);
  }).readOnly(),
  lastObject: nonEnumerableComputed(function() {
    return objectAt(this, this.length - 1);
  }).readOnly(),
  // Add any extra methods to EmberArray that are native to the built-in Array.
  slice(beginIndex = 0, endIndex) {
    let ret = A();
    let length = this.length;
    if (beginIndex < 0) {
      beginIndex = length + beginIndex;
    }
    let validatedEndIndex;
    if (endIndex === void 0 || endIndex > length) {
      validatedEndIndex = length;
    } else if (endIndex < 0) {
      validatedEndIndex = length + endIndex;
    } else {
      validatedEndIndex = endIndex;
    }
    while (beginIndex < validatedEndIndex) {
      ret[ret.length] = objectAt(this, beginIndex++);
    }
    return ret;
  },
  indexOf(object, startAt) {
    return indexOf(this, object, startAt, false);
  },
  lastIndexOf(object, startAt) {
    let len2 = this.length;
    if (startAt === void 0 || startAt >= len2) {
      startAt = len2 - 1;
    }
    if (startAt < 0) {
      startAt += len2;
    }
    for (let idx = startAt; idx >= 0; idx--) {
      if (objectAt(this, idx) === object) {
        return idx;
      }
    }
    return -1;
  },
  forEach(callback, target = null) {
    !(typeof callback === "function") && assert("`forEach` expects a function as first argument.", typeof callback === "function");
    let length = this.length;
    for (let index = 0; index < length; index++) {
      let item = this.objectAt(index);
      callback.call(target, item, index, this);
    }
    return this;
  },
  getEach: mapBy,
  setEach(key, value) {
    return this.forEach((item) => set(item, key, value));
  },
  map(callback, target = null) {
    !(typeof callback === "function") && assert("`map` expects a function as first argument.", typeof callback === "function");
    let ret = A();
    this.forEach((x, idx, i) => ret[idx] = callback.call(target, x, idx, i));
    return ret;
  },
  mapBy,
  filter(callback, target = null) {
    !(typeof callback === "function") && assert("`filter` expects a function as first argument.", typeof callback === "function");
    let ret = A();
    this.forEach((x, idx, i) => {
      if (callback.call(target, x, idx, i)) {
        ret.push(x);
      }
    });
    return ret;
  },
  reject(callback, target = null) {
    !(typeof callback === "function") && assert("`reject` expects a function as first argument.", typeof callback === "function");
    return this.filter(function() {
      return !callback.apply(target, arguments);
    });
  },
  filterBy() {
    return this.filter(iter(...arguments));
  },
  rejectBy() {
    return this.reject(iter(...arguments));
  },
  find(callback, target = null) {
    !(typeof callback === "function") && assert("`find` expects a function as first argument.", typeof callback === "function");
    return find(this, callback, target);
  },
  findBy() {
    let callback = iter(...arguments);
    return find(this, callback);
  },
  every(callback, target = null) {
    !(typeof callback === "function") && assert("`every` expects a function as first argument.", typeof callback === "function");
    return every(this, callback, target);
  },
  isEvery() {
    let callback = iter(...arguments);
    return every(this, callback);
  },
  any(callback, target = null) {
    !(typeof callback === "function") && assert("`any` expects a function as first argument.", typeof callback === "function");
    return any(this, callback, target);
  },
  isAny() {
    let callback = iter(...arguments);
    return any(this, callback);
  },
  // FIXME: When called without initialValue, behavior does not match native behavior
  reduce(callback, initialValue) {
    !(typeof callback === "function") && assert("`reduce` expects a function as first argument.", typeof callback === "function");
    let ret = initialValue;
    this.forEach(function(item, i) {
      ret = callback(ret, item, i, this);
    }, this);
    return ret;
  },
  invoke(methodName, ...args) {
    let ret = A();
    this.forEach((item) => ret.push(item[methodName]?.(...args)));
    return ret;
  },
  toArray() {
    return this.map((item) => item);
  },
  compact() {
    return this.filter((value) => value != null);
  },
  includes(object, startAt) {
    return indexOf(this, object, startAt, true) !== -1;
  },
  sortBy() {
    let sortKeys = arguments;
    return this.toArray().sort((a, b) => {
      for (let i = 0; i < sortKeys.length; i++) {
        let key = sortKeys[i];
        let propA = get(a, key);
        let propB = get(b, key);
        let compareValue = compare(propA, propB);
        if (compareValue) {
          return compareValue;
        }
      }
      return 0;
    });
  },
  uniq() {
    return uniqBy(this);
  },
  uniqBy(key) {
    return uniqBy(this, key);
  },
  without(value) {
    if (!this.includes(value)) {
      return this;
    }
    let predicate = value === value ? (item) => item !== value : (item) => item === item;
    return this.filter(predicate);
  }
});
var MutableArray = Mixin.create(EmberArray, MutableEnumerable, {
  clear() {
    let len2 = this.length;
    if (len2 === 0) {
      return this;
    }
    this.replace(0, len2, EMPTY_ARRAY2);
    return this;
  },
  insertAt(idx, object) {
    insertAt(this, idx, object);
    return this;
  },
  removeAt(start, len2) {
    return removeAt(this, start, len2);
  },
  pushObject(obj) {
    return insertAt(this, this.length, obj);
  },
  pushObjects(objects) {
    this.replace(this.length, 0, objects);
    return this;
  },
  popObject() {
    let len2 = this.length;
    if (len2 === 0) {
      return null;
    }
    let ret = objectAt(this, len2 - 1);
    this.removeAt(len2 - 1, 1);
    return ret;
  },
  shiftObject() {
    if (this.length === 0) {
      return null;
    }
    let ret = objectAt(this, 0);
    this.removeAt(0);
    return ret;
  },
  unshiftObject(obj) {
    return insertAt(this, 0, obj);
  },
  unshiftObjects(objects) {
    this.replace(0, 0, objects);
    return this;
  },
  reverseObjects() {
    let len2 = this.length;
    if (len2 === 0) {
      return this;
    }
    let objects = this.toArray().reverse();
    this.replace(0, len2, objects);
    return this;
  },
  setObjects(objects) {
    if (objects.length === 0) {
      return this.clear();
    }
    let len2 = this.length;
    this.replace(0, len2, objects);
    return this;
  },
  removeObject(obj) {
    let loc = this.length || 0;
    while (--loc >= 0) {
      let curObject = objectAt(this, loc);
      if (curObject === obj) {
        this.removeAt(loc);
      }
    }
    return this;
  },
  removeObjects(objects) {
    beginPropertyChanges();
    for (let i = objects.length - 1; i >= 0; i--) {
      this.removeObject(objects[i]);
    }
    endPropertyChanges();
    return this;
  },
  addObject(obj) {
    let included = this.includes(obj);
    if (!included) {
      this.pushObject(obj);
    }
    return this;
  },
  addObjects(objects) {
    beginPropertyChanges();
    objects.forEach((obj) => this.addObject(obj));
    endPropertyChanges();
    return this;
  }
});
var NativeArray = Mixin.create(MutableArray, Observable, {
  objectAt(idx) {
    return this[idx];
  },
  // primitive for array support.
  replace(start, deleteCount, items = EMPTY_ARRAY2) {
    !Array.isArray(items) && assert("The third argument to replace needs to be an array.", Array.isArray(items));
    replaceInNativeArray(this, start, deleteCount, items);
    return this;
  }
});
var ignore = ["length"];
NativeArray.keys().forEach((methodName) => {
  if (Array.prototype[methodName]) {
    ignore.push(methodName);
  }
});
NativeArray = NativeArray.without(...ignore);
var A;
A = function(arr) {
  !!(this instanceof A) && assert("You cannot create an Ember Array with `new A()`, please update to calling A as a function: `A()`", !(this instanceof A));
  if (isEmberArray(arr)) {
    return arr;
  } else {
    return NativeArray.apply(arr ?? []);
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/evented.js
var Evented = Mixin.create({
  on(name, target, method) {
    addListener(this, name, target, method);
    return this;
  },
  one(name, target, method) {
    addListener(this, name, target, method, true);
    return this;
  },
  trigger(name, ...args) {
    sendEvent(this, name, args);
  },
  off(name, target, method) {
    removeListener(this, name, target, method);
    return this;
  },
  has(name) {
    return hasListeners(this, name);
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/-internals.js
var FrameworkObject = class FrameworkObject2 extends EmberObject {
};
if (true) {
  const INIT_WAS_CALLED = Symbol("INIT_WAS_CALLED");
  let ASSERT_INIT_WAS_CALLED = symbol("ASSERT_INIT_WAS_CALLED");
  FrameworkObject = class DebugFrameworkObject extends EmberObject {
    [INIT_WAS_CALLED] = false;
    init(properties) {
      super.init(properties);
      this[INIT_WAS_CALLED] = true;
    }
    [ASSERT_INIT_WAS_CALLED]() {
      !this[INIT_WAS_CALLED] && assert(`You must call \`super.init(...arguments);\` or \`this._super(...arguments)\` when overriding \`init\` on a framework object. Please update ${this} to call \`super.init(...arguments);\` from \`init\` when using native classes or \`this._super(...arguments)\` when using \`EmberObject.extend()\`.`, this[INIT_WAS_CALLED]);
    }
  };
  addListener(FrameworkObject.prototype, "init", null, ASSERT_INIT_WAS_CALLED);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/controller/index.js
var MODEL = symbol("MODEL");
var ControllerMixin = Mixin.create(ActionHandler, {
  /* ducktype as a controller */
  isController: true,
  concatenatedProperties: ["queryParams"],
  target: null,
  store: null,
  init() {
    this._super(...arguments);
    let owner = getOwner2(this);
    if (owner) {
      this.namespace = owner.lookup("application:main");
      this.target = owner.lookup("router:main");
    }
  },
  model: computed({
    get() {
      return this[MODEL];
    },
    set(_key, value) {
      return this[MODEL] = value;
    }
  }),
  queryParams: null,
  /**
   This property is updated to various different callback functions depending on
   the current "state" of the backing route. It is used by
   `Controller.prototype._qpChanged`.
    The methods backing each state can be found in the `Route.prototype._qp` computed
   property return value (the `.states` property). The current values are listed here for
   the sanity of future travelers:
    * `inactive` - This state is used when this controller instance is not part of the active
     route hierarchy. Set in `Route.prototype._reset` (a `router.js` microlib hook) and
     `Route.prototype.actions.finalizeQueryParamChange`.
   * `active` - This state is used when this controller instance is part of the active
     route hierarchy. Set in `Route.prototype.actions.finalizeQueryParamChange`.
   * `allowOverrides` - This state is used in `Route.prototype.setup` (`route.js` microlib hook).
     @method _qpDelegate
    @private
  */
  _qpDelegate: null,
  // set by route
  /**
   During `Route#setup` observers are created to invoke this method
   when any of the query params declared in `Controller#queryParams` property
   are changed.
    When invoked this method uses the currently active query param update delegate
   (see `Controller.prototype._qpDelegate` for details) and invokes it with
   the QP key/value being changed.
     @method _qpChanged
    @private
  */
  _qpChanged(controller, _prop) {
    let dotIndex = _prop.indexOf(".[]");
    let prop = dotIndex === -1 ? _prop : _prop.slice(0, dotIndex);
    let delegate = controller._qpDelegate;
    let value = get(controller, prop);
    delegate(prop, value);
  }
});
var Controller = class extends FrameworkObject.extend(ControllerMixin) {
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/compat.js
var wrapGetterSetter = function(target, key, desc) {
  let {
    get: originalGet
  } = desc;
  !(descriptorForProperty(target, key) === void 0) && assert("You attempted to use @dependentKeyCompat on a property that already has been decorated with either @computed or @tracked. @dependentKeyCompat is only necessary for native getters that are not decorated with @computed.", descriptorForProperty(target, key) === void 0);
  if (originalGet !== void 0) {
    desc.get = function() {
      let propertyTag = tagFor(this, key);
      let ret;
      let tag = track(() => {
        ret = originalGet.call(this);
      });
      UPDATE_TAG(propertyTag, tag);
      consumeTag(tag);
      return ret;
    };
  }
  return desc;
};
function dependentKeyCompat(...args) {
  if (isElementDescriptor(args)) {
    let [target, key, desc] = args;
    !(desc != null && (typeof desc.get === "function" || typeof desc.set === "function")) && assert("The @dependentKeyCompat decorator must be applied to getters/setters when used in native classes", desc != null && (typeof desc.get === "function" || typeof desc.set === "function"));
    return wrapGetterSetter(target, key, desc);
  } else {
    const desc = args[0];
    !((value) => {
      if (value && typeof value === "object") {
        let cast2 = value;
        return (cast2.configurable === void 0 || cast2.configurable === false || cast2.configurable === true) && (cast2.enumerable === void 0 || cast2.enumerable === false || cast2.enumerable === true) && (cast2.writable === void 0 || cast2.writable === false || cast2.writable === true) && (cast2.get === void 0 || typeof cast2.get === "function") && (cast2.set === void 0 || typeof cast2.set === "function");
      }
      return false;
    })(desc) && assert("expected valid PropertyDescriptor", ((value) => {
      if (value && typeof value === "object") {
        let cast2 = value;
        return (cast2.configurable === void 0 || cast2.configurable === false || cast2.configurable === true) && (cast2.enumerable === void 0 || cast2.enumerable === false || cast2.enumerable === true) && (cast2.writable === void 0 || cast2.writable === false || cast2.writable === true) && (cast2.get === void 0 || typeof cast2.get === "function") && (cast2.set === void 0 || typeof cast2.set === "function");
      }
      return false;
    })(desc));
    let decorator = function(target, key, _desc, _meta, isClassicDecorator2) {
      !isClassicDecorator2 && assert("The @dependentKeyCompat decorator may only be passed a method when used in classic classes. You should decorate getters/setters directly in native classes", isClassicDecorator2);
      !(typeof desc.get === "function" || typeof desc.set === "function") && assert("The dependentKeyCompat() decorator must be passed a getter or setter when used in classic classes", typeof desc.get === "function" || typeof desc.set === "function");
      return wrapGetterSetter(target, key, desc);
    };
    setClassicDecorator(decorator);
    return decorator;
  }
}
setClassicDecorator(dependentKeyCompat);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/generate_controller.js
function generateControllerFactory(owner, controllerName) {
  let factoryManager = owner.factoryFor("controller:basic");
  !(factoryManager !== void 0) && assert("[BUG] unexpectedly missing a factoryManager for `controller:basic`", factoryManager !== void 0);
  let Factory = factoryManager.class;
  Factory = class extends Factory {
    toString() {
      return `(generated ${controllerName} controller)`;
    }
  };
  let fullName = `controller:${controllerName}`;
  owner.register(fullName, Factory);
  return owner.factoryFor(fullName);
}
function generateController(owner, controllerName) {
  generateControllerFactory(owner, controllerName);
  let fullName = `controller:${controllerName}`;
  let instance = owner.lookup(fullName);
  !(instance instanceof Controller) && assert("Expected an instance of controller", instance instanceof Controller);
  if (true) {
    if (get(instance, "namespace.LOG_ACTIVE_GENERATION")) {
      info(`generated -> ${fullName}`, {
        fullName
      });
    }
  }
  return instance;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/chunk-3SQBS3Y5-Cj4eryg1.js
var __defProp = Object.defineProperty;
var __export = (target, all2) => {
  for (var name in all2) __defProp(target, name, {
    get: all2[name],
    enumerable: true
  });
};
var runtime_exports = {};
__export(runtime_exports, {
  c: () => decorateClass,
  f: () => decorateFieldV1,
  g: () => decorateFieldV2,
  i: () => initializeDeferredDecorator,
  m: () => decorateMethodV1,
  n: () => decorateMethodV2,
  p: () => decoratePOJO
});
var deferred2 = /* @__PURE__ */ new WeakMap();
function deferDecorator(proto, prop, desc) {
  let map3 = deferred2.get(proto);
  if (!map3) {
    map3 = /* @__PURE__ */ new Map();
    deferred2.set(proto, map3);
  }
  map3.set(prop, desc);
}
function findDeferredDecorator(target, prop) {
  let cursor = target.prototype;
  while (cursor) {
    let desc = deferred2.get(cursor)?.get(prop);
    if (desc) {
      return desc;
    }
    cursor = cursor.prototype;
  }
}
function decorateFieldV1(target, prop, decorators, initializer) {
  return decorateFieldV2(target.prototype, prop, decorators, initializer);
}
function decorateFieldV2(prototype, prop, decorators, initializer) {
  let desc = {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: null
  };
  if (initializer) {
    desc.initializer = initializer;
  }
  for (let decorator of decorators) {
    desc = decorator(prototype, prop, desc) || desc;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(prototype, prop, desc);
  } else {
    deferDecorator(prototype, prop, desc);
  }
}
function decorateMethodV1({
  prototype
}, prop, decorators) {
  return decorateMethodV2(prototype, prop, decorators);
}
function decorateMethodV2(prototype, prop, decorators) {
  const origDesc = Object.getOwnPropertyDescriptor(prototype, prop);
  let desc = {
    ...origDesc
  };
  for (let decorator of decorators) {
    desc = decorator(prototype, prop, desc) || desc;
  }
  if (desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(prototype) : void 0;
    desc.initializer = void 0;
  }
  Object.defineProperty(prototype, prop, desc);
}
function initializeDeferredDecorator(target, prop) {
  let desc = findDeferredDecorator(target.constructor, prop);
  if (desc) {
    Object.defineProperty(target, prop, {
      enumerable: desc.enumerable,
      configurable: desc.configurable,
      writable: desc.writable,
      value: desc.initializer ? desc.initializer.call(target) : void 0
    });
  }
}
function decorateClass(target, decorators) {
  return decorators.reduce((accum, decorator) => decorator(accum) || accum, target);
}
function decoratePOJO(pojo, decorated) {
  for (let [type, prop, decorators] of decorated) {
    if (type === "field") {
      decoratePojoField(pojo, prop, decorators);
    } else {
      decorateMethodV2(pojo, prop, decorators);
    }
  }
  return pojo;
}
function decoratePojoField(pojo, prop, decorators) {
  let desc = {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: () => Object.getOwnPropertyDescriptor(pojo, prop)?.value
  };
  for (let decorator of decorators) {
    desc = decorator(pojo, prop, desc) || desc;
  }
  if (desc.initializer) {
    desc.value = desc.initializer.call(pojo);
    delete desc.initializer;
  }
  Object.defineProperty(pojo, prop, desc);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/route.js
var RENDER = Symbol("render");
var RENDER_STATE = Symbol("render-state");
var _Route = class _Route extends EmberObject.extend(ActionHandler, Evented) {
  // These properties will end up appearing in the public interface because we
  // `implements IRoute` from `router.js`, which has them as part of *its*
  // public contract. We mark them as `@internal` so they at least signal to
  // people subclassing `Route` that they should not use them.
  /** @internal */
  context = {};
  /** @internal */
  /** @internal */
  _bucketCache;
  /** @internal */
  _internalName;
  _names;
  _router;
  constructor(owner) {
    super(owner);
    if (owner) {
      let router = owner.lookup("router:main");
      let bucketCache = owner.lookup(privatize`-bucket-cache:main`);
      this._router = router;
      this._bucketCache = bucketCache;
      this._topLevelViewTemplate = owner.lookup("template:-outlet");
      this._environment = owner.lookup("-environment:main");
    }
  }
  /**
    A hook you can implement to convert the route's model into parameters
    for the URL.
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     ```
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      model({ post_id }) {
        // the server returns `{ id: 12 }`
        return fetch(`/posts/${post_id}`;
      }
       serialize(model) {
        // this will make the URL `/posts/12`
        return { post_id: model.id };
      }
    }
    ```
     The default `serialize` method will insert the model's `id` into the
    route's dynamic segment (in this case, `:post_id`) if the segment contains '_id'.
    If the route has multiple dynamic segments or does not contain '_id', `serialize`
    will return `getProperties(model, params)`
     This method is called when `transitionTo` is called with a context
    in order to populate the URL.
     @method serialize
    @param {Object} model the routes model
    @param {Array} params an Array of parameter names for the current
      route (in the example, `['post_id']`.
    @return {Object} the serialized parameters
    @since 1.0.0
    @public
  */
  serialize(model, params) {
    if (params.length < 1 || !model) {
      return;
    }
    let object = {};
    if (params.length === 1) {
      let [name] = params;
      !name && assert("has name", name);
      if (typeof model === "object" && name in model) {
        object[name] = get(model, name);
      } else if (/_id$/.test(name)) {
        object[name] = get(model, "id");
      } else if (isProxy(model)) {
        object[name] = get(model, name);
      }
    } else {
      object = getProperties(model, params);
    }
    return object;
  }
  /**
    Configuration hash for this route's queryParams. The possible
    configuration options and their defaults are as follows
    (assuming a query param whose controller property is `page`):
     ```javascript
    queryParams = {
      page: {
        // By default, controller query param properties don't
        // cause a full transition when they are changed, but
        // rather only cause the URL to update. Setting
        // `refreshModel` to true will cause an "in-place"
        // transition to occur, whereby the model hooks for
        // this route (and any child routes) will re-fire, allowing
        // you to reload models (e.g., from the server) using the
        // updated query param values.
        refreshModel: false,
         // By default, changes to controller query param properties
        // cause the URL to update via `pushState`, which means an
        // item will be added to the browser's history, allowing
        // you to use the back button to restore the app to the
        // previous state before the query param property was changed.
        // Setting `replace` to true will use `replaceState` (or its
        // hash location equivalent), which causes no browser history
        // item to be added. This options name and default value are
        // the same as the `link-to` helper's `replace` option.
        replace: false,
         // By default, the query param URL key is the same name as
        // the controller property name. Use `as` to specify a
        // different URL key.
        as: 'page'
      }
    };
    ```
     @property queryParams
    @for Route
    @type Object
    @since 1.6.0
    @public
  */
  // Set in reopen so it can be overriden with extend
  /**
    The name of the template to use by default when rendering this route's
    template.
     ```app/routes/posts/list.js
    import Route from '@ember/routing/route';
     export default class PostsListRoute extends Route {
      templateName = 'posts/list';
    }
    ```
     ```app/routes/posts/index.js
    import PostsListRoute from '../posts/list';
     export default class PostsIndexRoute extends PostsListRoute {};
    ```
     ```app/routes/posts/archived.js
    import PostsListRoute from '../posts/list';
     export default class PostsArchivedRoute extends PostsListRoute {};
    ```
     @property templateName
    @type String
    @default null
    @since 1.4.0
    @public
  */
  // Set in reopen so it can be overriden with extend
  /**
    The name of the controller to associate with this route.
     By default, Ember will lookup a route's controller that matches the name
    of the route (i.e. `posts.new`). However,
    if you would like to define a specific controller to use, you can do so
    using this property.
     This is useful in many ways, as the controller specified will be:
     * passed to the `setupController` method.
    * used as the controller for the template being rendered by the route.
    * returned from a call to `controllerFor` for the route.
     @property controllerName
    @type String
    @default null
    @since 1.4.0
    @public
  */
  // Set in reopen so it can be overriden with extend
  /**
    The controller associated with this route.
     Example
     ```app/routes/form.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class FormRoute extends Route {
      @action
      willTransition(transition) {
        if (this.controller.get('userHasEnteredData') &&
            !confirm('Are you sure you want to abandon progress?')) {
          transition.abort();
        } else {
          // Bubble the `willTransition` action so that
          // parent routes can decide whether or not to abort.
          return true;
        }
      }
    }
    ```
     @property controller
    @type Controller
    @since 1.6.0
    @public
  */
  /**
    The name of the route, dot-delimited.
     For example, a route found at `app/routes/posts/post.js` will have
    a `routeName` of `posts.post`.
     @property routeName
    @for Route
    @type String
    @since 1.0.0
    @public
  */
  /**
    The name of the route, dot-delimited, including the engine prefix
    if applicable.
     For example, a route found at `addon/routes/posts/post.js` within an
    engine named `admin` will have a `fullRouteName` of `admin.posts.post`.
     @property fullRouteName
    @for Route
    @type String
    @since 2.10.0
    @public
  */
  /**
    Sets the name for this route, including a fully resolved name for routes
    inside engines.
     @private
    @method _setRouteName
    @param {String} name
  */
  _setRouteName(name) {
    this.routeName = name;
    let owner = getOwner2(this);
    !(owner instanceof EngineInstance) && assert("Expected route to have EngineInstance as owner", owner instanceof EngineInstance);
    this.fullRouteName = getEngineRouteName(owner, name);
  }
  /**
    @private
     @method _stashNames
  */
  _stashNames(routeInfo, dynamicParent) {
    if (this._names) {
      return;
    }
    let names = this._names = routeInfo["_names"];
    if (!names.length) {
      routeInfo = dynamicParent;
      names = routeInfo && routeInfo["_names"] || [];
    }
    let qps = get(this, "_qp").qps;
    let namePaths = new Array(names.length);
    for (let a = 0; a < names.length; ++a) {
      namePaths[a] = `${routeInfo.name}.${names[a]}`;
    }
    for (let qp of qps) {
      if (qp.scope === "model") {
        qp.parts = namePaths;
      }
    }
  }
  /**
    @private
     @property _activeQPChanged
  */
  _activeQPChanged(qp, value) {
    this._router._activeQPChanged(qp.scopedPropertyName, value);
  }
  /**
    @private
    @method _updatingQPChanged
  */
  _updatingQPChanged(qp) {
    this._router._updatingQPChanged(qp.urlKey);
  }
  /**
    Returns a hash containing the parameters of an ancestor route.
     You may notice that `this.paramsFor` sometimes works when referring to a
    child route, but this behavior should not be relied upon as only ancestor
    routes are certain to be loaded in time.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('member', { path: ':name' }, function() {
        this.route('interest', { path: ':interest' });
      });
    });
    ```
     ```app/routes/member.js
    import Route from '@ember/routing/route';
     export default class MemberRoute extends Route {
      queryParams = {
        memberQp: { refreshModel: true }
      }
    }
    ```
     ```app/routes/member/interest.js
    import Route from '@ember/routing/route';
     export default class MemberInterestRoute extends Route {
      queryParams = {
        interestQp: { refreshModel: true }
      }
       model() {
        return this.paramsFor('member');
      }
    }
    ```
     If we visit `/turing/maths?memberQp=member&interestQp=interest` the model for
    the `member.interest` route is a hash with:
     * `name`: `turing`
    * `memberQp`: `member`
     @method paramsFor
    @param {String} name
    @return {Object} hash containing the parameters of the route `name`
    @since 1.4.0
    @public
  */
  paramsFor(name) {
    let owner = getOwner2(this);
    !owner && assert("Route is unexpectedly missing an owner", owner);
    let route = owner.lookup(`route:${name}`);
    if (route === void 0) {
      return {};
    }
    let transition = this._router._routerMicrolib.activeTransition;
    let state = transition ? transition[STATE_SYMBOL] : this._router._routerMicrolib.state;
    let fullName = route.fullRouteName;
    let params = {
      ...state.params[fullName]
    };
    let queryParams = getQueryParamsFor(route, state);
    return Object.entries(queryParams).reduce((params2, [key, value]) => {
      !!params2[key] && assert(`The route '${this.routeName}' has both a dynamic segment and query param with name '${key}'. Please rename one to avoid collisions.`, !params2[key]);
      params2[key] = value;
      return params2;
    }, params);
  }
  /**
    Serializes the query parameter key
     @method serializeQueryParamKey
    @param {String} controllerPropertyName
    @private
  */
  serializeQueryParamKey(controllerPropertyName) {
    return controllerPropertyName;
  }
  /**
    Serializes value of the query parameter based on defaultValueType
     @method serializeQueryParam
    @param {Object} value
    @param {String} urlKey
    @param {String} defaultValueType
    @private
  */
  serializeQueryParam(value, _urlKey, defaultValueType) {
    return this._router._serializeQueryParam(value, defaultValueType);
  }
  /**
    Deserializes value of the query parameter based on defaultValueType
     @method deserializeQueryParam
    @param {Object} value
    @param {String} urlKey
    @param {String} defaultValueType
    @private
  */
  deserializeQueryParam(value, _urlKey, defaultValueType) {
    return this._router._deserializeQueryParam(value, defaultValueType);
  }
  /**
    @private
     @property _optionsForQueryParam
  */
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  _optionsForQueryParam(qp) {
    const queryParams = get(this, "queryParams");
    return get(queryParams, qp.urlKey) || get(queryParams, qp.prop) || queryParams[qp.urlKey] || queryParams[qp.prop] || {};
  }
  /**
    A hook you can use to reset controller values either when the model
    changes or the route is exiting.
     ```app/routes/articles.js
    import Route from '@ember/routing/route';
     export default class ArticlesRoute extends Route {
      resetController(controller, isExiting, transition) {
        if (isExiting && transition.targetName !== 'error') {
          controller.set('page', 1);
        }
      }
    }
    ```
     @method resetController
    @param {Controller} controller instance
    @param {Boolean} isExiting
    @param {Object} transition
    @since 1.7.0
    @public
  */
  resetController(_controller, _isExiting, _transition) {
    return this;
  }
  /**
    @private
     @method exit
  */
  exit(transition) {
    this.deactivate(transition);
    this.trigger("deactivate", transition);
    this.teardownViews();
  }
  /**
    @private
     @method _internalReset
    @since 3.6.0
  */
  _internalReset(isExiting, transition) {
    let controller = this.controller;
    controller["_qpDelegate"] = get(this, "_qp").states.inactive;
    this.resetController(controller, isExiting, transition);
  }
  /**
    @private
     @method enter
  */
  enter(transition) {
    this[RENDER_STATE] = void 0;
    this.activate(transition);
    this.trigger("activate", transition);
  }
  /**
    This event is triggered when the router enters the route. It is
    not executed when the model for the route changes.
     ```app/routes/application.js
    import { on } from '@ember/object/evented';
    import Route from '@ember/routing/route';
     export default Route.extend({
      collectAnalytics: on('activate', function(){
        collectAnalytics();
      })
    });
    ```
     @event activate
    @since 1.9.0
    @public
  */
  /**
    This event is triggered when the router completely exits this
    route. It is not executed when the model for the route changes.
     ```app/routes/index.js
    import { on } from '@ember/object/evented';
    import Route from '@ember/routing/route';
     export default Route.extend({
      trackPageLeaveAnalytics: on('deactivate', function(){
        trackPageLeaveAnalytics();
      })
    });
    ```
     @event deactivate
    @since 1.9.0
    @public
  */
  /**
    This hook is executed when the router completely exits this route. It is
    not executed when the model for the route changes.
     @method deactivate
    @param {Transition} transition
    @since 1.0.0
    @public
  */
  deactivate(_transition) {
  }
  /**
    This hook is executed when the router enters the route. It is not executed
    when the model for the route changes.
     @method activate
    @param {Transition} transition
    @since 1.0.0
    @public
  */
  activate(_transition) {
  }
  /**
    Perform a synchronous transition into another route without attempting
    to resolve promises, update the URL, or abort any currently active
    asynchronous transitions (i.e. regular transitions caused by
    `transitionTo` or URL changes).
     This method is handy for performing intermediate transitions on the
    way to a final destination route, and is called internally by the
    default implementations of the `error` and `loading` handlers.
     @method intermediateTransitionTo
    @param {String} name the name of the route
    @param {...Object} models the model(s) to be used while transitioning
    to the route.
    @since 1.2.0
    @public
   */
  intermediateTransitionTo(...args) {
    let [name, ...preparedArgs] = prefixRouteNameArg(this, args);
    this._router.intermediateTransitionTo(name, ...preparedArgs);
  }
  /**
    Refresh the model on this route and any child routes, firing the
    `beforeModel`, `model`, and `afterModel` hooks in a similar fashion
    to how routes are entered when transitioning in from other route.
    The current route params (e.g. `article_id`) will be passed in
    to the respective model hooks, and if a different model is returned,
    `setupController` and associated route hooks will re-fire as well.
     An example usage of this method is re-querying the server for the
    latest information using the same parameters as when the route
    was first entered.
     Note that this will cause `model` hooks to fire even on routes
    that were provided a model object when the route was initially
    entered.
     @method refresh
    @return {Transition} the transition object associated with this
      attempted transition
    @since 1.4.0
    @public
   */
  refresh() {
    return this._router._routerMicrolib.refresh(this);
  }
  /**
    This hook is the entry point for router.js
     @private
    @method setup
  */
  setup(context2, transition) {
    let controllerName = this.controllerName || this.routeName;
    let definedController = this.controllerFor(controllerName, true);
    let controller = definedController ?? this.generateController(controllerName);
    let queryParams = get(this, "_qp");
    if (!this.controller) {
      let propNames = queryParams.propertyNames;
      addQueryParamsObservers(controller, propNames);
      this.controller = controller;
    }
    let states = queryParams.states;
    controller._qpDelegate = states.allowOverrides;
    if (transition) {
      stashParamNames(this._router, transition[STATE_SYMBOL].routeInfos);
      let cache = this._bucketCache;
      let params = transition[PARAMS_SYMBOL];
      let allParams = queryParams.propertyNames;
      allParams.forEach((prop) => {
        let aQp = queryParams.map[prop];
        !aQp && assert("expected aQp", aQp);
        aQp.values = params;
        let cacheKey = calculateCacheKey(aQp.route.fullRouteName, aQp.parts, aQp.values);
        let value = cache.lookup(cacheKey, prop, aQp.undecoratedDefaultValue);
        set(controller, prop, value);
      });
      let qpValues = getQueryParamsFor(this, transition[STATE_SYMBOL]);
      setProperties(controller, qpValues);
    }
    this.setupController(controller, context2, transition);
    if (this._environment.options.shouldRender) {
      this[RENDER]();
    }
    flushAsyncObservers(false);
  }
  /*
    Called when a query parameter for this route changes, regardless of whether the route
    is currently part of the active route hierarchy. This will update the query parameter's
    value in the cache so if this route becomes active, the cache value has been updated.
  */
  _qpChanged(prop, value, qp) {
    if (!qp) {
      return;
    }
    let cache = this._bucketCache;
    let cacheKey = calculateCacheKey(qp.route.fullRouteName, qp.parts, qp.values);
    cache.stash(cacheKey, prop, value);
  }
  /**
    This hook is the first of the route entry validation hooks
    called when an attempt is made to transition into a route
    or one of its children. It is called before `model` and
    `afterModel`, and is appropriate for cases when:
     1) A decision can be made to redirect elsewhere without
       needing to resolve the model first.
    2) Any async operations need to occur first before the
       model is attempted to be resolved.
     This hook is provided the current `transition` attempt
    as a parameter, which can be used to `.abort()` the transition,
    save it for a later `.retry()`, or retrieve values set
    on it from a previous hook. You can also just call
    `router.transitionTo` to another route to implicitly
    abort the `transition`.
     You can return a promise from this hook to pause the
    transition until the promise resolves (or rejects). This could
    be useful, for instance, for retrieving async code from
    the server that is required to enter a route.
     @method beforeModel
    @param {Transition} transition
    @return {any | Promise<any>} if the value returned from this hook is
      a promise, the transition will pause until the transition
      resolves. Otherwise, non-promise return values are not
      utilized in any way.
    @since 1.0.0
    @public
  */
  beforeModel(_transition) {
  }
  /**
    This hook is called after this route's model has resolved.
    It follows identical async/promise semantics to `beforeModel`
    but is provided the route's resolved model in addition to
    the `transition`, and is therefore suited to performing
    logic that can only take place after the model has already
    resolved.
     ```app/routes/posts.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PostsRoute extends Route {
      @service router;
       afterModel(posts, transition) {
        if (posts.get('length') === 1) {
          this.router.transitionTo('post.show', posts.get('firstObject'));
        }
      }
    }
    ```
     Refer to documentation for `beforeModel` for a description
    of transition-pausing semantics when a promise is returned
    from this hook.
     @method afterModel
    @param {Object} resolvedModel the value returned from `model`,
      or its resolved value if it was a promise
    @param {Transition} transition
    @return {any | Promise<any>} if the value returned from this hook is
      a promise, the transition will pause until the transition
      resolves. Otherwise, non-promise return values are not
      utilized in any way.
    @since 1.0.0
    @public
   */
  afterModel(_resolvedModel, _transition) {
  }
  /**
    A hook you can implement to optionally redirect to another route.
     Calling `this.router.transitionTo` from inside of the `redirect` hook will
    abort the current transition (into the route that has implemented `redirect`).
     `redirect` and `afterModel` behave very similarly and are
    called almost at the same time, but they have an important
    distinction when calling `this.router.transitionTo` to a child route
    of the current route. From `afterModel`, this new transition
    invalidates the current transition, causing `beforeModel`,
    `model`, and `afterModel` hooks to be called again. But the
    same transition started from `redirect` does _not_ invalidate
    the current transition. In other words, by the time the `redirect`
    hook has been called, both the resolved model and the attempted
    entry into this route are considered fully validated.
     @method redirect
    @param {Object} model the model for this route
    @param {Transition} transition the transition object associated with the current transition
    @since 1.0.0
    @public
  */
  redirect(_model, _transition) {
  }
  /**
    Called when the context is changed by router.js.
     @private
    @method contextDidChange
  */
  contextDidChange() {
    this.currentModel = this.context;
  }
  /**
    A hook you can implement to convert the URL into the model for
    this route.
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     export default Router;
    ```
     Note that for routes with dynamic segments, this hook is not always
    executed. If the route is entered through a transition (e.g. when
    using the `link-to` Handlebars helper or the `transitionTo` method
    of routes), and a model context is already provided this hook
    is not called.
     A model context does not include a primitive string or number,
    which does cause the model hook to be called.
     Routes without dynamic segments will always execute the model hook.
     ```javascript
    // no dynamic segment, model hook always called
    this.router.transitionTo('posts');
     // model passed in, so model hook not called
    thePost = store.findRecord('post', 1);
    this.router.transitionTo('post', thePost);
     // integer passed in, model hook is called
    this.router.transitionTo('post', 1);
     // model id passed in, model hook is called
    // useful for forcing the hook to execute
    thePost = store.findRecord('post', 1);
    this.router.transitionTo('post', thePost.id);
    ```
     This hook follows the asynchronous/promise semantics
    described in the documentation for `beforeModel`. In particular,
    if a promise returned from `model` fails, the error will be
    handled by the `error` hook on `Route`.
     Note that the legacy behavior of automatically defining a model
    hook when a dynamic segment ending in `_id` is present is
    [deprecated](https://deprecations.emberjs.com/v5.x#toc_deprecate-implicit-route-model).
    You should explicitly define a model hook whenever any segments are
    present.
     Example
     ```app/routes/post.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PostRoute extends Route {
      @service store;
       model(params) {
        return this.store.findRecord('post', params.post_id);
      }
    }
    ```
     @method model
    @param {Object} params the parameters extracted from the URL
    @param {Transition} transition
    @return {any | Promise<any>} the model for this route. If
      a promise is returned, the transition will pause until
      the promise resolves, and the resolved value of the promise
      will be used as the model for this route.
    @since 1.0.0
    @public
  */
  model(params, transition) {
    let name, sawParams;
    let queryParams = get(this, "_qp").map;
    for (let prop in params) {
      if (prop === "queryParams" || queryParams && prop in queryParams) {
        continue;
      }
      let match2 = prop.match(/^(.*)_id$/);
      if (match2 !== null) {
        name = match2[1];
      }
      sawParams = true;
    }
    if (!name) {
      if (sawParams) {
        return Object.assign({}, params);
      } else {
        if (transition.resolveIndex < 1) {
          return;
        }
        return transition[STATE_SYMBOL].routeInfos[transition.resolveIndex - 1].context;
      }
    }
    return void 0;
  }
  /**
    @private
    @method deserialize
    @param {Object} params the parameters extracted from the URL
    @param {Transition} transition
    @return {any | Promise<any>} the model for this route.
     Router.js hook.
   */
  deserialize(_params, transition) {
    return this.model(this._paramsFor(this.routeName, _params), transition);
  }
  /**
    A hook you can use to setup the controller for the current route.
     This method is called with the controller for the current route and the
    model supplied by the `model` hook.
     By default, the `setupController` hook sets the `model` property of
    the controller to the specified `model` when it is not `undefined`.
     If you implement the `setupController` hook in your Route, it will
    prevent this default behavior. If you want to preserve that behavior
    when implementing your `setupController` function, make sure to call
    `super`:
     ```app/routes/photos.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class PhotosRoute extends Route {
      @service store;
       model() {
        return this.store.findAll('photo');
      }
       setupController(controller, model) {
        super.setupController(controller, model);
         this.controllerFor('application').set('showingPhotos', true);
      }
    }
    ```
     The provided controller will be one resolved based on the name
    of this route.
     If no explicit controller is defined, Ember will automatically create one.
     As an example, consider the router:
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' });
    });
     export default Router;
    ```
     If you have defined a file for the post controller,
    the framework will use it.
    If it is not defined, a basic `Controller` instance would be used.
     @example Behavior of a basic Controller
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      setupController(controller, model) {
        controller.set('model', model);
      }
    });
    ```
     @method setupController
    @param {Controller} controller instance
    @param {Object} model
    @param {Transition} [transition]
    @since 1.0.0
    @public
  */
  setupController(controller, context2, _transition) {
    if (controller && context2 !== void 0) {
      set(controller, "model", context2);
    }
  }
  /**
    Returns the controller of the current route, or a parent (or any ancestor)
    route in a route hierarchy.
     The controller instance must already have been created, either through entering the
    associated route or using `generateController`.
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class PostRoute extends Route {
      setupController(controller, post) {
        super.setupController(controller, post);
         this.controllerFor('posts').set('currentPost', post);
      }
    }
    ```
     @method controllerFor
    @param {String} name the name of the route or controller
    @return {Controller | undefined}
    @since 1.0.0
    @public
  */
  controllerFor(name, _skipAssert = false) {
    let owner = getOwner2(this);
    !owner && assert("Route is unexpectedly missing an owner", owner);
    let route = owner.lookup(`route:${name}`);
    if (route && route.controllerName) {
      name = route.controllerName;
    }
    let controller = owner.lookup(`controller:${name}`);
    !(controller !== void 0 || _skipAssert === true) && assert(`The controller named '${name}' could not be found. Make sure that this route exists and has already been entered at least once. If you are accessing a controller not associated with a route, make sure the controller class is explicitly defined.`, controller !== void 0 || _skipAssert === true);
    !(controller === void 0 || controller instanceof Controller) && assert(`Expected controller:${name} to be an instance of Controller`, controller === void 0 || controller instanceof Controller);
    return controller;
  }
  /**
    Generates a controller for a route.
     Example
     ```app/routes/post.js
    import Route from '@ember/routing/route';
     export default class Post extends Route {
      setupController(controller, post) {
        super.setupController(controller, post);
         this.generateController('posts');
      }
    }
    ```
     @method generateController
    @param {String} name the name of the controller
    @private
  */
  generateController(name) {
    let owner = getOwner2(this);
    !owner && assert("Route is unexpectedly missing an owner", owner);
    return generateController(owner, name);
  }
  /**
    Returns the resolved model of a parent (or any ancestor) route
    in a route hierarchy.  During a transition, all routes
    must resolve a model object, and if a route
    needs access to a parent route's model in order to
    resolve a model (or just reuse the model from a parent),
    it can call `this.modelFor(theNameOfParentRoute)` to
    retrieve it. If the ancestor route's model was a promise,
    its resolved result is returned.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('post', { path: '/posts/:post_id' }, function() {
        this.route('comments');
      });
    });
     export default Router;
    ```
     ```app/routes/post/comments.js
    import Route from '@ember/routing/route';
     export default class PostCommentsRoute extends Route {
      model() {
        let post = this.modelFor('post');
         return post.comments;
      }
    }
    ```
     @method modelFor
    @param {String} name the name of the route
    @return {Object} the model object
    @since 1.0.0
    @public
  */
  modelFor(_name) {
    let name;
    let owner = getOwner2(this);
    !(owner instanceof EngineInstance) && assert("Expected router owner to be an EngineInstance", owner instanceof EngineInstance);
    let transition = this._router && this._router._routerMicrolib ? this._router._routerMicrolib.activeTransition : void 0;
    if (owner.routable && transition !== void 0) {
      name = getEngineRouteName(owner, _name);
    } else {
      name = _name;
    }
    let route = owner.lookup(`route:${name}`);
    if (transition !== void 0 && transition !== null) {
      let modelLookupName = route && route.routeName || name;
      if (Object.prototype.hasOwnProperty.call(transition.resolvedModels, modelLookupName)) {
        return transition.resolvedModels[modelLookupName];
      }
    }
    return route?.currentModel;
  }
  [RENDER_STATE] = void 0;
  /**
    `this[RENDER]` is used to set up the rendering option for the outlet state.
    @method this[RENDER]
    @private
   */
  [RENDER]() {
    this[RENDER_STATE] = buildRenderState(this);
    once(this._router, "_setOutlets");
  }
  willDestroy() {
    this.teardownViews();
  }
  /**
    @private
     @method teardownViews
  */
  teardownViews() {
    if (this[RENDER_STATE]) {
      this[RENDER_STATE] = void 0;
      once(this._router, "_setOutlets");
    }
  }
  /**
    Allows you to produce custom metadata for the route.
    The return value of this method will be attached to
    its corresponding RouteInfoWithAttributes object.
     Example
     ```app/routes/posts/index.js
    import Route from '@ember/routing/route';
     export default class PostsIndexRoute extends Route {
      buildRouteInfoMetadata() {
        return { title: 'Posts Page' }
      }
    }
    ```
     ```app/routes/application.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     export default class ApplicationRoute extends Route {
      @service router
       constructor() {
        super(...arguments);
         this.router.on('routeDidChange', transition => {
          document.title = transition.to.metadata.title;
          // would update document's title to "Posts Page"
        });
      }
    }
    ```
    @method buildRouteInfoMetadata
    @return any
    @since 3.10.0
    @public
   */
  buildRouteInfoMetadata() {
  }
  _paramsFor(routeName, params) {
    let transition = this._router._routerMicrolib.activeTransition;
    if (transition !== void 0) {
      return this.paramsFor(routeName);
    }
    return params;
  }
  /** @deprecated Manually define your own store, such as with `@service store` */
  get _store() {
    const owner = getOwner2(this);
    !owner && assert("Route is unexpectedly missing an owner", owner);
    let routeName = this.routeName;
    return {
      find(name, value) {
        let modelClass = owner.factoryFor(`model:${name}`);
        !Boolean(modelClass) && assert(`You used the dynamic segment \`${name}_id\` in your route \`${routeName}\` for which Ember requires you provide a data-loading implementation. Commonly, that is done by adding a model hook implementation on the route (\`model({${name}_id}) {\`) or by injecting an implemention of a data store: \`@service store;\`.`, Boolean(modelClass));
        if (!modelClass) {
          return;
        }
        modelClass = modelClass.class;
        !(typeof modelClass.find === "function") && assert(`You used the dynamic segment \`${name}_id\` in your route \`${routeName}\` for which Ember requires you provide a data-loading implementation. Commonly, that is done by adding a model hook implementation on the route (\`model({${name}_id}) {\`) or by injecting an implemention of a data store: \`@service store;\`.

Rarely, applications may attempt to use a legacy behavior where the model class (in this case \`${name}\`) is resolved and the \`find\` method on that class is invoked to load data. In this application, a model of \`${name}\` was found but it did not provide a \`find\` method. You should not add a \`find\` method to your model. Instead, please implement an appropriate \`model\` hook on the \`${routeName}\` route.`, typeof modelClass.find === "function");
        return modelClass.find(value);
      }
    };
  }
  get _qp() {
    let combinedQueryParameterConfiguration = {};
    let controllerName = this.controllerName || this.routeName;
    let owner = getOwner2(this);
    !owner && assert("Route is unexpectedly missing an owner", owner);
    let controller = owner.lookup(`controller:${controllerName}`);
    let queryParameterConfiguraton = get(this, "queryParams");
    let hasRouterDefinedQueryParams = Object.keys(queryParameterConfiguraton).length > 0;
    if (controller) {
      !(controller instanceof Controller) && assert("Expected an instance of controller", controller instanceof Controller);
      let controllerDefinedQueryParameterConfiguration = get(controller, "queryParams") || [];
      let normalizedControllerQueryParameterConfiguration = normalizeControllerQueryParams(controllerDefinedQueryParameterConfiguration);
      combinedQueryParameterConfiguration = mergeEachQueryParams(normalizedControllerQueryParameterConfiguration, queryParameterConfiguraton);
    } else if (hasRouterDefinedQueryParams) {
      controller = generateController(owner, controllerName);
      combinedQueryParameterConfiguration = queryParameterConfiguraton;
    }
    let qps = [];
    let map3 = {};
    let propertyNames = [];
    for (let propName in combinedQueryParameterConfiguration) {
      if (!Object.prototype.hasOwnProperty.call(combinedQueryParameterConfiguration, propName)) {
        continue;
      }
      if (propName === "unknownProperty" || propName === "_super") {
        continue;
      }
      let desc = combinedQueryParameterConfiguration[propName];
      !desc && assert(`[BUG] missing query parameter configuration for ${propName}`, desc);
      let scope = desc.scope || "model";
      let parts = void 0;
      if (scope === "controller") {
        parts = [];
      }
      let urlKey = desc.as || this.serializeQueryParamKey(propName);
      let defaultValue = get(controller, propName);
      defaultValue = copyDefaultValue(defaultValue);
      let type = desc.type || typeOf(defaultValue);
      let defaultValueSerialized = this.serializeQueryParam(defaultValue, urlKey, type);
      let scopedPropertyName = `${controllerName}:${propName}`;
      let qp = {
        undecoratedDefaultValue: get(controller, propName),
        defaultValue,
        serializedDefaultValue: defaultValueSerialized,
        serializedValue: defaultValueSerialized,
        type,
        urlKey,
        prop: propName,
        scopedPropertyName,
        controllerName,
        route: this,
        parts,
        // provided later when stashNames is called if 'model' scope
        values: null,
        // provided later when setup is called. no idea why.
        scope
      };
      map3[propName] = map3[urlKey] = map3[scopedPropertyName] = qp;
      qps.push(qp);
      propertyNames.push(propName);
    }
    return {
      qps,
      map: map3,
      propertyNames,
      states: {
        /*
          Called when a query parameter changes in the URL, this route cares
          about that query parameter, but the route is not currently
          in the active route hierarchy.
        */
        inactive: (prop, value) => {
          let qp = map3[prop];
          !qp && assert("expected inactive callback to only be called for registered qps", qp);
          this._qpChanged(prop, value, qp);
        },
        /*
          Called when a query parameter changes in the URL, this route cares
          about that query parameter, and the route is currently
          in the active route hierarchy.
        */
        active: (prop, value) => {
          let qp = map3[prop];
          !qp && assert("expected active callback to only be called for registered qps", qp);
          this._qpChanged(prop, value, qp);
          return this._activeQPChanged(qp, value);
        },
        /*
          Called when a value of a query parameter this route handles changes in a controller
          and the route is currently in the active route hierarchy.
        */
        allowOverrides: (prop, value) => {
          let qp = map3[prop];
          !qp && assert("expected allowOverrides callback to only be called for registered qps", qp);
          this._qpChanged(prop, value, qp);
          return this._updatingQPChanged(qp);
        }
      }
    };
  }
  /**
    Sends an action to the router, which will delegate it to the currently
    active route hierarchy per the bubbling rules explained under `actions`.
     Example
     ```app/router.js
    // ...
     Router.map(function() {
      this.route('index');
    });
     export default Router;
    ```
     ```app/routes/application.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class ApplicationRoute extends Route {
      @action
      track(arg) {
        console.log(arg, 'was clicked');
      }
    }
    ```
     ```app/routes/index.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class IndexRoute extends Route {
      @action
      trackIfDebug(arg) {
        if (debug) {
          this.send('track', arg);
        }
      }
    }
    ```
     @method send
    @param {String} name the name of the action to trigger
    @param {...*} args
    @since 1.0.0
    @public
  */
  // Set with reopen to override parent behavior
};
__publicField(_Route, "isRouteFactory", true);
decorateMethodV2(_Route.prototype, "_store", [computed]);
decorateMethodV2(_Route.prototype, "_qp", [computed]);
var Route = _Route;
function getRenderState(route) {
  return route[RENDER_STATE];
}
function buildRenderState(route) {
  let owner = getOwner2(route);
  !owner && assert("Route is unexpectedly missing an owner", owner);
  let name = route.routeName;
  let controller = owner.lookup(`controller:${route.controllerName || name}`);
  !(controller instanceof Controller) && assert("Expected an instance of controller", controller instanceof Controller);
  let model = route.currentModel;
  let templateFactoryOrComponent = owner.lookup(`template:${route.templateName || name}`);
  let template;
  if (templateFactoryOrComponent) {
    if (hasInternalComponentManager(templateFactoryOrComponent)) {
      template = templateFactoryOrComponent;
    } else {
      if (typeof templateFactoryOrComponent !== "function") {
        let label;
        try {
          label = `\`${String(templateFactoryOrComponent)}\``;
        } catch {
          label = "an unknown object";
        }
        assert(`Failed to render the ${name} route, expected \`template:${route.templateName || name}\` to resolve into a component or a \`TemplateFactory\`, got: ${label}. Most likely an improperly defined class or an invalid module export.`);
      }
      template = templateFactoryOrComponent(owner);
    }
  } else {
    template = route._topLevelViewTemplate(owner);
  }
  let render = {
    owner,
    name,
    controller,
    model,
    template
  };
  if (true) {
    let LOG_VIEW_LOOKUPS = get(route._router, "namespace.LOG_VIEW_LOOKUPS");
    if (LOG_VIEW_LOOKUPS && !templateFactoryOrComponent) {
      info(`Could not find "${name}" template. Nothing will be rendered`, {
        fullName: `template:${name}`
      });
    }
  }
  return render;
}
function getFullQueryParams(router, state) {
  if (state.fullQueryParams) {
    return state.fullQueryParams;
  }
  let haveAllRouteInfosResolved = state.routeInfos.every((routeInfo) => routeInfo.route);
  let fullQueryParamsState = {
    ...state.queryParams
  };
  router._deserializeQueryParams(state.routeInfos, fullQueryParamsState);
  if (haveAllRouteInfosResolved) {
    state.fullQueryParams = fullQueryParamsState;
  }
  return fullQueryParamsState;
}
function getQueryParamsFor(route, state) {
  state.queryParamsFor = state.queryParamsFor || {};
  let name = route.fullRouteName;
  let existing = state.queryParamsFor[name];
  if (existing) {
    return existing;
  }
  let fullQueryParams = getFullQueryParams(route._router, state);
  let params = state.queryParamsFor[name] = {};
  let qps = get(route, "_qp").qps;
  for (let qp of qps) {
    let qpValueWasPassedIn = qp.prop in fullQueryParams;
    params[qp.prop] = qpValueWasPassedIn ? fullQueryParams[qp.prop] : copyDefaultValue(qp.defaultValue);
  }
  return params;
}
function copyDefaultValue(value) {
  if (Array.isArray(value)) {
    return A(value.slice());
  }
  return value;
}
function mergeEachQueryParams(controllerQP, routeQP) {
  let qps = {};
  let keysAlreadyMergedOrSkippable = {
    defaultValue: true,
    type: true,
    scope: true,
    as: true
  };
  for (let cqpName in controllerQP) {
    if (!Object.prototype.hasOwnProperty.call(controllerQP, cqpName)) {
      continue;
    }
    qps[cqpName] = {
      ...controllerQP[cqpName],
      ...routeQP[cqpName]
    };
    keysAlreadyMergedOrSkippable[cqpName] = true;
  }
  for (let rqpName in routeQP) {
    if (!Object.prototype.hasOwnProperty.call(routeQP, rqpName) || keysAlreadyMergedOrSkippable[rqpName]) {
      continue;
    }
    qps[rqpName] = {
      ...routeQP[rqpName],
      ...controllerQP[rqpName]
    };
  }
  return qps;
}
function addQueryParamsObservers(controller, propNames) {
  propNames.forEach((prop) => {
    if (descriptorForProperty(controller, prop) === void 0) {
      let desc = lookupDescriptor(controller, prop);
      if (desc !== null && (typeof desc.get === "function" || typeof desc.set === "function")) {
        defineProperty(controller, prop, dependentKeyCompat({
          get: desc.get,
          set: desc.set
        }));
      }
    }
    addObserver(controller, `${prop}.[]`, controller, controller._qpChanged, false);
  });
}
function getEngineRouteName(engine, routeName) {
  if (engine.routable) {
    let prefix = engine.mountPoint;
    if (routeName === "application") {
      return prefix;
    } else {
      return `${prefix}.${routeName}`;
    }
  }
  return routeName;
}
var defaultSerialize = Route.prototype.serialize;
function hasDefaultSerialize(route) {
  return route.serialize === defaultSerialize;
}
Route.reopen({
  mergedProperties: ["queryParams"],
  queryParams: {},
  templateName: null,
  controllerName: null,
  send(...args) {
    !(!this.isDestroying && !this.isDestroyed) && assert(`Attempted to call .send() with the action '${args[0]}' on the destroyed route '${this.routeName}'.`, !this.isDestroying && !this.isDestroyed);
    if (this._router && this._router._routerMicrolib || !isTesting()) {
      this._router.send(...args);
    } else {
      let name = args.shift();
      let action2 = this.actions[name];
      if (action2) {
        return action2.apply(this, args);
      }
    }
  },
  /**
    The controller associated with this route.
     Example
     ```app/routes/form.js
    import Route from '@ember/routing/route';
    import { action } from '@ember/object';
     export default class FormRoute extends Route {
      @action
      willTransition(transition) {
        if (this.controller.get('userHasEnteredData') &&
            !confirm('Are you sure you want to abandon progress?')) {
          transition.abort();
        } else {
          // Bubble the `willTransition` action so that
          // parent routes can decide whether or not to abort.
          return true;
        }
      }
    }
    ```
     @property controller
    @type Controller
    @since 1.6.0
    @public
  */
  actions: {
    /**
    This action is called when one or more query params have changed. Bubbles.
     @method queryParamsDidChange
    @param changed {Object} Keys are names of query params that have changed.
    @param totalPresent {Object} Keys are names of query params that are currently set.
    @param removed {Object} Keys are names of query params that have been removed.
    @returns {boolean}
    @private
    */
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
    queryParamsDidChange(changed, _totalPresent, removed) {
      let qpMap = get(this, "_qp").map;
      let totalChanged = Object.keys(changed).concat(Object.keys(removed));
      for (let change of totalChanged) {
        let qp = qpMap[change];
        if (qp) {
          let options = this._optionsForQueryParam(qp);
          !(options && typeof options === "object") && assert("options exists", options && typeof options === "object");
          if (get(options, "refreshModel") && this._router.currentState) {
            this.refresh();
            break;
          }
        }
      }
      return true;
    },
    finalizeQueryParamChange(params, finalParams, transition) {
      if (this.fullRouteName !== "application") {
        return true;
      }
      if (!transition) {
        return;
      }
      let routeInfos = transition[STATE_SYMBOL].routeInfos;
      let router = this._router;
      let qpMeta = router._queryParamsFor(routeInfos);
      let changes = router._qpUpdates;
      let qpUpdated = false;
      let replaceUrl;
      stashParamNames(router, routeInfos);
      for (let qp of qpMeta.qps) {
        let route = qp.route;
        let controller = route.controller;
        let presentKey = qp.urlKey in params && qp.urlKey;
        let value;
        let svalue;
        if (changes.has(qp.urlKey)) {
          value = get(controller, qp.prop);
          svalue = route.serializeQueryParam(value, qp.urlKey, qp.type);
        } else {
          if (presentKey) {
            svalue = params[presentKey];
            if (svalue !== void 0) {
              value = route.deserializeQueryParam(svalue, qp.urlKey, qp.type);
            }
          } else {
            svalue = qp.serializedDefaultValue;
            value = copyDefaultValue(qp.defaultValue);
          }
        }
        controller._qpDelegate = get(route, "_qp").states.inactive;
        let thisQueryParamChanged = svalue !== qp.serializedValue;
        if (thisQueryParamChanged) {
          if (transition.queryParamsOnly && replaceUrl !== false) {
            let options = route._optionsForQueryParam(qp);
            let replaceConfigValue = get(options, "replace");
            if (replaceConfigValue) {
              replaceUrl = true;
            } else if (replaceConfigValue === false) {
              replaceUrl = false;
            }
          }
          set(controller, qp.prop, value);
          qpUpdated = true;
        }
        qp.serializedValue = svalue;
        let thisQueryParamHasDefaultValue = qp.serializedDefaultValue === svalue;
        if (!thisQueryParamHasDefaultValue) {
          finalParams.push({
            value: svalue,
            visible: true,
            key: presentKey || qp.urlKey
          });
        }
      }
      if (qpUpdated === true) {
        flushAsyncObservers(false);
      }
      if (replaceUrl) {
        transition.method("replace");
      }
      qpMeta.qps.forEach((qp) => {
        let routeQpMeta = get(qp.route, "_qp");
        let finalizedController = qp.route.controller;
        finalizedController["_qpDelegate"] = get(routeQpMeta, "states.active");
      });
      router._qpUpdates.clear();
      return;
    }
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/router-BViwI_oJ.js
var ROUTE_INFOS = /* @__PURE__ */ new WeakMap();
function toReadOnlyRouteInfo(routeInfos, queryParams = {}, options = {
  includeAttributes: false,
  localizeMapUpdates: false
}) {
  const LOCAL_ROUTE_INFOS = /* @__PURE__ */ new WeakMap();
  return routeInfos.map((info2, i) => {
    let {
      name,
      params,
      paramNames,
      context: context2,
      route
    } = info2;
    let key = info2;
    if (ROUTE_INFOS.has(key) && options.includeAttributes) {
      let routeInfo2 = ROUTE_INFOS.get(key);
      routeInfo2 = attachMetadata(route, routeInfo2);
      let routeInfoWithAttribute = createRouteInfoWithAttributes(routeInfo2, context2);
      LOCAL_ROUTE_INFOS.set(key, routeInfo2);
      if (!options.localizeMapUpdates) {
        ROUTE_INFOS.set(key, routeInfoWithAttribute);
      }
      return routeInfoWithAttribute;
    }
    const routeInfosRef = options.localizeMapUpdates ? LOCAL_ROUTE_INFOS : ROUTE_INFOS;
    let routeInfo = {
      find(predicate, thisArg) {
        let publicInfo;
        let arr = [];
        if (predicate.length === 3) {
          arr = routeInfos.map(
            // SAFETY: This should be safe since it is just for use as a key
            (info3) => routeInfosRef.get(info3)
          );
        }
        for (let i2 = 0; routeInfos.length > i2; i2++) {
          publicInfo = routeInfosRef.get(routeInfos[i2]);
          if (predicate.call(thisArg, publicInfo, i2, arr)) {
            return publicInfo;
          }
        }
        return void 0;
      },
      get name() {
        return name;
      },
      get paramNames() {
        return paramNames;
      },
      get metadata() {
        return buildRouteInfoMetadata(info2.route);
      },
      get parent() {
        let parent = routeInfos[i - 1];
        if (parent === void 0) {
          return null;
        }
        return routeInfosRef.get(parent);
      },
      get child() {
        let child = routeInfos[i + 1];
        if (child === void 0) {
          return null;
        }
        return routeInfosRef.get(child);
      },
      get localName() {
        let parts = this.name.split(".");
        return parts[parts.length - 1];
      },
      get params() {
        return params;
      },
      get queryParams() {
        return queryParams;
      }
    };
    if (options.includeAttributes) {
      routeInfo = createRouteInfoWithAttributes(routeInfo, context2);
    }
    LOCAL_ROUTE_INFOS.set(info2, routeInfo);
    if (!options.localizeMapUpdates) {
      ROUTE_INFOS.set(info2, routeInfo);
    }
    return routeInfo;
  });
}
function createRouteInfoWithAttributes(routeInfo, context2) {
  let attributes = {
    get attributes() {
      return context2;
    }
  };
  if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty("attributes")) {
    return Object.freeze(Object.assign({}, routeInfo, attributes));
  }
  return Object.assign(routeInfo, attributes);
}
function buildRouteInfoMetadata(route) {
  if (route !== void 0 && route !== null && route.buildRouteInfoMetadata !== void 0) {
    return route.buildRouteInfoMetadata();
  }
  return null;
}
function attachMetadata(route, routeInfo) {
  let metadata = {
    get metadata() {
      return buildRouteInfoMetadata(route);
    }
  };
  if (!Object.isExtensible(routeInfo) || routeInfo.hasOwnProperty("metadata")) {
    return Object.freeze(Object.assign({}, routeInfo, metadata));
  }
  return Object.assign(routeInfo, metadata);
}
var InternalRouteInfo = class {
  constructor(router, name, paramNames, route) {
    this._routePromise = void 0;
    this._route = null;
    this.params = {};
    this.isResolved = false;
    this.name = name;
    this.paramNames = paramNames;
    this.router = router;
    if (route) {
      this._processRoute(route);
    }
  }
  getModel(_transition) {
    return Promise$1.resolve(this.context);
  }
  serialize(_context) {
    return this.params || {};
  }
  resolve(transition) {
    return Promise$1.resolve(this.routePromise).then((route) => {
      throwIfAborted(transition);
      return route;
    }).then(() => this.runBeforeModelHook(transition)).then(() => throwIfAborted(transition)).then(() => this.getModel(transition)).then((resolvedModel) => {
      throwIfAborted(transition);
      return resolvedModel;
    }).then((resolvedModel) => this.runAfterModelHook(transition, resolvedModel)).then((resolvedModel) => this.becomeResolved(transition, resolvedModel));
  }
  becomeResolved(transition, resolvedContext) {
    let params = this.serialize(resolvedContext);
    if (transition) {
      this.stashResolvedModel(transition, resolvedContext);
      transition[PARAMS_SYMBOL] = transition[PARAMS_SYMBOL] || {};
      transition[PARAMS_SYMBOL][this.name] = params;
    }
    let context2;
    let contextsMatch = resolvedContext === this.context;
    if ("context" in this || !contextsMatch) {
      context2 = resolvedContext;
    }
    let cached = ROUTE_INFOS.get(this);
    let resolved = new ResolvedRouteInfo(this.router, this.name, this.paramNames, params, this.route, context2);
    if (cached !== void 0) {
      ROUTE_INFOS.set(resolved, cached);
    }
    return resolved;
  }
  shouldSupersede(routeInfo) {
    if (!routeInfo) {
      return true;
    }
    let contextsMatch = routeInfo.context === this.context;
    return routeInfo.name !== this.name || "context" in this && !contextsMatch || this.hasOwnProperty("params") && !paramsMatch(this.params, routeInfo.params);
  }
  get route() {
    if (this._route !== null) {
      return this._route;
    }
    return this.fetchRoute();
  }
  set route(route) {
    this._route = route;
  }
  get routePromise() {
    if (this._routePromise) {
      return this._routePromise;
    }
    this.fetchRoute();
    return this._routePromise;
  }
  set routePromise(routePromise) {
    this._routePromise = routePromise;
  }
  log(transition, message) {
    if (transition.log) {
      transition.log(this.name + ": " + message);
    }
  }
  updateRoute(route) {
    route._internalName = this.name;
    return this.route = route;
  }
  runBeforeModelHook(transition) {
    if (transition.trigger) {
      transition.trigger(true, "willResolveModel", transition, this.route);
    }
    let result;
    if (this.route) {
      if (this.route.beforeModel !== void 0) {
        result = this.route.beforeModel(transition);
      }
    }
    if (isTransition(result)) {
      result = null;
    }
    return Promise$1.resolve(result);
  }
  runAfterModelHook(transition, resolvedModel) {
    let name = this.name;
    this.stashResolvedModel(transition, resolvedModel);
    let result;
    if (this.route !== void 0) {
      if (this.route.afterModel !== void 0) {
        result = this.route.afterModel(resolvedModel, transition);
      }
    }
    result = prepareResult(result);
    return Promise$1.resolve(result).then(() => {
      return transition.resolvedModels[name];
    });
  }
  stashResolvedModel(transition, resolvedModel) {
    transition.resolvedModels = transition.resolvedModels || {};
    transition.resolvedModels[this.name] = resolvedModel;
  }
  fetchRoute() {
    let route = this.router.getRoute(this.name);
    return this._processRoute(route);
  }
  _processRoute(route) {
    this.routePromise = Promise$1.resolve(route);
    if (isPromise(route)) {
      this.routePromise = this.routePromise.then((r) => {
        return this.updateRoute(r);
      });
      return this.route = void 0;
    } else if (route) {
      return this.updateRoute(route);
    }
    return void 0;
  }
};
var ResolvedRouteInfo = class extends InternalRouteInfo {
  constructor(router, name, paramNames, params, route, context2) {
    super(router, name, paramNames, route);
    this.params = params;
    this.isResolved = true;
    this.context = context2;
  }
  resolve(transition) {
    if (transition && transition.resolvedModels) {
      transition.resolvedModels[this.name] = this.context;
    }
    return Promise$1.resolve(this);
  }
};
var UnresolvedRouteInfoByParam = class extends InternalRouteInfo {
  constructor(router, name, paramNames, params, route) {
    super(router, name, paramNames, route);
    this.params = {};
    if (params) {
      this.params = params;
    }
  }
  getModel(transition) {
    let fullParams = this.params;
    if (transition && transition[QUERY_PARAMS_SYMBOL]) {
      fullParams = {};
      merge(fullParams, this.params);
      fullParams.queryParams = transition[QUERY_PARAMS_SYMBOL];
    }
    let route = this.route;
    let result;
    if (route.deserialize) {
      result = route.deserialize(fullParams, transition);
    } else if (route.model) {
      result = route.model(fullParams, transition);
    }
    if (result && isTransition(result)) {
      result = void 0;
    }
    return Promise$1.resolve(result);
  }
};
var UnresolvedRouteInfoByObject = class extends InternalRouteInfo {
  constructor(router, name, paramNames, context2) {
    super(router, name, paramNames);
    this.context = context2;
    this.serializer = this.router.getSerializer(name);
  }
  getModel(transition) {
    if (this.router.log !== void 0) {
      this.router.log(this.name + ": resolving provided model");
    }
    return super.getModel(transition);
  }
  /**
    @private
       Serializes a route using its custom `serialize` method or
    by a default that looks up the expected property name from
    the dynamic segment.
       @param {Object} model the model to be serialized for this route
  */
  serialize(model) {
    let {
      paramNames,
      context: context2
    } = this;
    if (!model) {
      model = context2;
    }
    let object = {};
    if (isParam(model)) {
      object[paramNames[0]] = model;
      return object;
    }
    if (this.serializer) {
      return this.serializer.call(null, model, paramNames);
    } else if (this.route !== void 0) {
      if (this.route.serialize) {
        return this.route.serialize(model, paramNames);
      }
    }
    if (paramNames.length !== 1) {
      return;
    }
    let name = paramNames[0];
    if (/_id$/.test(name)) {
      object[name] = model.id;
    } else {
      object[name] = model;
    }
    return object;
  }
};
function paramsMatch(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  for (let k in a) {
    if (a.hasOwnProperty(k) && a[k] !== b[k]) {
      return false;
    }
  }
  return true;
}
var TransitionIntent = class {
  constructor(router, data = {}) {
    this.router = router;
    this.data = data;
  }
};
function handleError(currentState, transition, error) {
  let routeInfos = currentState.routeInfos;
  let errorHandlerIndex = transition.resolveIndex >= routeInfos.length ? routeInfos.length - 1 : transition.resolveIndex;
  let wasAborted = transition.isAborted;
  throw new TransitionError(error, currentState.routeInfos[errorHandlerIndex].route, wasAborted, currentState);
}
function resolveOneRouteInfo(currentState, transition) {
  if (transition.resolveIndex === currentState.routeInfos.length) {
    return;
  }
  let routeInfo = currentState.routeInfos[transition.resolveIndex];
  let callback = proceed.bind(null, currentState, transition);
  return routeInfo.resolve(transition).then(callback, null, currentState.promiseLabel("Proceed"));
}
function proceed(currentState, transition, resolvedRouteInfo) {
  let wasAlreadyResolved = currentState.routeInfos[transition.resolveIndex].isResolved;
  currentState.routeInfos[transition.resolveIndex++] = resolvedRouteInfo;
  if (!wasAlreadyResolved) {
    let {
      route
    } = resolvedRouteInfo;
    if (route !== void 0) {
      if (route.redirect) {
        route.redirect(resolvedRouteInfo.context, transition);
      }
    }
  }
  throwIfAborted(transition);
  return resolveOneRouteInfo(currentState, transition);
}
var TransitionState = class {
  constructor() {
    this.routeInfos = [];
    this.queryParams = {};
    this.params = {};
  }
  promiseLabel(label) {
    let targetName = "";
    forEach(this.routeInfos, function(routeInfo) {
      if (targetName !== "") {
        targetName += ".";
      }
      targetName += routeInfo.name;
      return true;
    });
    return promiseLabel("'" + targetName + "': " + label);
  }
  resolve(transition) {
    let params = this.params;
    forEach(this.routeInfos, (routeInfo) => {
      params[routeInfo.name] = routeInfo.params || {};
      return true;
    });
    transition.resolveIndex = 0;
    let callback = resolveOneRouteInfo.bind(null, this, transition);
    let errorHandler = handleError.bind(null, this, transition);
    return Promise$1.resolve(null, this.promiseLabel("Start transition")).then(callback, null, this.promiseLabel("Resolve route")).catch(errorHandler, this.promiseLabel("Handle error")).then(() => this);
  }
};
var TransitionError = class {
  constructor(error, route, wasAborted, state) {
    this.error = error;
    this.route = route;
    this.wasAborted = wasAborted;
    this.state = state;
  }
};
var NamedTransitionIntent = class extends TransitionIntent {
  constructor(router, name, pivotHandler, contexts = [], queryParams = {}, data) {
    super(router, data);
    this.preTransitionState = void 0;
    this.name = name;
    this.pivotHandler = pivotHandler;
    this.contexts = contexts;
    this.queryParams = queryParams;
  }
  applyToState(oldState, isIntermediate) {
    let handlers = this.router.recognizer.handlersFor(this.name);
    let targetRouteName = handlers[handlers.length - 1].handler;
    return this.applyToHandlers(oldState, handlers, targetRouteName, isIntermediate, false);
  }
  applyToHandlers(oldState, parsedHandlers, targetRouteName, isIntermediate, checkingIfActive) {
    let i, len2;
    let newState = new TransitionState();
    let objects = this.contexts.slice(0);
    let invalidateIndex = parsedHandlers.length;
    if (this.pivotHandler) {
      for (i = 0, len2 = parsedHandlers.length; i < len2; ++i) {
        if (parsedHandlers[i].handler === this.pivotHandler._internalName) {
          invalidateIndex = i;
          break;
        }
      }
    }
    for (i = parsedHandlers.length - 1; i >= 0; --i) {
      let result = parsedHandlers[i];
      let name = result.handler;
      let oldHandlerInfo = oldState.routeInfos[i];
      let newHandlerInfo = null;
      if (result.names.length > 0) {
        if (i >= invalidateIndex) {
          newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);
        } else {
          newHandlerInfo = this.getHandlerInfoForDynamicSegment(name, result.names, objects, oldHandlerInfo, targetRouteName, i);
        }
      } else {
        newHandlerInfo = this.createParamHandlerInfo(name, result.names, objects, oldHandlerInfo);
      }
      if (checkingIfActive) {
        newHandlerInfo = newHandlerInfo.becomeResolved(
          null,
          // SAFETY: This seems to imply that it would be resolved, but it's unclear if that's actually the case.
          newHandlerInfo.context
        );
        let oldContext = oldHandlerInfo && oldHandlerInfo.context;
        if (result.names.length > 0 && oldHandlerInfo.context !== void 0 && newHandlerInfo.context === oldContext) {
          newHandlerInfo.params = oldHandlerInfo && oldHandlerInfo.params;
        }
        newHandlerInfo.context = oldContext;
      }
      let handlerToUse = oldHandlerInfo;
      if (i >= invalidateIndex || newHandlerInfo.shouldSupersede(oldHandlerInfo)) {
        invalidateIndex = Math.min(i, invalidateIndex);
        handlerToUse = newHandlerInfo;
      }
      if (isIntermediate && !checkingIfActive) {
        handlerToUse = handlerToUse.becomeResolved(
          null,
          // SAFETY: This seems to imply that it would be resolved, but it's unclear if that's actually the case.
          handlerToUse.context
        );
      }
      newState.routeInfos.unshift(handlerToUse);
    }
    if (objects.length > 0) {
      throw new Error("More context objects were passed than there are dynamic segments for the route: " + targetRouteName);
    }
    if (!isIntermediate) {
      this.invalidateChildren(newState.routeInfos, invalidateIndex);
    }
    merge(newState.queryParams, this.queryParams || {});
    if (isIntermediate && oldState.queryParams) {
      merge(newState.queryParams, oldState.queryParams);
    }
    return newState;
  }
  invalidateChildren(handlerInfos, invalidateIndex) {
    for (let i = invalidateIndex, l = handlerInfos.length; i < l; ++i) {
      let handlerInfo = handlerInfos[i];
      if (handlerInfo.isResolved) {
        let {
          name,
          params,
          route,
          paramNames
        } = handlerInfos[i];
        handlerInfos[i] = new UnresolvedRouteInfoByParam(this.router, name, paramNames, params, route);
      }
    }
  }
  getHandlerInfoForDynamicSegment(name, names, objects, oldHandlerInfo, _targetRouteName, i) {
    let objectToUse;
    if (objects.length > 0) {
      objectToUse = objects[objects.length - 1];
      if (isParam(objectToUse)) {
        return this.createParamHandlerInfo(name, names, objects, oldHandlerInfo);
      } else {
        objects.pop();
      }
    } else if (oldHandlerInfo && oldHandlerInfo.name === name) {
      return oldHandlerInfo;
    } else {
      if (this.preTransitionState) {
        let preTransitionHandlerInfo = this.preTransitionState.routeInfos[i];
        objectToUse = preTransitionHandlerInfo === null || preTransitionHandlerInfo === void 0 ? void 0 : preTransitionHandlerInfo.context;
      } else {
        return oldHandlerInfo;
      }
    }
    return new UnresolvedRouteInfoByObject(this.router, name, names, objectToUse);
  }
  createParamHandlerInfo(name, names, objects, oldHandlerInfo) {
    let params = {};
    let numNames = names.length;
    let missingParams = [];
    while (numNames--) {
      let oldParams = oldHandlerInfo && name === oldHandlerInfo.name && oldHandlerInfo.params || {};
      let peek = objects[objects.length - 1];
      let paramName = names[numNames];
      if (isParam(peek)) {
        params[paramName] = "" + objects.pop();
      } else {
        if (oldParams.hasOwnProperty(paramName)) {
          params[paramName] = oldParams[paramName];
        } else {
          missingParams.push(paramName);
        }
      }
    }
    if (missingParams.length > 0) {
      throw new Error(`You didn't provide enough string/numeric parameters to satisfy all of the dynamic segments for route ${name}. Missing params: ${missingParams}`);
    }
    return new UnresolvedRouteInfoByParam(this.router, name, names, params);
  }
};
var URLTransitionIntent = class extends TransitionIntent {
  constructor(router, url, data) {
    super(router, data);
    this.url = url;
    this.preTransitionState = void 0;
  }
  applyToState(oldState) {
    let newState = new TransitionState();
    let results = this.router.recognizer.recognize(this.url), i, len2;
    if (!results) {
      throw new UnrecognizedURLError(this.url);
    }
    let statesDiffer = false;
    let _url = this.url;
    function checkHandlerAccessibility(handler) {
      if (handler && handler.inaccessibleByURL) {
        throw new UnrecognizedURLError(_url);
      }
      return handler;
    }
    for (i = 0, len2 = results.length; i < len2; ++i) {
      let result = results[i];
      let name = result.handler;
      let paramNames = [];
      if (this.router.recognizer.hasRoute(name)) {
        paramNames = this.router.recognizer.handlersFor(name)[i].names;
      }
      let newRouteInfo = new UnresolvedRouteInfoByParam(this.router, name, paramNames, result.params);
      let route = newRouteInfo.route;
      if (route) {
        checkHandlerAccessibility(route);
      } else {
        newRouteInfo.routePromise = newRouteInfo.routePromise.then(checkHandlerAccessibility);
      }
      let oldRouteInfo = oldState.routeInfos[i];
      if (statesDiffer || newRouteInfo.shouldSupersede(oldRouteInfo)) {
        statesDiffer = true;
        newState.routeInfos[i] = newRouteInfo;
      } else {
        newState.routeInfos[i] = oldRouteInfo;
      }
    }
    merge(newState.queryParams, results.queryParams);
    return newState;
  }
};
var Router = class {
  constructor(logger) {
    this._lastQueryParams = {};
    this.state = void 0;
    this.oldState = void 0;
    this.activeTransition = void 0;
    this.currentRouteInfos = void 0;
    this._changedQueryParams = void 0;
    this.currentSequence = 0;
    this.log = logger;
    this.recognizer = new RouteRecognizer();
    this.reset();
  }
  /**
    The main entry point into the router. The API is essentially
    the same as the `map` method in `route-recognizer`.
       This method extracts the String handler at the last `.to()`
    call and uses it as the name of the whole route.
       @param {Function} callback
  */
  map(callback) {
    this.recognizer.map(callback, function(recognizer, routes) {
      for (let i = routes.length - 1, proceed2 = true; i >= 0 && proceed2; --i) {
        let route = routes[i];
        let handler = route.handler;
        recognizer.add(routes, {
          as: handler
        });
        proceed2 = route.path === "/" || route.path === "" || handler.slice(-6) === ".index";
      }
    });
  }
  hasRoute(route) {
    return this.recognizer.hasRoute(route);
  }
  queryParamsTransition(changelist, wasTransitioning, oldState, newState) {
    this.fireQueryParamDidChange(newState, changelist);
    if (!wasTransitioning && this.activeTransition) {
      return this.activeTransition;
    } else {
      let newTransition = new Transition(this, void 0, void 0);
      newTransition.queryParamsOnly = true;
      oldState.queryParams = this.finalizeQueryParamChange(newState.routeInfos, newState.queryParams, newTransition);
      newTransition[QUERY_PARAMS_SYMBOL] = newState.queryParams;
      this.toReadOnlyInfos(newTransition, newState);
      this.routeWillChange(newTransition);
      newTransition.promise = newTransition.promise.then((result) => {
        if (!newTransition.isAborted) {
          this._updateURL(newTransition, oldState);
          this.didTransition(this.currentRouteInfos);
          this.toInfos(newTransition, newState.routeInfos, true);
          this.routeDidChange(newTransition);
        }
        return result;
      }, null, promiseLabel("Transition complete"));
      return newTransition;
    }
  }
  transitionByIntent(intent, isIntermediate) {
    try {
      return this.getTransitionByIntent(intent, isIntermediate);
    } catch (e) {
      return new Transition(this, intent, void 0, e, void 0);
    }
  }
  recognize(url) {
    let intent = new URLTransitionIntent(this, url);
    let newState = this.generateNewState(intent);
    if (newState === null) {
      return newState;
    }
    let readonlyInfos = toReadOnlyRouteInfo(newState.routeInfos, newState.queryParams, {
      includeAttributes: false,
      localizeMapUpdates: true
    });
    return readonlyInfos[readonlyInfos.length - 1];
  }
  recognizeAndLoad(url) {
    let intent = new URLTransitionIntent(this, url);
    let newState = this.generateNewState(intent);
    if (newState === null) {
      return Promise$1.reject(`URL ${url} was not recognized`);
    }
    let newTransition = new Transition(this, intent, newState, void 0);
    return newTransition.then(() => {
      let routeInfosWithAttributes = toReadOnlyRouteInfo(newState.routeInfos, newTransition[QUERY_PARAMS_SYMBOL], {
        includeAttributes: true,
        localizeMapUpdates: false
      });
      return routeInfosWithAttributes[routeInfosWithAttributes.length - 1];
    });
  }
  generateNewState(intent) {
    try {
      return intent.applyToState(this.state, false);
    } catch (e) {
      return null;
    }
  }
  getTransitionByIntent(intent, isIntermediate) {
    let wasTransitioning = !!this.activeTransition;
    let oldState = wasTransitioning ? this.activeTransition[STATE_SYMBOL] : this.state;
    let newTransition;
    let newState = intent.applyToState(oldState, isIntermediate);
    let queryParamChangelist = getChangelist(oldState.queryParams, newState.queryParams);
    if (routeInfosEqual(newState.routeInfos, oldState.routeInfos)) {
      if (queryParamChangelist) {
        let newTransition2 = this.queryParamsTransition(queryParamChangelist, wasTransitioning, oldState, newState);
        newTransition2.queryParamsOnly = true;
        return newTransition2;
      }
      return this.activeTransition || new Transition(this, void 0, void 0);
    }
    if (isIntermediate) {
      let transition = new Transition(this, void 0, newState);
      transition.isIntermediate = true;
      this.toReadOnlyInfos(transition, newState);
      this.setupContexts(newState, transition);
      this.routeWillChange(transition);
      return this.activeTransition;
    }
    newTransition = new Transition(this, intent, newState, void 0, this.activeTransition);
    if (routeInfosSameExceptQueryParams(newState.routeInfos, oldState.routeInfos)) {
      newTransition.queryParamsOnly = true;
    }
    this.toReadOnlyInfos(newTransition, newState);
    if (this.activeTransition) {
      this.activeTransition.redirect(newTransition);
    }
    this.activeTransition = newTransition;
    newTransition.promise = newTransition.promise.then((result) => {
      return this.finalizeTransition(newTransition, result);
    }, null, promiseLabel("Settle transition promise when transition is finalized"));
    if (!wasTransitioning) {
      this.notifyExistingHandlers(newState, newTransition);
    }
    this.fireQueryParamDidChange(newState, queryParamChangelist);
    return newTransition;
  }
  /**
  @private
     Begins and returns a Transition based on the provided
  arguments. Accepts arguments in the form of both URL
  transitions and named transitions.
     @param {Router} router
  @param {Array[Object]} args arguments passed to transitionTo,
    replaceWith, or handleURL
  */
  doTransition(name, modelsArray = [], isIntermediate = false) {
    let lastArg = modelsArray[modelsArray.length - 1];
    let queryParams = {};
    if (lastArg && Object.prototype.hasOwnProperty.call(lastArg, "queryParams")) {
      queryParams = modelsArray.pop().queryParams;
    }
    let intent;
    if (name === void 0) {
      log(this, "Updating query params");
      let {
        routeInfos
      } = this.state;
      intent = new NamedTransitionIntent(this, routeInfos[routeInfos.length - 1].name, void 0, [], queryParams);
    } else if (name.charAt(0) === "/") {
      log(this, "Attempting URL transition to " + name);
      intent = new URLTransitionIntent(this, name);
    } else {
      log(this, "Attempting transition to " + name);
      intent = new NamedTransitionIntent(
        this,
        name,
        void 0,
        // SAFETY: We know this to be the case since we removed the last item if it was QPs
        modelsArray,
        queryParams
      );
    }
    return this.transitionByIntent(intent, isIntermediate);
  }
  /**
  @private
     Updates the URL (if necessary) and calls `setupContexts`
  to update the router's array of `currentRouteInfos`.
  */
  finalizeTransition(transition, newState) {
    try {
      log(transition.router, transition.sequence, "Resolved all models on destination route; finalizing transition.");
      let routeInfos = newState.routeInfos;
      this.setupContexts(newState, transition);
      if (transition.isAborted) {
        this.state.routeInfos = this.currentRouteInfos;
        return Promise$1.reject(logAbort(transition));
      }
      this._updateURL(transition, newState);
      transition.isActive = false;
      this.activeTransition = void 0;
      this.triggerEvent(this.currentRouteInfos, true, "didTransition", []);
      this.didTransition(this.currentRouteInfos);
      this.toInfos(transition, newState.routeInfos, true);
      this.routeDidChange(transition);
      log(this, transition.sequence, "TRANSITION COMPLETE.");
      return routeInfos[routeInfos.length - 1].route;
    } catch (e) {
      if (!isTransitionAborted(e)) {
        let infos = transition[STATE_SYMBOL].routeInfos;
        transition.trigger(true, "error", e, transition, infos[infos.length - 1].route);
        transition.abort();
      }
      throw e;
    }
  }
  /**
  @private
     Takes an Array of `RouteInfo`s, figures out which ones are
  exiting, entering, or changing contexts, and calls the
  proper route hooks.
     For example, consider the following tree of routes. Each route is
  followed by the URL segment it handles.
     ```
  |~index ("/")
  | |~posts ("/posts")
  | | |-showPost ("/:id")
  | | |-newPost ("/new")
  | | |-editPost ("/edit")
  | |~about ("/about/:id")
  ```
     Consider the following transitions:
     1. A URL transition to `/posts/1`.
     1. Triggers the `*model` callbacks on the
        `index`, `posts`, and `showPost` routes
     2. Triggers the `enter` callback on the same
     3. Triggers the `setup` callback on the same
  2. A direct transition to `newPost`
     1. Triggers the `exit` callback on `showPost`
     2. Triggers the `enter` callback on `newPost`
     3. Triggers the `setup` callback on `newPost`
  3. A direct transition to `about` with a specified
     context object
     1. Triggers the `exit` callback on `newPost`
        and `posts`
     2. Triggers the `serialize` callback on `about`
     3. Triggers the `enter` callback on `about`
     4. Triggers the `setup` callback on `about`
     @param {Router} transition
  @param {TransitionState} newState
  */
  setupContexts(newState, transition) {
    let partition = this.partitionRoutes(this.state, newState);
    let i, l, route;
    for (i = 0, l = partition.exited.length; i < l; i++) {
      route = partition.exited[i].route;
      delete route.context;
      if (route !== void 0) {
        if (route._internalReset !== void 0) {
          route._internalReset(true, transition);
        }
        if (route.exit !== void 0) {
          route.exit(transition);
        }
      }
    }
    let oldState = this.oldState = this.state;
    this.state = newState;
    let currentRouteInfos = this.currentRouteInfos = partition.unchanged.slice();
    try {
      for (i = 0, l = partition.reset.length; i < l; i++) {
        route = partition.reset[i].route;
        if (route !== void 0) {
          if (route._internalReset !== void 0) {
            route._internalReset(false, transition);
          }
        }
      }
      for (i = 0, l = partition.updatedContext.length; i < l; i++) {
        this.routeEnteredOrUpdated(currentRouteInfos, partition.updatedContext[i], false, transition);
      }
      for (i = 0, l = partition.entered.length; i < l; i++) {
        this.routeEnteredOrUpdated(currentRouteInfos, partition.entered[i], true, transition);
      }
    } catch (e) {
      this.state = oldState;
      this.currentRouteInfos = oldState.routeInfos;
      throw e;
    }
    this.state.queryParams = this.finalizeQueryParamChange(currentRouteInfos, newState.queryParams, transition);
  }
  /**
  @private
     Fires queryParamsDidChange event
  */
  fireQueryParamDidChange(newState, queryParamChangelist) {
    if (queryParamChangelist) {
      this._changedQueryParams = queryParamChangelist.all;
      this.triggerEvent(newState.routeInfos, true, "queryParamsDidChange", [queryParamChangelist.changed, queryParamChangelist.all, queryParamChangelist.removed]);
      this._changedQueryParams = void 0;
    }
  }
  /**
  @private
     Helper method used by setupContexts. Handles errors or redirects
  that may happen in enter/setup.
  */
  routeEnteredOrUpdated(currentRouteInfos, routeInfo, enter, transition) {
    let route = routeInfo.route, context2 = routeInfo.context;
    function _routeEnteredOrUpdated(route2) {
      if (enter) {
        if (route2.enter !== void 0) {
          route2.enter(transition);
        }
      }
      throwIfAborted(transition);
      route2.context = context2;
      if (route2.contextDidChange !== void 0) {
        route2.contextDidChange();
      }
      if (route2.setup !== void 0) {
        route2.setup(context2, transition);
      }
      throwIfAborted(transition);
      currentRouteInfos.push(routeInfo);
      return route2;
    }
    if (route === void 0) {
      routeInfo.routePromise = routeInfo.routePromise.then(_routeEnteredOrUpdated);
    } else {
      _routeEnteredOrUpdated(route);
    }
    return true;
  }
  /**
  @private
     This function is called when transitioning from one URL to
  another to determine which routes are no longer active,
  which routes are newly active, and which routes remain
  active but have their context changed.
     Take a list of old routes and new routes and partition
  them into four buckets:
     * unchanged: the route was active in both the old and
    new URL, and its context remains the same
  * updated context: the route was active in both the
    old and new URL, but its context changed. The route's
    `setup` method, if any, will be called with the new
    context.
  * exited: the route was active in the old URL, but is
    no longer active.
  * entered: the route was not active in the old URL, but
    is now active.
     The PartitionedRoutes structure has four fields:
     * `updatedContext`: a list of `RouteInfo` objects that
    represent routes that remain active but have a changed
    context
  * `entered`: a list of `RouteInfo` objects that represent
    routes that are newly active
  * `exited`: a list of `RouteInfo` objects that are no
    longer active.
  * `unchanged`: a list of `RouteInfo` objects that remain active.
     @param {Array[InternalRouteInfo]} oldRoutes a list of the route
    information for the previous URL (or `[]` if this is the
    first handled transition)
  @param {Array[InternalRouteInfo]} newRoutes a list of the route
    information for the new URL
     @return {Partition}
  */
  partitionRoutes(oldState, newState) {
    let oldRouteInfos = oldState.routeInfos;
    let newRouteInfos = newState.routeInfos;
    let routes = {
      updatedContext: [],
      exited: [],
      entered: [],
      unchanged: [],
      reset: []
    };
    let routeChanged, contextChanged = false, i, l;
    for (i = 0, l = newRouteInfos.length; i < l; i++) {
      let oldRouteInfo = oldRouteInfos[i], newRouteInfo = newRouteInfos[i];
      if (!oldRouteInfo || oldRouteInfo.route !== newRouteInfo.route) {
        routeChanged = true;
      }
      if (routeChanged) {
        routes.entered.push(newRouteInfo);
        if (oldRouteInfo) {
          routes.exited.unshift(oldRouteInfo);
        }
      } else if (contextChanged || oldRouteInfo.context !== newRouteInfo.context) {
        contextChanged = true;
        routes.updatedContext.push(newRouteInfo);
      } else {
        routes.unchanged.push(oldRouteInfo);
      }
    }
    for (i = newRouteInfos.length, l = oldRouteInfos.length; i < l; i++) {
      routes.exited.unshift(oldRouteInfos[i]);
    }
    routes.reset = routes.updatedContext.slice();
    routes.reset.reverse();
    return routes;
  }
  _updateURL(transition, state) {
    let urlMethod = transition.urlMethod;
    if (!urlMethod) {
      return;
    }
    let {
      routeInfos
    } = state;
    let {
      name: routeName
    } = routeInfos[routeInfos.length - 1];
    let params = {};
    for (let i = routeInfos.length - 1; i >= 0; --i) {
      let routeInfo = routeInfos[i];
      merge(params, routeInfo.params);
      if (routeInfo.route.inaccessibleByURL) {
        urlMethod = null;
      }
    }
    if (urlMethod) {
      params.queryParams = transition._visibleQueryParams || state.queryParams;
      let url = this.recognizer.generate(routeName, params);
      let initial = transition.isCausedByInitialTransition;
      let replaceAndNotAborting = urlMethod === "replace" && !transition.isCausedByAbortingTransition;
      let isQueryParamsRefreshTransition = transition.queryParamsOnly && urlMethod === "replace";
      let replacingReplace = urlMethod === "replace" && transition.isCausedByAbortingReplaceTransition;
      if (initial || replaceAndNotAborting || isQueryParamsRefreshTransition || replacingReplace) {
        this.replaceURL(url);
      } else {
        this.updateURL(url);
      }
    }
  }
  finalizeQueryParamChange(resolvedHandlers, newQueryParams, transition) {
    for (let k in newQueryParams) {
      if (newQueryParams.hasOwnProperty(k) && newQueryParams[k] === null) {
        delete newQueryParams[k];
      }
    }
    let finalQueryParamsArray = [];
    this.triggerEvent(resolvedHandlers, true, "finalizeQueryParamChange", [newQueryParams, finalQueryParamsArray, transition]);
    if (transition) {
      transition._visibleQueryParams = {};
    }
    let finalQueryParams = {};
    for (let i = 0, len2 = finalQueryParamsArray.length; i < len2; ++i) {
      let qp = finalQueryParamsArray[i];
      finalQueryParams[qp.key] = qp.value;
      if (transition && qp.visible !== false) {
        transition._visibleQueryParams[qp.key] = qp.value;
      }
    }
    return finalQueryParams;
  }
  toReadOnlyInfos(newTransition, newState) {
    let oldRouteInfos = this.state.routeInfos;
    this.fromInfos(newTransition, oldRouteInfos);
    this.toInfos(newTransition, newState.routeInfos);
    this._lastQueryParams = newState.queryParams;
  }
  fromInfos(newTransition, oldRouteInfos) {
    if (newTransition !== void 0 && oldRouteInfos.length > 0) {
      let fromInfos = toReadOnlyRouteInfo(oldRouteInfos, Object.assign({}, this._lastQueryParams), {
        includeAttributes: true,
        localizeMapUpdates: false
      });
      newTransition.from = fromInfos[fromInfos.length - 1] || null;
    }
  }
  toInfos(newTransition, newRouteInfos, includeAttributes = false) {
    if (newTransition !== void 0 && newRouteInfos.length > 0) {
      let toInfos = toReadOnlyRouteInfo(newRouteInfos, Object.assign({}, newTransition[QUERY_PARAMS_SYMBOL]), {
        includeAttributes,
        localizeMapUpdates: false
      });
      newTransition.to = toInfos[toInfos.length - 1] || null;
    }
  }
  notifyExistingHandlers(newState, newTransition) {
    let oldRouteInfos = this.state.routeInfos, i, oldRouteInfoLen, oldHandler, newRouteInfo;
    oldRouteInfoLen = oldRouteInfos.length;
    for (i = 0; i < oldRouteInfoLen; i++) {
      oldHandler = oldRouteInfos[i];
      newRouteInfo = newState.routeInfos[i];
      if (!newRouteInfo || oldHandler.name !== newRouteInfo.name) {
        break;
      }
      if (!newRouteInfo.isResolved) ;
    }
    this.triggerEvent(oldRouteInfos, true, "willTransition", [newTransition]);
    this.routeWillChange(newTransition);
    this.willTransition(oldRouteInfos, newState.routeInfos, newTransition);
  }
  /**
    Clears the current and target route routes and triggers exit
    on each of them starting at the leaf and traversing up through
    its ancestors.
  */
  reset() {
    if (this.state) {
      forEach(this.state.routeInfos.slice().reverse(), function(routeInfo) {
        let route = routeInfo.route;
        if (route !== void 0) {
          if (route.exit !== void 0) {
            route.exit();
          }
        }
        return true;
      });
    }
    this.oldState = void 0;
    this.state = new TransitionState();
    this.currentRouteInfos = void 0;
  }
  /**
    let handler = routeInfo.handler;
    The entry point for handling a change to the URL (usually
    via the back and forward button).
       Returns an Array of handlers and the parameters associated
    with those parameters.
       @param {String} url a URL to process
       @return {Array} an Array of `[handler, parameter]` tuples
  */
  handleURL(url) {
    if (url.charAt(0) !== "/") {
      url = "/" + url;
    }
    return this.doTransition(url).method(null);
  }
  /**
    Transition into the specified named route.
       If necessary, trigger the exit callback on any routes
    that are no longer represented by the target route.
       @param {String} name the name of the route
  */
  transitionTo(name, ...contexts) {
    if (typeof name === "object") {
      contexts.push(name);
      return this.doTransition(void 0, contexts, false);
    }
    return this.doTransition(name, contexts);
  }
  intermediateTransitionTo(name, ...args) {
    return this.doTransition(name, args, true);
  }
  refresh(pivotRoute) {
    let previousTransition = this.activeTransition;
    let state = previousTransition ? previousTransition[STATE_SYMBOL] : this.state;
    let routeInfos = state.routeInfos;
    if (pivotRoute === void 0) {
      pivotRoute = routeInfos[0].route;
    }
    log(this, "Starting a refresh transition");
    let name = routeInfos[routeInfos.length - 1].name;
    let intent = new NamedTransitionIntent(this, name, pivotRoute, [], this._changedQueryParams || state.queryParams);
    let newTransition = this.transitionByIntent(intent, false);
    if (previousTransition && previousTransition.urlMethod === "replace") {
      newTransition.method(previousTransition.urlMethod);
    }
    return newTransition;
  }
  /**
    Identical to `transitionTo` except that the current URL will be replaced
    if possible.
       This method is intended primarily for use with `replaceState`.
       @param {String} name the name of the route
  */
  replaceWith(name) {
    return this.doTransition(name).method("replace");
  }
  /**
    Take a named route and context objects and generate a
    URL.
       @param {String} name the name of the route to generate
      a URL for
    @param {...Object} objects a list of objects to serialize
       @return {String} a URL
  */
  generate(routeName, ...args) {
    let partitionedArgs = extractQueryParams(args), suppliedParams = partitionedArgs[0], queryParams = partitionedArgs[1];
    let intent = new NamedTransitionIntent(this, routeName, void 0, suppliedParams);
    let state = intent.applyToState(this.state, false);
    let params = {};
    for (let i = 0, len2 = state.routeInfos.length; i < len2; ++i) {
      let routeInfo = state.routeInfos[i];
      let routeParams = routeInfo.serialize();
      merge(params, routeParams);
    }
    params.queryParams = queryParams;
    return this.recognizer.generate(routeName, params);
  }
  applyIntent(routeName, contexts) {
    let intent = new NamedTransitionIntent(this, routeName, void 0, contexts);
    let state = this.activeTransition && this.activeTransition[STATE_SYMBOL] || this.state;
    return intent.applyToState(state, false);
  }
  isActiveIntent(routeName, contexts, queryParams, _state) {
    let state = _state || this.state, targetRouteInfos = state.routeInfos, routeInfo, len2;
    if (!targetRouteInfos.length) {
      return false;
    }
    let targetHandler = targetRouteInfos[targetRouteInfos.length - 1].name;
    let recognizerHandlers = this.recognizer.handlersFor(targetHandler);
    let index = 0;
    for (len2 = recognizerHandlers.length; index < len2; ++index) {
      routeInfo = targetRouteInfos[index];
      if (routeInfo.name === routeName) {
        break;
      }
    }
    if (index === recognizerHandlers.length) {
      return false;
    }
    let testState = new TransitionState();
    testState.routeInfos = targetRouteInfos.slice(0, index + 1);
    recognizerHandlers = recognizerHandlers.slice(0, index + 1);
    let intent = new NamedTransitionIntent(this, targetHandler, void 0, contexts);
    let newState = intent.applyToHandlers(testState, recognizerHandlers, targetHandler, true, true);
    let routesEqual = routeInfosEqual(newState.routeInfos, testState.routeInfos);
    if (!queryParams || !routesEqual) {
      return routesEqual;
    }
    let activeQPsOnNewHandler = {};
    merge(activeQPsOnNewHandler, queryParams);
    let activeQueryParams = state.queryParams;
    for (let key in activeQueryParams) {
      if (activeQueryParams.hasOwnProperty(key) && activeQPsOnNewHandler.hasOwnProperty(key)) {
        activeQPsOnNewHandler[key] = activeQueryParams[key];
      }
    }
    return routesEqual && !getChangelist(activeQPsOnNewHandler, queryParams);
  }
  isActive(routeName, ...args) {
    let [contexts, queryParams] = extractQueryParams(args);
    return this.isActiveIntent(routeName, contexts, queryParams);
  }
  trigger(name, ...args) {
    this.triggerEvent(this.currentRouteInfos, false, name, args);
  }
};
function routeInfosEqual(routeInfos, otherRouteInfos) {
  if (routeInfos.length !== otherRouteInfos.length) {
    return false;
  }
  for (let i = 0, len2 = routeInfos.length; i < len2; ++i) {
    if (routeInfos[i] !== otherRouteInfos[i]) {
      return false;
    }
  }
  return true;
}
function routeInfosSameExceptQueryParams(routeInfos, otherRouteInfos) {
  if (routeInfos.length !== otherRouteInfos.length) {
    return false;
  }
  for (let i = 0, len2 = routeInfos.length; i < len2; ++i) {
    if (routeInfos[i].name !== otherRouteInfos[i].name) {
      return false;
    }
    if (!paramsEqual(routeInfos[i].params, otherRouteInfos[i].params)) {
      return false;
    }
  }
  return true;
}
function paramsEqual(params, otherParams) {
  if (params === otherParams) {
    return true;
  }
  if (!params || !otherParams) {
    return false;
  }
  let keys = Object.keys(params);
  let otherKeys = Object.keys(otherParams);
  if (keys.length !== otherKeys.length) {
    return false;
  }
  for (let i = 0, len2 = keys.length; i < len2; ++i) {
    let key = keys[i];
    if (params[key] !== otherParams[key]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/router.js
function defaultDidTransition(infos) {
  updatePaths(this);
  this._cancelSlowTransitionTimer();
  this.notifyPropertyChange("url");
  this.set("currentState", this.targetState);
  if (true) {
    if (this.namespace.LOG_TRANSITIONS) {
      console.log(`Transitioned into '${EmberRouter._routePath(infos)}'`);
    }
  }
}
function defaultWillTransition(oldInfos, newInfos) {
  if (true) {
    if (this.namespace.LOG_TRANSITIONS) {
      console.log(`Preparing to transition from '${EmberRouter._routePath(oldInfos)}' to '${EmberRouter._routePath(newInfos)}'`);
    }
  }
}
var freezeRouteInfo;
if (true) {
  freezeRouteInfo = (transition) => {
    if (transition.from !== null && !Object.isFrozen(transition.from)) {
      Object.freeze(transition.from);
    }
    if (transition.to !== null && !Object.isFrozen(transition.to)) {
      Object.freeze(transition.to);
    }
  };
}
function K() {
  return this;
}
var {
  slice: slice2
} = Array.prototype;
var EmberRouter = class _EmberRouter extends EmberObject.extend(Evented) {
  /**
   Represents the URL of the root of the application, often '/'. This prefix is
    assumed on all routes defined on this router.
     @property rootURL
    @default '/'
    @public
  */
  // Set with reopen to allow overriding via extend
  /**
   The `location` property determines the type of URL's that your
    application will use.
     The following location types are currently available:
     * `history` - use the browser's history API to make the URLs look just like any standard URL
    * `hash` - use `#` to separate the server part of the URL from the Ember part: `/blog/#/posts/new`
    * `none` - do not store the Ember URL in the actual browser URL (mainly used for testing)
    * `auto` - use the best option based on browser capabilities: `history` if possible, then `hash` if possible, otherwise `none`
     This value is defaulted to `history` by the `locationType` setting of `/config/environment.js`
     @property location
    @default 'hash'
    @see {Location}
    @public
  */
  // Set with reopen to allow overriding via extend
  _routerMicrolib;
  _didSetupRouter = false;
  _initialTransitionStarted = false;
  currentURL = null;
  currentRouteName = null;
  currentPath = null;
  currentRoute = null;
  _qpCache = /* @__PURE__ */ Object.create(null);
  // Set of QueryParam['urlKey']
  _qpUpdates = /* @__PURE__ */ new Set();
  _queuedQPChanges = {};
  _bucketCache;
  _toplevelView = null;
  _handledErrors = /* @__PURE__ */ new Set();
  _engineInstances = /* @__PURE__ */ Object.create(null);
  _engineInfoByRoute = /* @__PURE__ */ Object.create(null);
  _routerService;
  _slowTransitionTimer = null;
  namespace;
  // Begin Evented
  // End Evented
  // Set with reopenClass
  static dslCallbacks;
  /**
    The `Router.map` function allows you to define mappings from URLs to routes
    in your application. These mappings are defined within the
    supplied callback function using `this.route`.
     The first parameter is the name of the route which is used by default as the
    path name as well.
     The second parameter is the optional options hash. Available options are:
       * `path`: allows you to provide your own path as well as mark dynamic
        segments.
      * `resetNamespace`: false by default; when nesting routes, ember will
        combine the route names to form the fully-qualified route name, which is
        used with `{{link-to}}` or manually transitioning to routes. Setting
        `resetNamespace: true` will cause the route not to inherit from its
        parent route's names. This is handy for preventing extremely long route names.
        Keep in mind that the actual URL path behavior is still retained.
     The third parameter is a function, which can be used to nest routes.
    Nested routes, by default, will have the parent route tree's route name and
    path prepended to it's own.
     ```app/router.js
    Router.map(function(){
      this.route('post', { path: '/post/:post_id' }, function() {
        this.route('edit');
        this.route('comments', { resetNamespace: true }, function() {
          this.route('new');
        });
      });
    });
    ```
     @method map
    @param callback
    @public
  */
  static map(callback) {
    if (!this.dslCallbacks) {
      this.dslCallbacks = [];
      this.reopenClass({
        dslCallbacks: this.dslCallbacks
      });
    }
    this.dslCallbacks.push(callback);
    return this;
  }
  static _routePath(routeInfos) {
    let path = [];
    function intersectionMatches(a1, a2) {
      for (let i = 0; i < a1.length; ++i) {
        if (a1[i] !== a2[i]) {
          return false;
        }
      }
      return true;
    }
    let name, nameParts, oldNameParts;
    for (let i = 1; i < routeInfos.length; i++) {
      let routeInfo = routeInfos[i];
      !routeInfo && assert("has routeInfo", routeInfo);
      name = routeInfo.name;
      nameParts = name.split(".");
      oldNameParts = slice2.call(path);
      while (oldNameParts.length) {
        if (intersectionMatches(oldNameParts, nameParts)) {
          break;
        }
        oldNameParts.shift();
      }
      path.push(...nameParts.slice(oldNameParts.length));
    }
    return path.join(".");
  }
  // Note that owner is actually required in this scenario, but since it is strictly
  // optional in other contexts trying to make it required here confuses TS.
  constructor(owner) {
    super(owner);
    !owner && assert("BUG: Missing owner", owner);
    this._resetQueuedQueryParameterChanges();
    this.namespace = owner.lookup("application:main");
    let bucketCache = owner.lookup(privatize`-bucket-cache:main`);
    !(bucketCache instanceof BucketCache) && assert("BUG: BucketCache should always be present", bucketCache instanceof BucketCache);
    this._bucketCache = bucketCache;
    let routerService = owner.lookup("service:router");
    !(routerService !== void 0) && assert("BUG: RouterService should always be present", routerService !== void 0);
    this._routerService = routerService;
  }
  _initRouterJs() {
    let location2 = get(this, "location");
    let router = this;
    const owner = getOwner3(this);
    !owner && assert("Router is unexpectedly missing an owner", owner);
    let seen = /* @__PURE__ */ Object.create(null);
    class PrivateRouter extends Router {
      getRoute(name) {
        let routeName = name;
        let routeOwner = owner;
        let engineInfo = router._engineInfoByRoute[routeName];
        if (engineInfo) {
          let engineInstance = router._getEngineInstance(engineInfo);
          routeOwner = engineInstance;
          routeName = engineInfo.localFullName;
        }
        let fullRouteName = `route:${routeName}`;
        !routeOwner && assert("Route is unexpectedly missing an owner", routeOwner);
        let route = routeOwner.lookup(fullRouteName);
        if (seen[name]) {
          !route && assert("seen routes should exist", route);
          return route;
        }
        seen[name] = true;
        if (!route) {
          let DefaultRoute = routeOwner.factoryFor("route:basic").class;
          routeOwner.register(fullRouteName, class extends DefaultRoute {
          });
          route = routeOwner.lookup(fullRouteName);
          if (true) {
            if (router.namespace.LOG_ACTIVE_GENERATION) {
              info(`generated -> ${fullRouteName}`, {
                fullName: fullRouteName
              });
            }
          }
        }
        route._setRouteName(routeName);
        if (engineInfo && !hasDefaultSerialize(route)) {
          throw new Error("Defining a custom serialize method on an Engine route is not supported.");
        }
        return route;
      }
      getSerializer(name) {
        let engineInfo = router._engineInfoByRoute[name];
        if (!engineInfo) {
          return;
        }
        return engineInfo.serializeMethod || defaultSerialize;
      }
      updateURL(path) {
        once(() => {
          location2.setURL(path);
          set(router, "currentURL", path);
        });
      }
      // TODO: merge into routeDidChange
      didTransition(infos) {
        !(router.didTransition === defaultDidTransition) && assert('You attempted to override the "didTransition" method which has been deprecated. Please inject the router service and listen to the "routeDidChange" event.', router.didTransition === defaultDidTransition);
        router.didTransition(infos);
      }
      // TODO: merge into routeWillChange
      willTransition(oldInfos, newInfos) {
        !(router.willTransition === defaultWillTransition) && assert('You attempted to override the "willTransition" method which has been deprecated. Please inject the router service and listen to the "routeWillChange" event.', router.willTransition === defaultWillTransition);
        router.willTransition(oldInfos, newInfos);
      }
      triggerEvent(routeInfos, ignoreFailure, name, args) {
        return triggerEvent.bind(router)(routeInfos, ignoreFailure, name, args);
      }
      routeWillChange(transition) {
        router.trigger("routeWillChange", transition);
        if (true) {
          freezeRouteInfo(transition);
        }
        router._routerService.trigger("routeWillChange", transition);
        if (transition.isIntermediate) {
          router.set("currentRoute", transition.to);
        }
      }
      routeDidChange(transition) {
        router.set("currentRoute", transition.to);
        once(() => {
          router.trigger("routeDidChange", transition);
          if (true) {
            freezeRouteInfo(transition);
          }
          router._routerService.trigger("routeDidChange", transition);
        });
      }
      transitionDidError(error, transition) {
        if (error.wasAborted || transition.isAborted) {
          return logAbort(transition);
        } else {
          transition.trigger(false, "error", error.error, transition, error.route);
          if (router._isErrorHandled(error.error)) {
            transition.rollback();
            this.routeDidChange(transition);
            return error.error;
          } else {
            transition.abort();
            return error.error;
          }
        }
      }
      replaceURL(url) {
        if (location2.replaceURL) {
          let doReplaceURL = () => {
            location2.replaceURL(url);
            set(router, "currentURL", url);
          };
          once(doReplaceURL);
        } else {
          this.updateURL(url);
        }
      }
    }
    let routerMicrolib = this._routerMicrolib = new PrivateRouter();
    let dslCallbacks = this.constructor.dslCallbacks || [K];
    let dsl = this._buildDSL();
    dsl.route("application", {
      path: "/",
      resetNamespace: true,
      overrideNameAssertion: true
    }, function() {
      for (let i = 0; i < dslCallbacks.length; i++) {
        dslCallbacks[i].call(this);
      }
    });
    if (true) {
      if (this.namespace.LOG_TRANSITIONS_INTERNAL) {
        routerMicrolib.log = console.log.bind(console);
      }
    }
    routerMicrolib.map(dsl.generate());
  }
  _buildDSL() {
    let enableLoadingSubstates = this._hasModuleBasedResolver();
    let router = this;
    const owner = getOwner3(this);
    !owner && assert("Router is unexpectedly missing an owner", owner);
    let options = {
      enableLoadingSubstates,
      resolveRouteMap(name) {
        return owner.factoryFor(`route-map:${name}`);
      },
      addRouteForEngine(name, engineInfo) {
        if (!router._engineInfoByRoute[name]) {
          router._engineInfoByRoute[name] = engineInfo;
        }
      }
    };
    return new DSLImpl(null, options);
  }
  /*
    Resets all pending query parameter changes.
    Called after transitioning to a new route
    based on query parameter changes.
  */
  _resetQueuedQueryParameterChanges() {
    this._queuedQPChanges = {};
  }
  _hasModuleBasedResolver() {
    let owner = getOwner3(this);
    !owner && assert("Router is unexpectedly missing an owner", owner);
    let resolver = get(owner, "application.__registry__.resolver.moduleBasedResolver");
    return Boolean(resolver);
  }
  /**
    Initializes the current router instance and sets up the change handling
    event listeners used by the instances `location` implementation.
     A property named `initialURL` will be used to determine the initial URL.
    If no value is found `/` will be used.
     @method startRouting
    @private
  */
  startRouting() {
    if (this.setupRouter()) {
      let initialURL = get(this, "initialURL");
      if (initialURL === void 0) {
        initialURL = get(this, "location").getURL();
      }
      let initialTransition = this.handleURL(initialURL);
      if (initialTransition && initialTransition.error) {
        throw initialTransition.error;
      }
    }
  }
  setupRouter() {
    if (this._didSetupRouter) {
      return false;
    }
    this._didSetupRouter = true;
    this._setupLocation();
    let location2 = get(this, "location");
    if (get(location2, "cancelRouterSetup")) {
      return false;
    }
    this._initRouterJs();
    location2.onUpdateURL((url) => {
      this.handleURL(url);
    });
    return true;
  }
  _setOutlets() {
    if (this.isDestroying || this.isDestroyed) {
      return;
    }
    let routeInfos = this._routerMicrolib.currentRouteInfos;
    if (!routeInfos) {
      return;
    }
    let root = null;
    let parent = null;
    for (let routeInfo of routeInfos) {
      let route = routeInfo.route;
      let render = getRenderState(route);
      if (render) {
        let state = {
          render,
          outlets: {
            main: void 0
          }
        };
        if (parent) {
          parent.outlets.main = state;
        } else {
          root = state;
        }
        parent = state;
      } else {
        break;
      }
    }
    if (root === null) {
      return;
    }
    if (!this._toplevelView) {
      let owner = getOwner3(this);
      !owner && assert("Router is unexpectedly missing an owner", owner);
      let OutletView = owner.factoryFor("view:-outlet");
      !(OutletView !== void 0) && assert("[BUG] unexpectedly missing `view:-outlet`", OutletView !== void 0);
      let application = owner.lookup("application:main");
      !(application !== void 0) && assert("[BUG] unexpectedly missing `application:-main`", application !== void 0);
      let environment2 = owner.lookup("-environment:main");
      !(environment2 !== void 0) && assert("[BUG] unexpectedly missing `-environment:main`", environment2 !== void 0);
      let template = owner.lookup("template:-outlet");
      !(template !== void 0) && assert("[BUG] unexpectedly missing `template:-outlet`", template !== void 0);
      this._toplevelView = OutletView.create({
        environment: environment2,
        template,
        application
      });
      this._toplevelView.setOutletState(root);
      let instance = owner.lookup("-application-instance:main");
      if (instance) {
        instance.didCreateRootView(this._toplevelView);
      }
    } else {
      this._toplevelView.setOutletState(root);
    }
  }
  handleURL(url) {
    let _url = url.split(/#(.+)?/)[0];
    return this._doURLTransition("handleURL", _url);
  }
  _doURLTransition(routerJsMethod, url) {
    this._initialTransitionStarted = true;
    let transition = this._routerMicrolib[routerJsMethod](url || "/");
    didBeginTransition(transition, this);
    return transition;
  }
  /**
    Transition the application into another route. The route may
    be either a single route or route path:
     @method transitionTo
    @param {String} [name] the name of the route or a URL
    @param {...Object} models the model(s) or identifier(s) to be used while
      transitioning to the route.
    @param {Object} [options] optional hash with a queryParams property
      containing a mapping of query parameters
    @return {Transition} the transition object associated with this
      attempted transition
    @public
  */
  transitionTo(...args) {
    if (resemblesURL(args[0])) {
      !(!this.isDestroying && !this.isDestroyed) && assert(`A transition was attempted from '${this.currentRouteName}' to '${args[0]}' but the application instance has already been destroyed.`, !this.isDestroying && !this.isDestroyed);
      return this._doURLTransition("transitionTo", args[0]);
    }
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    !(!this.isDestroying && !this.isDestroyed) && assert(`A transition was attempted from '${this.currentRouteName}' to '${routeName}' but the application instance has already been destroyed.`, !this.isDestroying && !this.isDestroyed);
    return this._doTransition(routeName, models, queryParams);
  }
  intermediateTransitionTo(name, ...args) {
    this._routerMicrolib.intermediateTransitionTo(name, ...args);
    updatePaths(this);
    if (true) {
      let infos = this._routerMicrolib.currentRouteInfos;
      if (this.namespace.LOG_TRANSITIONS) {
        !infos && assert("expected infos to be set", infos);
        console.log(`Intermediate-transitioned into '${_EmberRouter._routePath(infos)}'`);
      }
    }
  }
  /**
    Similar to `transitionTo`, but instead of adding the destination to the browser's URL history,
    it replaces the entry for the current route.
    When the user clicks the "back" button in the browser, there will be fewer steps.
    This is most commonly used to manage redirects in a way that does not cause confusing additions
    to the user's browsing history.
     @method replaceWith
    @param {String} [name] the name of the route or a URL
    @param {...Object} models the model(s) or identifier(s) to be used while
      transitioning to the route.
    @param {Object} [options] optional hash with a queryParams property
      containing a mapping of query parameters
    @return {Transition} the transition object associated with this
      attempted transition
    @public
  */
  replaceWith(...args) {
    return this.transitionTo(...args).method("replace");
  }
  generate(name, ...args) {
    let url = this._routerMicrolib.generate(name, ...args);
    !(typeof this.location !== "string") && assert("expected non-string location", typeof this.location !== "string");
    return this.location.formatURL(url);
  }
  /**
    Determines if the supplied route is currently active.
     @method isActive
    @param routeName
    @return {Boolean}
    @private
  */
  isActive(routeName) {
    return this._routerMicrolib.isActive(routeName);
  }
  /**
    An alternative form of `isActive` that doesn't require
    manual concatenation of the arguments into a single
    array.
     @method isActiveIntent
    @param routeName
    @param models
    @param queryParams
    @return {Boolean}
    @private
    @since 1.7.0
  */
  isActiveIntent(routeName, models, queryParams) {
    return this.currentState.isActiveIntent(routeName, models, queryParams);
  }
  send(name, ...args) {
    this._routerMicrolib.trigger(name, ...args);
  }
  /**
    Does this router instance have the given route.
     @method hasRoute
    @return {Boolean}
    @private
  */
  hasRoute(route) {
    return this._routerMicrolib.hasRoute(route);
  }
  /**
    Resets the state of the router by clearing the current route
    handlers and deactivating them.
     @private
    @method reset
   */
  reset() {
    this._didSetupRouter = false;
    this._initialTransitionStarted = false;
    if (this._routerMicrolib) {
      this._routerMicrolib.reset();
    }
  }
  willDestroy() {
    if (this._toplevelView) {
      this._toplevelView.destroy();
      this._toplevelView = null;
    }
    super.willDestroy();
    this.reset();
    let instances = this._engineInstances;
    for (let name in instances) {
      let instanceMap = instances[name];
      !instanceMap && assert("has instanceMap", instanceMap);
      for (let id in instanceMap) {
        let instance = instanceMap[id];
        !instance && assert("has instance", instance);
        run(instance, "destroy");
      }
    }
  }
  /*
    Called when an active route's query parameter has changed.
    These changes are batched into a runloop run and trigger
    a single transition.
  */
  _activeQPChanged(queryParameterName, newValue) {
    this._queuedQPChanges[queryParameterName] = newValue;
    once(this, this._fireQueryParamTransition);
  }
  // The queryParameterName is QueryParam['urlKey']
  _updatingQPChanged(queryParameterName) {
    this._qpUpdates.add(queryParameterName);
  }
  /*
    Triggers a transition to a route based on query parameter changes.
    This is called once per runloop, to batch changes.
     e.g.
     if these methods are called in succession:
    this._activeQPChanged('foo', '10');
      // results in _queuedQPChanges = { foo: '10' }
    this._activeQPChanged('bar', false);
      // results in _queuedQPChanges = { foo: '10', bar: false }
     _queuedQPChanges will represent both of these changes
    and the transition using `transitionTo` will be triggered
    once.
  */
  _fireQueryParamTransition() {
    this.transitionTo({
      queryParams: this._queuedQPChanges
    });
    this._resetQueuedQueryParameterChanges();
  }
  _setupLocation() {
    let location2 = this.location;
    let rootURL = this.rootURL;
    let owner = getOwner3(this);
    !owner && assert("Router is unexpectedly missing an owner", owner);
    if ("string" === typeof location2) {
      let resolvedLocation = owner.lookup(`location:${location2}`);
      !resolvedLocation && assert(`Could not resolve a location class at 'location:${location2}'`, resolvedLocation);
      location2 = set(this, "location", resolvedLocation);
    }
    if (location2 !== null && typeof location2 === "object") {
      if (rootURL) {
        set(location2, "rootURL", rootURL);
      }
      if (typeof location2.initState === "function") {
        location2.initState();
      }
    }
  }
  /**
    Serializes the given query params according to their QP meta information.
     @private
    @method _serializeQueryParams
    @param {Arrray<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _serializeQueryParams(routeInfos, queryParams) {
    forEachQueryParam(this, routeInfos, queryParams, (key, value, qp) => {
      if (qp) {
        delete queryParams[key];
        queryParams[qp.urlKey] = qp.route.serializeQueryParam(value, qp.urlKey, qp.type);
      } else if (value === void 0) {
        return;
      } else {
        queryParams[key] = this._serializeQueryParam(value, typeOf(value));
      }
    });
  }
  /**
    Serializes the value of a query parameter based on a type
     @private
    @method _serializeQueryParam
    @param {Object} value
    @param {String} type
  */
  _serializeQueryParam(value, type) {
    if (value === null || value === void 0) {
      return value;
    } else if (type === "array") {
      return JSON.stringify(value);
    }
    return `${value}`;
  }
  /**
    Deserializes the given query params according to their QP meta information.
     @private
    @method _deserializeQueryParams
    @param {Array<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _deserializeQueryParams(routeInfos, queryParams) {
    forEachQueryParam(this, routeInfos, queryParams, (key, value, qp) => {
      if (qp) {
        delete queryParams[key];
        queryParams[qp.prop] = qp.route.deserializeQueryParam(value, qp.urlKey, qp.type);
      }
    });
  }
  /**
    Deserializes the value of a query parameter based on a default type
     @private
    @method _deserializeQueryParam
    @param {Object} value
    @param {String} defaultType
  */
  _deserializeQueryParam(value, defaultType) {
    if (value === null || value === void 0) {
      return value;
    } else if (defaultType === "boolean") {
      return value === "true";
    } else if (defaultType === "number") {
      return Number(value).valueOf();
    } else if (defaultType === "array") {
      return A(JSON.parse(value));
    }
    return value;
  }
  /**
    Removes (prunes) any query params with default values from the given QP
    object. Default values are determined from the QP meta information per key.
     @private
    @method _pruneDefaultQueryParamValues
    @param {Array<RouteInfo>} routeInfos
    @param {Object} queryParams
    @return {Void}
  */
  _pruneDefaultQueryParamValues(routeInfos, queryParams) {
    let qps = this._queryParamsFor(routeInfos);
    for (let key in queryParams) {
      let qp = qps.map[key];
      if (qp && qp.serializedDefaultValue === queryParams[key]) {
        delete queryParams[key];
      }
    }
  }
  _doTransition(_targetRouteName, models, _queryParams, _fromRouterService) {
    let targetRouteName = _targetRouteName || getActiveTargetName(this._routerMicrolib);
    !(Boolean(targetRouteName) && this._routerMicrolib.hasRoute(targetRouteName)) && assert(`The route ${targetRouteName} was not found`, Boolean(targetRouteName) && this._routerMicrolib.hasRoute(targetRouteName));
    this._initialTransitionStarted = true;
    let queryParams = {};
    this._processActiveTransitionQueryParams(targetRouteName, models, queryParams, _queryParams);
    Object.assign(queryParams, _queryParams);
    this._prepareQueryParams(targetRouteName, models, queryParams, Boolean(_fromRouterService));
    let transition = this._routerMicrolib.transitionTo(targetRouteName, ...models, {
      queryParams
    });
    didBeginTransition(transition, this);
    return transition;
  }
  _processActiveTransitionQueryParams(targetRouteName, models, queryParams, _queryParams) {
    if (!this._routerMicrolib.activeTransition) {
      return;
    }
    let unchangedQPs = {};
    let qpUpdates = this._qpUpdates;
    let params = getFullQueryParams(this, this._routerMicrolib.activeTransition[STATE_SYMBOL]);
    for (let key in params) {
      if (!qpUpdates.has(key)) {
        unchangedQPs[key] = params[key];
      }
    }
    this._fullyScopeQueryParams(targetRouteName, models, _queryParams);
    this._fullyScopeQueryParams(targetRouteName, models, unchangedQPs);
    Object.assign(queryParams, unchangedQPs);
  }
  /**
    Prepares the query params for a URL or Transition. Restores any undefined QP
    keys/values, serializes all values, and then prunes any default values.
     @private
    @method _prepareQueryParams
    @param {String} targetRouteName
    @param {Array<Object>} models
    @param {Object} queryParams
    @param {boolean} keepDefaultQueryParamValues
    @return {Void}
  */
  _prepareQueryParams(targetRouteName, models, queryParams, _fromRouterService) {
    let state = calculatePostTransitionState(this, targetRouteName, models);
    this._hydrateUnsuppliedQueryParams(state, queryParams, Boolean(_fromRouterService));
    this._serializeQueryParams(state.routeInfos, queryParams);
    if (!_fromRouterService) {
      this._pruneDefaultQueryParamValues(state.routeInfos, queryParams);
    }
  }
  /**
    Returns the meta information for the query params of a given route. This
    will be overridden to allow support for lazy routes.
     @private
    @method _getQPMeta
    @param {RouteInfo} routeInfo
    @return {Object}
  */
  _getQPMeta(routeInfo) {
    let route = routeInfo.route;
    return route && get(route, "_qp");
  }
  /**
    Returns a merged query params meta object for a given set of routeInfos.
    Useful for knowing what query params are available for a given route hierarchy.
     @private
    @method _queryParamsFor
    @param {Array<RouteInfo>} routeInfos
    @return {Object}
   */
  _queryParamsFor(routeInfos) {
    let routeInfoLength = routeInfos.length;
    let leafRouteName = routeInfos[routeInfoLength - 1].name;
    let cached = this._qpCache[leafRouteName];
    if (cached !== void 0) {
      return cached;
    }
    let shouldCache = true;
    let map3 = {};
    let qps = [];
    let qpsByUrlKey = true ? {} : null;
    let qpMeta;
    let urlKey;
    let qpOther;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        shouldCache = false;
        continue;
      }
      for (let qp of qpMeta.qps) {
        if (true) {
          urlKey = qp.urlKey;
          qpOther = qpsByUrlKey[urlKey];
          if (qpOther && qpOther.controllerName !== qp.controllerName) {
            assert(`You're not allowed to have more than one controller property map to the same query param key, but both \`${qpOther.scopedPropertyName}\` and \`${qp.scopedPropertyName}\` map to \`${urlKey}\`. You can fix this by mapping one of the controller properties to a different query param key via the \`as\` config option, e.g. \`${qpOther.prop}: { as: 'other-${qpOther.prop}' }\``, false);
          }
          qpsByUrlKey[urlKey] = qp;
        }
        qps.push(qp);
      }
      Object.assign(map3, qpMeta.map);
    }
    let finalQPMeta = {
      qps,
      map: map3
    };
    if (shouldCache) {
      this._qpCache[leafRouteName] = finalQPMeta;
    }
    return finalQPMeta;
  }
  /**
    Maps all query param keys to their fully scoped property name of the form
    `controllerName:propName`.
     @private
    @method _fullyScopeQueryParams
    @param {String} leafRouteName
    @param {Array<Object>} contexts
    @param {Object} queryParams
    @return {Void}
  */
  _fullyScopeQueryParams(leafRouteName, contexts, queryParams) {
    let state = calculatePostTransitionState(this, leafRouteName, contexts);
    let routeInfos = state.routeInfos;
    let qpMeta;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        continue;
      }
      for (let qp of qpMeta.qps) {
        let presentProp = qp.prop in queryParams && qp.prop || qp.scopedPropertyName in queryParams && qp.scopedPropertyName || qp.urlKey in queryParams && qp.urlKey;
        if (presentProp) {
          if (presentProp !== qp.scopedPropertyName) {
            queryParams[qp.scopedPropertyName] = queryParams[presentProp];
            delete queryParams[presentProp];
          }
        }
      }
    }
  }
  /**
    Hydrates (adds/restores) any query params that have pre-existing values into
    the given queryParams hash. This is what allows query params to be "sticky"
    and restore their last known values for their scope.
     @private
    @method _hydrateUnsuppliedQueryParams
    @param {TransitionState} state
    @param {Object} queryParams
    @return {Void}
  */
  _hydrateUnsuppliedQueryParams(state, queryParams, _fromRouterService) {
    let routeInfos = state.routeInfos;
    let appCache = this._bucketCache;
    let qpMeta;
    let qp;
    let presentProp;
    for (let routeInfo of routeInfos) {
      qpMeta = this._getQPMeta(routeInfo);
      if (!qpMeta) {
        continue;
      }
      for (let j = 0, qpLen = qpMeta.qps.length; j < qpLen; ++j) {
        qp = qpMeta.qps[j];
        !qp && assert("expected qp", qp);
        presentProp = qp.prop in queryParams && qp.prop || qp.scopedPropertyName in queryParams && qp.scopedPropertyName || qp.urlKey in queryParams && qp.urlKey;
        !(function() {
          if (qp.urlKey === presentProp || qp.scopedPropertyName === presentProp) {
            return true;
          }
          if (_fromRouterService && presentProp !== false && qp.urlKey !== qp.prop) {
            return false;
          }
          return true;
        })() && assert(`You passed the \`${presentProp}\` query parameter during a transition into ${qp.route.routeName}, please update to ${qp.urlKey}`, (function() {
          if (qp.urlKey === presentProp || qp.scopedPropertyName === presentProp) {
            return true;
          }
          if (_fromRouterService && presentProp !== false && qp.urlKey !== qp.prop) {
            return false;
          }
          return true;
        })());
        if (presentProp) {
          if (presentProp !== qp.scopedPropertyName) {
            queryParams[qp.scopedPropertyName] = queryParams[presentProp];
            delete queryParams[presentProp];
          }
        } else {
          let cacheKey = calculateCacheKey(qp.route.fullRouteName, qp.parts, state.params);
          !appCache && assert("ROUTER BUG: expected appCache to be defined. This is an internal bug, please open an issue on Github if you see this message!", appCache);
          queryParams[qp.scopedPropertyName] = appCache.lookup(cacheKey, qp.prop, qp.defaultValue);
        }
      }
    }
  }
  _scheduleLoadingEvent(transition, originRoute) {
    this._cancelSlowTransitionTimer();
    this._slowTransitionTimer = scheduleOnce("routerTransitions", this, this._handleSlowTransition, transition, originRoute);
  }
  currentState = null;
  targetState = null;
  _handleSlowTransition(transition, originRoute) {
    if (!this._routerMicrolib.activeTransition) {
      return;
    }
    let targetState = new RouterState(this, this._routerMicrolib, this._routerMicrolib.activeTransition[STATE_SYMBOL]);
    this.set("targetState", targetState);
    transition.trigger(true, "loading", transition, originRoute);
  }
  _cancelSlowTransitionTimer() {
    if (this._slowTransitionTimer) {
      cancel(this._slowTransitionTimer);
    }
    this._slowTransitionTimer = null;
  }
  // These three helper functions are used to ensure errors aren't
  // re-raised if they're handled in a route's error action.
  _markErrorAsHandled(error) {
    this._handledErrors.add(error);
  }
  _isErrorHandled(error) {
    return this._handledErrors.has(error);
  }
  _clearHandledError(error) {
    this._handledErrors.delete(error);
  }
  _getEngineInstance({
    name,
    instanceId,
    mountPoint
  }) {
    let engineInstances = this._engineInstances;
    let namedInstances = engineInstances[name];
    if (!namedInstances) {
      namedInstances = /* @__PURE__ */ Object.create(null);
      engineInstances[name] = namedInstances;
    }
    !namedInstances && assert("has namedInstances", namedInstances);
    let engineInstance = namedInstances[instanceId];
    if (!engineInstance) {
      let owner = getOwner3(this);
      !(owner instanceof EngineInstance) && assert("Expected router to have EngineInstance as owner", owner instanceof EngineInstance);
      !owner.hasRegistration(`engine:${name}`) && assert(`You attempted to mount the engine '${name}' in your router map, but the engine can not be found.`, owner.hasRegistration(`engine:${name}`));
      engineInstance = owner.buildChildEngineInstance(name, {
        routable: true,
        mountPoint
      });
      engineInstance.boot();
      namedInstances[instanceId] = engineInstance;
    }
    return engineInstance;
  }
  /**
    Handles updating the paths and notifying any listeners of the URL
    change.
     Triggers the router level `didTransition` hook.
     For example, to notify google analytics when the route changes,
    you could use this hook.  (Note: requires also including GA scripts, etc.)
     ```javascript
    import config from './config/environment';
    import EmberRouter from '@ember/routing/router';
    import { service } from '@ember/service';
     export default class Router extends EmberRouter {
      location = config.locationType;
       @service()
      router;
       didTransition() {
        super.didTransition(...arguments);
         ga('send', 'pageview', {
          page: this.router.currentURL,
          title: this.router.currentRouteName,
        });
      }
    }
    ```
     @method didTransition
    @private
    @since 1.2.0
  */
  // Set with reopen to allow overriding via extend
  /**
    Handles notifying any listeners of an impending URL
    change.
     Triggers the router level `willTransition` hook.
     @method willTransition
    @private
    @since 1.11.0
  */
  // Set with reopen to allow overriding via extend
  /**
   Represents the current URL.
     @property url
    @type {String}
    @private
  */
  // Set with reopen to allow overriding via extend
};
function forEachRouteAbove(routeInfos, callback) {
  for (let i = routeInfos.length - 1; i >= 0; --i) {
    let routeInfo = routeInfos[i];
    !routeInfo && assert("has routeInfo", routeInfo);
    let route = routeInfo.route;
    if (route === void 0) {
      continue;
    }
    if (callback(route, routeInfo) !== true) {
      return;
    }
  }
}
var defaultActionHandlers = {
  willResolveModel(_routeInfos, transition, originRoute) {
    this._scheduleLoadingEvent(transition, originRoute);
  },
  // Attempt to find an appropriate error route or substate to enter.
  error(routeInfos, error, transition) {
    let router = this;
    let routeInfoWithError = routeInfos[routeInfos.length - 1];
    forEachRouteAbove(routeInfos, (route, routeInfo) => {
      if (routeInfo !== routeInfoWithError) {
        let errorRouteName = findRouteStateName(route, "error");
        if (errorRouteName) {
          router._markErrorAsHandled(error);
          router.intermediateTransitionTo(errorRouteName, error);
          return false;
        }
      }
      let errorSubstateName = findRouteSubstateName(route, "error");
      if (errorSubstateName) {
        router._markErrorAsHandled(error);
        router.intermediateTransitionTo(errorSubstateName, error);
        return false;
      }
      return true;
    });
    logError(error, `Error while processing route: ${transition.targetName}`);
  },
  // Attempt to find an appropriate loading route or substate to enter.
  loading(routeInfos, transition) {
    let router = this;
    let routeInfoWithSlowLoading = routeInfos[routeInfos.length - 1];
    forEachRouteAbove(routeInfos, (route, routeInfo) => {
      if (routeInfo !== routeInfoWithSlowLoading) {
        let loadingRouteName = findRouteStateName(route, "loading");
        if (loadingRouteName) {
          router.intermediateTransitionTo(loadingRouteName);
          return false;
        }
      }
      let loadingSubstateName = findRouteSubstateName(route, "loading");
      if (loadingSubstateName) {
        router.intermediateTransitionTo(loadingSubstateName);
        return false;
      }
      return transition.pivotHandler !== route;
    });
  }
};
function logError(_error, initialMessage) {
  let errorArgs = [];
  let error;
  if (_error && typeof _error === "object" && typeof _error.errorThrown === "object") {
    error = _error.errorThrown;
  } else {
    error = _error;
  }
  if (initialMessage) {
    errorArgs.push(initialMessage);
  }
  if (error) {
    if (error.message) {
      errorArgs.push(error.message);
    }
    if (error.stack) {
      errorArgs.push(error.stack);
    }
    if (typeof error === "string") {
      errorArgs.push(error);
    }
  }
  console.error(...errorArgs);
}
function findRouteSubstateName(route, state) {
  let owner = getOwner3(route);
  !owner && assert("Route is unexpectedly missing an owner", owner);
  let {
    routeName,
    fullRouteName,
    _router: router
  } = route;
  let substateName = `${routeName}_${state}`;
  let substateNameFull = `${fullRouteName}_${state}`;
  return routeHasBeenDefined(owner, router, substateName, substateNameFull) ? substateNameFull : "";
}
function findRouteStateName(route, state) {
  let owner = getOwner3(route);
  !owner && assert("Route is unexpectedly missing an owner", owner);
  let {
    routeName,
    fullRouteName,
    _router: router
  } = route;
  let stateName = routeName === "application" ? state : `${routeName}.${state}`;
  let stateNameFull = fullRouteName === "application" ? state : `${fullRouteName}.${state}`;
  return routeHasBeenDefined(owner, router, stateName, stateNameFull) ? stateNameFull : "";
}
function routeHasBeenDefined(owner, router, localName, fullName) {
  let routerHasRoute = router.hasRoute(fullName);
  let ownerHasRoute = owner.factoryFor(`template:${localName}`) || owner.factoryFor(`route:${localName}`);
  return routerHasRoute && ownerHasRoute;
}
function triggerEvent(routeInfos, ignoreFailure, name, args) {
  if (!routeInfos) {
    if (ignoreFailure) {
      return;
    }
    throw new Error(`Can't trigger action '${name}' because your app hasn't finished transitioning into its first route. To trigger an action on destination routes during a transition, you can call \`.send()\` on the \`Transition\` object passed to the \`model/beforeModel/afterModel\` hooks.`);
  }
  let eventWasHandled = false;
  let routeInfo, handler, actionHandler;
  for (let i = routeInfos.length - 1; i >= 0; i--) {
    routeInfo = routeInfos[i];
    !routeInfo && assert("[BUG] Missing routeInfo", routeInfo);
    handler = routeInfo.route;
    actionHandler = handler && handler.actions && handler.actions[name];
    if (actionHandler) {
      if (actionHandler.apply(handler, args) === true) {
        eventWasHandled = true;
      } else {
        if (name === "error") {
          !handler && assert("[BUG] Missing handler", handler);
          handler._router._markErrorAsHandled(args[0]);
        }
        return;
      }
    }
  }
  let defaultHandler = defaultActionHandlers[name];
  if (defaultHandler) {
    defaultHandler.call(this, routeInfos, ...args);
    return;
  }
  if (!eventWasHandled && !ignoreFailure) {
    throw new Error(`Nothing handled the action '${name}'. If you did handle the action, this error can be caused by returning true from an action handler in a controller, causing the action to bubble.`);
  }
}
function calculatePostTransitionState(emberRouter, leafRouteName, contexts) {
  let state = emberRouter._routerMicrolib.applyIntent(leafRouteName, contexts);
  let {
    routeInfos,
    params
  } = state;
  for (let routeInfo of routeInfos) {
    if (!routeInfo.isResolved) {
      params[routeInfo.name] = routeInfo.serialize(routeInfo.context);
    } else {
      params[routeInfo.name] = routeInfo.params;
    }
  }
  return state;
}
function updatePaths(router) {
  let infos = router._routerMicrolib.currentRouteInfos;
  if (infos.length === 0) {
    return;
  }
  let path = EmberRouter._routePath(infos);
  let info2 = infos[infos.length - 1];
  !info2 && assert("expected info", info2);
  let currentRouteName = info2.name;
  let location2 = router.location;
  !(typeof location2 !== "string") && assert("expected location to not be a string", typeof location2 !== "string");
  let currentURL = location2.getURL();
  set(router, "currentPath", path);
  set(router, "currentRouteName", currentRouteName);
  set(router, "currentURL", currentURL);
}
function didBeginTransition(transition, router) {
  let routerState = new RouterState(router, router._routerMicrolib, transition[STATE_SYMBOL]);
  if (!router.currentState) {
    router.set("currentState", routerState);
  }
  router.set("targetState", routerState);
  transition.promise = transition.catch((error) => {
    if (router._isErrorHandled(error)) {
      router._clearHandledError(error);
    } else {
      throw error;
    }
  }, "Transition Error");
}
function forEachQueryParam(router, routeInfos, queryParams, callback) {
  let qpCache = router._queryParamsFor(routeInfos);
  for (let key in queryParams) {
    if (!Object.prototype.hasOwnProperty.call(queryParams, key)) {
      continue;
    }
    let value = queryParams[key];
    let qp = qpCache.map[key];
    callback(key, value, qp);
  }
}
EmberRouter.reopen({
  didTransition: defaultDidTransition,
  willTransition: defaultWillTransition,
  rootURL: "/",
  location: "hash",
  // FIXME: Does this need to be overrideable via extend?
  url: computed(function() {
    let location2 = get(this, "location");
    if (typeof location2 === "string") {
      return void 0;
    }
    return location2.getURL();
  })
});

export {
  hasDOM,
  window2 as window,
  environment,
  ENV,
  assert,
  inspect,
  warn2 as warn,
  debugFreeze,
  deprecate2 as deprecate,
  isObject,
  guidFor,
  getDebugName$1,
  teardownMandatorySetter,
  makeDictionary,
  isFactory,
  getOwner2 as getOwner,
  setOwner2 as setOwner,
  getFactoryFor,
  Registry,
  privatize,
  enumerableSymbol,
  meta,
  isProxy,
  isEmberArray,
  Cache,
  Version,
  objectAt,
  tagForProperty,
  tagForObject,
  CHAIN_PASS_THROUGH,
  finishLazyChains,
  getChainTagsForKey,
  isElementDescriptor,
  nativeDescDecorator,
  ComputedDescriptor,
  makeComputedDecorator,
  descriptorForProperty,
  descriptorForDecorator,
  expandProperties,
  PROPERTY_DID_CHANGE,
  computed,
  defineProperty,
  get,
  _getProp,
  LIBRARIES,
  inject,
  tracked,
  _getCurrentRunLoop,
  _backburner,
  run,
  join,
  bind,
  schedule,
  once,
  set,
  _setProp,
  setName,
  getName,
  NAMESPACES,
  NAMESPACES_BY_ID,
  addNamespace,
  removeNamespace,
  findNamespaces,
  findNamespace,
  processNamespace,
  processAllNamespaces,
  Mixin,
  RegistryProxyMixin,
  ActionHandler,
  contentFor,
  TargetActionSupport,
  RSVP,
  RSVP$1,
  EmberObject,
  action,
  decorateFieldV2,
  decorateMethodV2,
  initializeDeferredDecorator,
  Evented,
  FrameworkObject,
  getEngineParent,
  EngineInstance,
  typeOf,
  isArray6 as isArray,
  getOwner3 as getOwner2,
  BucketCache,
  extractRouteArgs,
  resemblesURL,
  shallowEqual,
  Controller,
  generateControllerFactory,
  Route,
  EmberRouter,
  triggerEvent
};
//# sourceMappingURL=chunk-ED7J5GAS.js.map
