import {
  $fp,
  $s0,
  $s1,
  $sp,
  $v0,
  ARG_SHIFT,
  ContentType,
  EMPTY_ARRAY,
  EMPTY_STRING_ARRAY,
  InternalComponentCapabilities,
  MACHINE_MASK,
  MAX_SIZE,
  StackImpl,
  TYPE_SIZE,
  assign,
  dict,
  enumerate,
  hasCapability,
  reverse
} from "./chunk-HJOPXKLZ.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/encoder/index.js
var InstructionEncoderImpl = class {
  constructor(buffer) {
    this.buffer = buffer, this.size = 0;
  }
  encode(type, machine, ...args) {
    if (type > TYPE_SIZE) throw new Error(`Opcode type over 8-bits. Got ${type}.`);
    let first = type | machine | arguments.length - 2 << ARG_SHIFT;
    this.buffer.push(first);
    for (const op of args) {
      if ("number" == typeof op && op > MAX_SIZE) throw new Error(`Operand over 32-bits. Got ${op}.`);
      this.buffer.push(op);
    }
    this.size = this.buffer.length;
  }
  patch(position, target) {
    if (-1 !== this.buffer[position + 1]) throw new Error("Trying to patch operand in populated slot instead of a reserved slot.");
    this.buffer[position + 1] = target;
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/wire-format/index.js
var opcodes = {
  Append: 1,
  TrustingAppend: 2,
  Comment: 3,
  Modifier: 4,
  StrictModifier: 5,
  Block: 6,
  StrictBlock: 7,
  Component: 8,
  OpenElement: 10,
  OpenElementWithSplat: 11,
  FlushElement: 12,
  CloseElement: 13,
  StaticAttr: 14,
  DynamicAttr: 15,
  ComponentAttr: 16,
  AttrSplat: 17,
  Yield: 18,
  DynamicArg: 20,
  StaticArg: 21,
  TrustingDynamicAttr: 22,
  TrustingComponentAttr: 23,
  StaticComponentAttr: 24,
  Debugger: 26,
  Undefined: 27,
  Call: 28,
  Concat: 29,
  GetSymbol: 30,
  GetLexicalSymbol: 32,
  GetStrictKeyword: 31,
  GetFreeAsComponentOrHelperHead: 35,
  GetFreeAsHelperHead: 37,
  GetFreeAsModifierHead: 38,
  GetFreeAsComponentHead: 39,
  InElement: 40,
  If: 41,
  Each: 42,
  Let: 44,
  WithDynamicVars: 45,
  InvokeComponent: 46,
  HasBlock: 48,
  HasBlockParams: 49,
  Curry: 50,
  Not: 51,
  IfInline: 52,
  GetDynamicVar: 53,
  Log: 54
};
function is(variant) {
  return function(value) {
    return Array.isArray(value) && value[0] === variant;
  };
}
var isFlushElement = is(opcodes.FlushElement);
var isGet = is(opcodes.GetSymbol);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/opcode-compiler/index.js
var debugToString;
if (true) {
  let getFunctionName = (fn) => {
    let functionName = fn.name;
    if ("" === functionName) {
      let match = /function (\w+)\s*\(/u.exec(String(fn));
      functionName = match && match[1] || "";
    }
    return functionName.replace(/^bound /u, "");
  }, getObjectName = (obj) => {
    let name, className;
    return "function" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), "toString" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && // eslint-disable-next-line @typescript-eslint/no-base-to-string
    (name = obj.toString()), name && /<.*:ember\d+>/u.test(name) && className && "_" !== className[0] && className.length > 2 && "Class" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;
  }, getPrimitiveName = (value) => String(value);
  debugToString = (value) => "function" == typeof value ? getFunctionName(value) || "(unknown function)" : "object" == typeof value && null !== value ? getObjectName(value) || "(unknown object)" : getPrimitiveName(value);
}
var debugToString$1 = debugToString;
function encodeImmediate(num) {
  return (num |= 0) < 0 ? (function(num2) {
    return -536870913 & num2;
  })(num) : (function(num2) {
    return ~num2;
  })(num);
}
function makeResolutionTypeVerifier(typeToVerify) {
  return (opcode) => {
    if (!(function(opcode2) {
      return Array.isArray(opcode2) && 2 === opcode2.length;
    })(opcode)) return false;
    let type = opcode[0];
    return type === opcodes.GetStrictKeyword || type === opcodes.GetLexicalSymbol || type === typeToVerify;
  };
}
[1, -1].forEach((x) => {
  return num = encodeImmediate(x), (num |= 0) > -536870913 ? (function(num2) {
    return ~num2;
  })(num) : (function(num2) {
    return 536870912 | num2;
  })(num);
  var num;
});
var isGetFreeComponent = makeResolutionTypeVerifier(opcodes.GetFreeAsComponentHead);
var isGetFreeModifier = makeResolutionTypeVerifier(opcodes.GetFreeAsModifierHead);
var isGetFreeHelper = makeResolutionTypeVerifier(opcodes.GetFreeAsHelperHead);
var isGetFreeComponentOrHelper = makeResolutionTypeVerifier(opcodes.GetFreeAsComponentOrHelperHead);
function assertResolverInvariants(meta2) {
  if (true) {
    if (!meta2.symbols.upvars) throw new Error("Attempted to resolve a component, helper, or modifier, but no free vars were found");
    if (!meta2.owner) throw new Error("Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from");
  }
  return meta2;
}
function lookupBuiltInHelper(expr2, resolver, meta2, constants, type) {
  let {
    symbols: {
      upvars
    }
  } = assertResolverInvariants(meta2), name = upvars[expr2[1]], helper = resolver?.lookupBuiltInHelper?.(name) ?? null;
  if (null === helper)
    throw meta2.isStrictMode, new Error(`Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${// eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    meta2.symbols.upvars[expr2[1]] ?? "{unknown variable}"}`);
  return constants.helper(helper, name);
}
function labelOperand(value) {
  return {
    type: 1,
    value
  };
}
function stdlibOperand(value) {
  return {
    type: 5,
    value
  };
}
function symbolTableOperand(value) {
  return {
    type: 7,
    value
  };
}
function layoutOperand(value) {
  return {
    type: 8,
    value
  };
}
var Labels = class {
  label(name, index) {
    this.labels[name] = index;
  }
  target(at, target) {
    this.targets.push({
      at,
      target
    });
  }
  patch(heap) {
    let {
      targets,
      labels
    } = this;
    for (const {
      at,
      target
    } of targets) {
      let address = labels[target] - at;
      heap.getbyaddr(at), heap.setbyaddr(at, address);
    }
  }
  constructor() {
    this.labels = dict(), this.targets = [];
  }
};
function encodeOp(encoder, context, meta2, op) {
  let {
    program: {
      constants
    },
    resolver
  } = context;
  if ((function(op2) {
    return op2 < 1e3;
  })(op[0])) {
    let [type, ...operands] = op;
    encoder.push(constants, type, ...operands);
  } else switch (op[0]) {
    case 1e3:
      return encoder.label(op[1]);
    case 1001:
      return encoder.startLabels();
    case 1002:
      return encoder.stopLabels();
    case 1004:
      return (function(resolver2, constants2, meta3, [, expr2, then]) {
        isGetFreeComponent(expr2);
        let type = expr2[0];
        if (expr2[0] === opcodes.GetStrictKeyword) throw meta3.isStrictMode, new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${// eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
        meta3.symbols.upvars[expr2[1]] ?? "{unknown variable}"}`);
        if (type === opcodes.GetLexicalSymbol) {
          let {
            scopeValues,
            owner,
            symbols: {
              lexical
            }
          } = meta3, definition = scopeValues[expr2[1]];
          then(constants2.component(definition, owner, false, lexical?.at(expr2[1])));
        } else {
          let {
            symbols: {
              upvars
            },
            owner
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], definition = resolver2?.lookupComponent?.(name, owner) ?? null;
          if ("object" != typeof definition || null === definition) throw meta3.isStrictMode, new Error(`Attempted to resolve \`${name}\`, which was expected to be a component, but nothing was found.`);
          then(constants2.resolvedComponent(definition, name));
        }
      })(resolver, constants, meta2, op);
    case 1003:
      return (function(resolver2, constants2, meta3, [, expr2, then]) {
        isGetFreeModifier(expr2);
        let type = expr2[0];
        if (type === opcodes.GetLexicalSymbol) {
          let {
            scopeValues,
            symbols: {
              lexical
            }
          } = meta3, definition = scopeValues[expr2[1]];
          then(constants2.modifier(definition, lexical?.at(expr2[1]) ?? void 0));
        } else if (type === opcodes.GetStrictKeyword) {
          let {
            symbols: {
              upvars
            }
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], modifier = resolver2?.lookupBuiltInModifier?.(name) ?? null;
          if (null === modifier) throw meta3.isStrictMode, new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`);
          then(constants2.modifier(modifier, name));
        } else {
          let {
            symbols: {
              upvars
            },
            owner
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], modifier = resolver2?.lookupModifier?.(name, owner) ?? null;
          if (null === modifier) throw meta3.isStrictMode, new Error(`Attempted to resolve \`${name}\`, which was expected to be a modifier, but nothing was found.`);
          then(constants2.modifier(modifier));
        }
      })(resolver, constants, meta2, op);
    case 1005:
      return (function(resolver2, constants2, meta3, [, expr2, then]) {
        isGetFreeHelper(expr2);
        let type = expr2[0];
        if (type === opcodes.GetLexicalSymbol) {
          let {
            scopeValues
          } = meta3, definition = scopeValues[expr2[1]];
          then(constants2.helper(definition));
        } else if (type === opcodes.GetStrictKeyword) then(lookupBuiltInHelper(expr2, resolver2, meta3, constants2, "helper"));
        else {
          let {
            symbols: {
              upvars
            },
            owner
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], helper = resolver2?.lookupHelper?.(name, owner) ?? null;
          if (null === helper) throw meta3.isStrictMode, new Error(`Attempted to resolve \`${name}\`, which was expected to be a helper, but nothing was found.`);
          then(constants2.helper(helper, name));
        }
      })(resolver, constants, meta2, op);
    case 1007:
      return (function(resolver2, constants2, meta3, [, expr2, {
        ifComponent,
        ifHelper
      }]) {
        isGetFreeComponentOrHelper(expr2);
        let type = expr2[0];
        if (type === opcodes.GetLexicalSymbol) {
          let {
            scopeValues,
            owner,
            symbols: {
              lexical
            }
          } = meta3, definition = scopeValues[expr2[1]], component = constants2.component(definition, owner, true, lexical?.at(expr2[1]));
          if (null !== component) return void ifComponent(component);
          let helper = constants2.helper(definition, null, true);
          if (null === helper) throw meta3.isStrictMode, new Error(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
            `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString$1(definition)}`
          );
          ifHelper(helper);
        } else if (type === opcodes.GetStrictKeyword) ifHelper(lookupBuiltInHelper(expr2, resolver2, meta3, constants2, "component or helper"));
        else {
          let {
            symbols: {
              upvars
            },
            owner
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], definition = resolver2?.lookupComponent?.(name, owner) ?? null;
          if (null !== definition) ifComponent(constants2.resolvedComponent(definition, name));
          else {
            let helper = resolver2?.lookupHelper?.(name, owner) ?? null;
            if (null === helper) throw meta3.isStrictMode, new Error(`Attempted to resolve \`${name}\`, which was expected to be a component or helper, but nothing was found.`);
            ifHelper(constants2.helper(helper, name));
          }
        }
      })(resolver, constants, meta2, op);
    case 1008:
      return (function(resolver2, constants2, meta3, [, expr2, {
        ifComponent,
        ifHelper,
        ifValue
      }]) {
        isGetFreeComponentOrHelper(expr2);
        let type = expr2[0];
        if (type === opcodes.GetLexicalSymbol) {
          let {
            scopeValues,
            owner,
            symbols: {
              lexical
            }
          } = meta3, definition = scopeValues[expr2[1]];
          if ("function" != typeof definition && ("object" != typeof definition || null === definition))
            return void ifValue(constants2.value(definition));
          let component = constants2.component(definition, owner, true, lexical?.at(expr2[1]));
          if (null !== component) return void ifComponent(component);
          let helper = constants2.helper(definition, null, true);
          if (null !== helper) return void ifHelper(helper);
          ifValue(constants2.value(definition));
        } else if (type === opcodes.GetStrictKeyword) ifHelper(lookupBuiltInHelper(expr2, resolver2, meta3, constants2, "value"));
        else {
          let {
            symbols: {
              upvars
            },
            owner
          } = assertResolverInvariants(meta3), name = upvars[expr2[1]], definition = resolver2?.lookupComponent?.(name, owner) ?? null;
          if (null !== definition) return void ifComponent(constants2.resolvedComponent(definition, name));
          let helper = resolver2?.lookupHelper?.(name, owner) ?? null;
          null !== helper && ifHelper(constants2.helper(helper, name));
        }
      })(resolver, constants, meta2, op);
    case 1010: {
      let [, freeVar, andThen] = op;
      andThen(meta2.symbols.upvars[freeVar], meta2.moduleName);
      break;
    }
    case 1011: {
      let [, valueIndex, then] = op, value = meta2.scopeValues[valueIndex];
      then(constants.value(value));
      break;
    }
    default:
      throw new Error(`Unexpected high level opcode ${op[0]}`);
  }
}
var EncoderImpl = class {
  constructor(heap, meta2, stdlib) {
    this.heap = heap, this.meta = meta2, this.stdlib = stdlib, this.labelsStack = new StackImpl(), this.encoder = new InstructionEncoderImpl([]), this.errors = [], this.handle = heap.malloc();
  }
  error(error) {
    this.encoder.encode(30, 0), this.errors.push(error);
  }
  commit(size) {
    let handle = this.handle;
    return this.heap.pushMachine(5), this.heap.finishMalloc(handle, size), (list = this.errors) && list.length > 0 ? {
      errors: this.errors,
      handle
    } : handle;
    var list;
  }
  push(constants, type, ...args) {
    let {
      heap
    } = this;
    if (type > TYPE_SIZE) throw new Error(`Opcode type over 8-bits. Got ${type}.`);
    var value;
    let first = type | ((value = type) >= 0 && value <= 15 ? MACHINE_MASK : 0) | args.length << ARG_SHIFT;
    heap.pushRaw(first);
    for (let i = 0; i < args.length; i++) {
      let op = args[i];
      heap.pushRaw(this.operand(constants, op));
    }
  }
  operand(constants, operand) {
    if ("number" == typeof operand) return operand;
    if ("object" == typeof operand && null !== operand) {
      if (Array.isArray(operand)) return constants.array(operand);
      switch (operand.type) {
        case 1:
          return this.currentLabels.target(this.heap.offset, operand.value), -1;
        case 2:
          return constants.value(this.meta.isStrictMode);
        case 3:
        case 6:
        case 7:
        case 8:
          return constants.value(operand.value);
        case 4:
          return constants.value((block = operand.value, containing = this.meta, new CompilableTemplateImpl(block[0], containing, {
            parameters: block[1] || EMPTY_ARRAY
          })));
        case 5:
          return this.stdlib[operand.value];
      }
    }
    var block, containing;
    return constants.value(operand);
  }
  get currentLabels() {
    return this.labelsStack.current;
  }
  label(name) {
    this.currentLabels.label(name, this.heap.offset + 1);
  }
  startLabels() {
    this.labelsStack.push(new Labels());
  }
  stopLabels() {
    this.labelsStack.pop().patch(this.heap);
  }
};
function templateCompilationContext(evaluation, meta2) {
  return {
    evaluation,
    encoder: new EncoderImpl(evaluation.program.heap, meta2, evaluation.stdlib),
    meta: meta2
  };
}
var Compilers = class {
  add(name, func) {
    this.names[name] = this.funcs.push(func) - 1;
  }
  compile(op, sexp) {
    let name = sexp[0], index = this.names[name], func = this.funcs[index];
    sexp[0], func(op, sexp);
  }
  constructor() {
    this.names = {}, // eslint-disable-next-line @typescript-eslint/no-explicit-any
    this.funcs = [];
  }
};
var EXPRESSIONS = new Compilers();
function withPath(op, path) {
  if (void 0 !== path && 0 !== path.length) for (let i = 0; i < path.length; i++) op(22, path[i]);
}
function expr(op, expression) {
  Array.isArray(expression) ? EXPRESSIONS.compile(op, expression) : (PushPrimitive(op, expression), op(31));
}
function PushPrimitiveReference(op, value) {
  PushPrimitive(op, value), op(31);
}
function PushPrimitive(op, primitive) {
  let p = primitive;
  var value;
  "number" == typeof p && (p = (value = p) % 1 == 0 && value <= 536870911 && value >= -536870912 ? encodeImmediate(p) : /* @__PURE__ */ (function(value2) {
    return {
      type: 6,
      value: value2
    };
  })(p)), op(30, p);
}
function Call(op, handle, positional, named) {
  op(0), SimpleArgs(op, positional, named, false), op(16, handle), op(1), op(36, $v0);
}
function CallDynamic(op, positional, named, append) {
  op(0), SimpleArgs(op, positional, named, false), op(33, $fp, 1), op(107), append ? (op(36, $v0), append(), op(1), op(34, 1)) : (op(1), op(34, 1), op(36, $v0));
}
function Curry(op, type, definition, positional, named) {
  op(0), SimpleArgs(op, positional, named, false), op(86), expr(op, definition), op(77, type, {
    type: 2,
    value: void 0
  }), op(1), op(36, $v0);
}
function YieldBlock(op, to, positional) {
  SimpleArgs(op, positional, null, true), op(23, to), op(24), op(61), op(64), op(40), op(1);
}
function PushYieldableBlock(op, block) {
  !(function(op2, parameters) {
    null !== parameters ? op2(63, symbolTableOperand({
      parameters
    })) : PushPrimitive(op2, null);
  })(op, block && block[1]), op(62), PushCompilable(op, block);
}
function InvokeStaticBlock(op, block) {
  op(0), PushCompilable(op, block), op(61), op(2), op(1);
}
function InvokeStaticBlockWithStack(op, block, callerCount) {
  let parameters = block[1], calleeCount = parameters.length, count = Math.min(callerCount, calleeCount);
  if (0 !== count) {
    if (op(0), count) {
      op(39);
      for (let i = 0; i < count; i++) op(33, $fp, callerCount - i), op(19, parameters[i]);
    }
    PushCompilable(op, block), op(61), op(2), count && op(40), op(1);
  } else InvokeStaticBlock(op, block);
}
function PushCompilable(op, _block) {
  null === _block ? PushPrimitive(op, null) : op(28, {
    type: 4,
    value: _block
  });
}
function SimpleArgs(op, positional, named, atNames) {
  if (null === positional && null === named) return void op(83);
  let flags = CompilePositional(op, positional) << 4;
  atNames && (flags |= 8);
  let names = EMPTY_STRING_ARRAY;
  if (named) {
    names = named[0];
    let val = named[1];
    for (let i = 0; i < val.length; i++) expr(op, val[i]);
  }
  op(82, names, EMPTY_STRING_ARRAY, flags);
}
function CompilePositional(op, positional) {
  if (null === positional) return 0;
  for (let i = 0; i < positional.length; i++) expr(op, positional[i]);
  return positional.length;
}
function meta(layout) {
  let [, locals, upvars, lexicalSymbols] = layout.block;
  return {
    symbols: {
      locals,
      upvars,
      lexical: lexicalSymbols
    },
    scopeValues: layout.scope?.() ?? null,
    isStrictMode: layout.isStrictMode,
    moduleName: layout.moduleName,
    owner: layout.owner,
    size: locals.length
  };
}
EXPRESSIONS.add(opcodes.Concat, (op, [, parts]) => {
  for (let part of parts) expr(op, part);
  op(27, parts.length);
}), EXPRESSIONS.add(opcodes.Call, (op, [, expression, positional, named]) => {
  isGetFreeHelper(expression) ? op(1005, expression, (handle) => {
    Call(op, handle, positional, named);
  }) : (expr(op, expression), CallDynamic(op, positional, named));
}), EXPRESSIONS.add(opcodes.Curry, (op, [, expr2, type, positional, named]) => {
  Curry(op, type, expr2, positional, named);
}), EXPRESSIONS.add(opcodes.GetSymbol, (op, [, sym, path]) => {
  op(21, sym), withPath(op, path);
}), EXPRESSIONS.add(opcodes.GetLexicalSymbol, (op, [, sym, path]) => {
  op(1011, sym, (handle) => {
    op(29, handle), withPath(op, path);
  });
}), EXPRESSIONS.add(opcodes.GetStrictKeyword, (op, expr2) => {
  op(1010, expr2[1], () => {
    op(1005, expr2, (handle) => {
      Call(op, handle, null, null);
    });
  });
}), EXPRESSIONS.add(opcodes.GetFreeAsHelperHead, (op, expr2) => {
  op(1010, expr2[1], () => {
    op(1005, expr2, (handle) => {
      Call(op, handle, null, null);
    });
  });
}), EXPRESSIONS.add(opcodes.Undefined, (op) => PushPrimitiveReference(op, void 0)), EXPRESSIONS.add(opcodes.HasBlock, (op, [, block]) => {
  expr(op, block), op(25);
}), EXPRESSIONS.add(opcodes.HasBlockParams, (op, [, block]) => {
  expr(op, block), op(24), op(61), op(26);
}), EXPRESSIONS.add(opcodes.IfInline, (op, [, condition, truthy, falsy]) => {
  expr(op, falsy), expr(op, truthy), expr(op, condition), op(109);
}), EXPRESSIONS.add(opcodes.Not, (op, [, value]) => {
  expr(op, value), op(110);
}), EXPRESSIONS.add(opcodes.GetDynamicVar, (op, [, expression]) => {
  expr(op, expression), op(111);
}), EXPRESSIONS.add(opcodes.Log, (op, [, positional]) => {
  op(0), SimpleArgs(op, positional, null, false), op(112), op(1), op(36, $v0);
});
var NamedBlocksImpl = class _NamedBlocksImpl {
  constructor(blocks) {
    this.blocks = blocks, this.names = blocks ? Object.keys(blocks) : [];
  }
  get(name) {
    return this.blocks && this.blocks[name] || null;
  }
  has(name) {
    let {
      blocks
    } = this;
    return null !== blocks && name in blocks;
  }
  with(name, block) {
    let {
      blocks
    } = this;
    return new _NamedBlocksImpl(blocks ? assign({}, blocks, {
      [name]: block
    }) : {
      [name]: block
    });
  }
  get hasAny() {
    return null !== this.blocks;
  }
};
var EMPTY_BLOCKS = new NamedBlocksImpl(null);
function namedBlocks(blocks) {
  if (null === blocks) return EMPTY_BLOCKS;
  let out = dict(), [keys, values] = blocks;
  for (const [i, key] of enumerate(keys)) out[key] = values[i];
  return new NamedBlocksImpl(out);
}
function SwitchCases(op, bootstrap, matcher) {
  let clauses = [], count = 0;
  matcher(function(match, callback) {
    clauses.push({
      match,
      callback,
      label: "CLAUSE" + count++
    });
  }), // Emit the opcodes for the switch
  op(69, 1), bootstrap(), op(1001);
  for (let clause of clauses.slice(0, -1)) op(67, labelOperand(clause.label), clause.match);
  for (let i = clauses.length - 1; i >= 0; i--) {
    let clause = clauses[i];
    op(1e3, clause.label), op(34, 1), clause.callback(), // The first match is special: it is placed directly before the END
    // label, so no additional jump is needed at the end of it.
    0 !== i && op(4, labelOperand("END"));
  }
  op(1e3, "END"), op(1002), op(70);
}
function Replayable(op, args, body) {
  op(1001), op(0), // If the body invokes a block, its return will return to
  // END. Otherwise, the return in RETURN will return to END.
  op(6, labelOperand("ENDINITIAL")), // Start a new updating closure, remembering `count` elements
  // from the stack. Everything after this point, and before END,
  // will execute both initially and to update the block.
  // The enter and exit opcodes also track the area of the DOM
  // associated with this block. If an assertion inside the block
  // fails (for example, the test value changes from true to false
  // in an #if), the DOM is cleared and the program is re-executed,
  // restoring `count` elements to the stack and executing the
  // instructions between the enter and exit.
  op(69, args()), // Evaluate the body of the block. The body of the block may
  // return, which will jump execution to END during initial
  // execution, and exit the updating routine.
  body(), // All execution paths in the body should run the FINALLY once
  // they are done. It is executed both during initial execution
  // and during updating execution.
  op(1e3, "FINALLY"), // Finalize the DOM.
  op(70), // In initial execution, this is a noop: it returns to the
  // immediately following opcode. In updating execution, this
  // exits the updating routine.
  op(5), // Cleanup code for the block. Runs on initial execution
  // but not on updating.
  op(1e3, "ENDINITIAL"), op(1), op(1002);
}
function ReplayableIf(op, args, ifTrue, ifFalse) {
  return Replayable(op, args, () => {
    op(66, labelOperand("ELSE")), // Otherwise, execute the code associated with the true branch.
    ifTrue(), // We're done, so return. In the initial execution, this runs
    // the cleanup code. In the updating VM, it exits the updating
    // routine.
    op(4, labelOperand("FINALLY")), op(1e3, "ELSE"), // If the conditional is false, and code associatied ith the
    // false branch was provided, execute it. If there was no code
    // associated with the false branch, jumping to the else statement
    // has no other behavior.
    void 0 !== ifFalse && ifFalse();
  });
}
function InvokeComponent(op, component, _elementBlock, positional, named, _blocks) {
  let {
    compilable: compilable2,
    capabilities,
    handle
  } = component, elementBlock = _elementBlock ? [_elementBlock, []] : null, blocks = namedBlocks(_blocks);
  compilable2 ? (op(78, handle), (function(op2, {
    capabilities: capabilities2,
    layout,
    elementBlock: elementBlock2,
    positional: positional2,
    named: named2,
    blocks: blocks2
  }) {
    let {
      symbolTable
    } = layout;
    if (hasCapability(capabilities2, InternalComponentCapabilities.prepareArgs)) return void InvokeNonStaticComponent(op2, {
      capabilities: capabilities2,
      elementBlock: elementBlock2,
      positional: positional2,
      named: named2,
      atNames: true,
      blocks: blocks2,
      layout
    });
    op2(36, $s0), op2(33, $sp, 1), op2(35, $s0), op2(0);
    let {
      symbols
    } = symbolTable, blockSymbols = [], argSymbols = [], argNames = [], blockNames = blocks2.names;
    if (null !== elementBlock2) {
      let symbol = symbols.indexOf("&attrs");
      -1 !== symbol && (PushYieldableBlock(op2, elementBlock2), blockSymbols.push(symbol));
    }
    for (const name of blockNames) {
      let symbol = symbols.indexOf(`&${name}`);
      -1 !== symbol && (PushYieldableBlock(op2, blocks2.get(name)), blockSymbols.push(symbol));
    }
    if (hasCapability(capabilities2, InternalComponentCapabilities.createArgs)) {
      let flags = CompilePositional(op2, positional2) << 4;
      flags |= 8;
      let names = EMPTY_STRING_ARRAY;
      if (null !== named2) {
        names = named2[0];
        let val = named2[1];
        for (let i = 0; i < val.length; i++) {
          let symbol = symbols.indexOf(names[i]);
          expr(op2, val[i]), argSymbols.push(symbol);
        }
      }
      op2(82, names, EMPTY_STRING_ARRAY, flags), // And push an extra pop operation to remove the args before we begin setting
      // variables on the local context
      argSymbols.push(-1);
    } else if (null !== named2) {
      let names = named2[0], val = named2[1];
      for (let i = 0; i < val.length; i++) {
        let name = names[i], symbol = symbols.indexOf(name);
        -1 !== symbol && (expr(op2, val[i]), argSymbols.push(symbol), argNames.push(name));
      }
    }
    op2(97, $s0), hasCapability(capabilities2, InternalComponentCapabilities.dynamicScope) && op2(59), hasCapability(capabilities2, InternalComponentCapabilities.createInstance) && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    op2(87, 0 | blocks2.has("default")), op2(88, $s0), hasCapability(capabilities2, InternalComponentCapabilities.createArgs) ? op2(90, $s0) : op2(90, $s0, argNames), // Setup the new root scope for the component
    op2(37, symbols.length + 1, Object.keys(blocks2).length > 0 ? 1 : 0), // Pop the self reference off the stack and set it to the symbol for `this`
    // in the new scope. This is why all subsequent symbols are increased by one.
    op2(19, 0);
    for (const symbol of reverse(argSymbols))
      -1 === symbol ? (
        // The expression was not bound to a local symbol, it was only pushed to be
        // used with VM args in the javascript side
        op2(34, 1)
      ) : op2(19, symbol + 1);
    null !== positional2 && op2(34, positional2.length);
    for (const symbol of reverse(blockSymbols)) op2(20, symbol + 1);
    op2(28, layoutOperand(layout)), op2(61), op2(2), op2(100, $s0), op2(1), op2(40), hasCapability(capabilities2, InternalComponentCapabilities.dynamicScope) && op2(60), op2(98), op2(35, $s0);
  })(op, {
    capabilities,
    layout: compilable2,
    elementBlock,
    positional,
    named,
    blocks
  })) : (op(78, handle), InvokeNonStaticComponent(op, {
    capabilities,
    elementBlock,
    positional,
    named,
    atNames: true,
    blocks
  }));
}
function InvokeDynamicComponent(op, definition, _elementBlock, positional, named, _blocks, atNames, curried) {
  let elementBlock = _elementBlock ? [_elementBlock, []] : null, blocks = namedBlocks(_blocks);
  Replayable(op, () => (expr(op, definition), op(33, $sp, 0), 2), () => {
    op(66, labelOperand("ELSE")), curried ? op(81) : op(80, {
      type: 2,
      value: void 0
    }), op(79), InvokeNonStaticComponent(op, {
      capabilities: true,
      elementBlock,
      positional,
      named,
      atNames,
      blocks
    }), op(1e3, "ELSE");
  });
}
function InvokeNonStaticComponent(op, {
  capabilities,
  elementBlock,
  positional,
  named,
  atNames,
  blocks: namedBlocks2,
  layout
}) {
  let bindableBlocks = !!namedBlocks2, bindableAtNames = true === capabilities || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) || !(!named || 0 === named[0].length), blocks = namedBlocks2.with("attrs", elementBlock);
  op(36, $s0), op(33, $sp, 1), op(35, $s0), op(0), (function(op2, positional2, named2, blocks2, atNames2) {
    let blockNames = blocks2.names;
    for (const name of blockNames) PushYieldableBlock(op2, blocks2.get(name));
    let flags = CompilePositional(op2, positional2) << 4;
    atNames2 && (flags |= 8), blocks2.hasAny && (flags |= 7);
    let names = EMPTY_ARRAY;
    if (named2) {
      names = named2[0];
      let val = named2[1];
      for (let i = 0; i < val.length; i++) expr(op2, val[i]);
    }
    op2(82, names, blockNames, flags);
  })(op, positional, named, blocks, atNames), op(85, $s0), invokePreparedComponent(op, blocks.has("default"), bindableBlocks, bindableAtNames, () => {
    layout ? (op(63, symbolTableOperand(layout.symbolTable)), op(28, layoutOperand(layout)), op(61)) : op(92, $s0), op(95, $s0);
  }), op(35, $s0);
}
function invokePreparedComponent(op, hasBlock, bindableBlocks, bindableAtNames, populateLayout = null) {
  op(97, $s0), op(59), // eslint-disable-next-line @typescript-eslint/no-explicit-any
  op(87, 0 | hasBlock), // this has to run after createComponent to allow
  // for late-bound layouts, but a caller is free
  // to populate the layout earlier if it wants to
  // and do nothing here.
  populateLayout && populateLayout(), op(88, $s0), op(90, $s0), op(38, $s0), op(19, 0), bindableAtNames && op(17, $s0), bindableBlocks && op(18, $s0), op(34, 1), op(96, $s0), op(100, $s0), op(1), op(40), op(60), op(98);
}
var STATEMENTS = new Compilers();
var INFLATE_ATTR_TABLE = ["class", "id", "value", "name", "type", "style", "href"];
var INFLATE_TAG_TABLE = ["div", "span", "p", "a"];
function inflateTagName(tagName) {
  return "string" == typeof tagName ? tagName : INFLATE_TAG_TABLE[tagName];
}
function inflateAttrName(attrName) {
  return "string" == typeof attrName ? attrName : INFLATE_ATTR_TABLE[attrName];
}
function hashToArgs(hash) {
  return null === hash ? null : [hash[0].map((key) => `@${key}`), hash[1]];
}
STATEMENTS.add(opcodes.Comment, (op, sexp) => op(42, sexp[1])), STATEMENTS.add(opcodes.CloseElement, (op) => op(55)), STATEMENTS.add(opcodes.FlushElement, (op) => op(54)), STATEMENTS.add(opcodes.Modifier, (op, [, expression, positional, named]) => {
  isGetFreeModifier(expression) ? op(1003, expression, (handle) => {
    op(0), SimpleArgs(op, positional, named, false), op(57, handle), op(1);
  }) : (expr(op, expression), op(0), SimpleArgs(op, positional, named, false), op(33, $fp, 1), op(108), op(1));
}), STATEMENTS.add(opcodes.StaticAttr, (op, [, name, value, namespace]) => {
  op(51, inflateAttrName(name), value, namespace ?? null);
}), STATEMENTS.add(opcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {
  op(105, inflateAttrName(name), value, namespace ?? null);
}), STATEMENTS.add(opcodes.DynamicAttr, (op, [, name, value, namespace]) => {
  expr(op, value), op(52, inflateAttrName(name), false, namespace ?? null);
}), STATEMENTS.add(opcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {
  expr(op, value), op(52, inflateAttrName(name), true, namespace ?? null);
}), STATEMENTS.add(opcodes.ComponentAttr, (op, [, name, value, namespace]) => {
  expr(op, value), op(53, inflateAttrName(name), false, namespace ?? null);
}), STATEMENTS.add(opcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {
  expr(op, value), op(53, inflateAttrName(name), true, namespace ?? null);
}), STATEMENTS.add(opcodes.OpenElement, (op, [, tag]) => {
  op(48, inflateTagName(tag));
}), STATEMENTS.add(opcodes.OpenElementWithSplat, (op, [, tag]) => {
  op(89), op(48, inflateTagName(tag));
}), STATEMENTS.add(opcodes.Component, (op, [, expr2, elementBlock, named, blocks]) => {
  isGetFreeComponent(expr2) ? op(1004, expr2, (component) => {
    InvokeComponent(op, component, elementBlock, null, named, blocks);
  }) : (
    // otherwise, the component name was an expression, so resolve the expression
    // and invoke it as a dynamic component
    InvokeDynamicComponent(op, expr2, elementBlock, null, named, blocks, true, true)
  );
}), STATEMENTS.add(opcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params)), STATEMENTS.add(opcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null)), STATEMENTS.add(opcodes.Debugger, (op, [, locals, upvars, lexical]) => {
  op(103, /* @__PURE__ */ (function(locals2, upvars2, lexical2) {
    return {
      type: 3,
      value: {
        locals: locals2,
        upvars: upvars2,
        lexical: lexical2
      }
    };
  })(locals, upvars, lexical));
}), STATEMENTS.add(opcodes.Append, (op, [, value]) => {
  if (Array.isArray(value)) {
    if (isGetFreeComponentOrHelper(value)) op(1008, value, {
      ifComponent(component) {
        InvokeComponent(op, component, null, null, null, null);
      },
      ifHelper(handle) {
        op(0), Call(op, handle, null, null), op(3, stdlibOperand("cautious-non-dynamic-append")), op(1);
      },
      ifValue(handle) {
        op(0), op(29, handle), op(3, stdlibOperand("cautious-non-dynamic-append")), op(1);
      }
    });
    else if (value[0] === opcodes.Call) {
      let [, expression, positional, named] = value;
      isGetFreeComponentOrHelper(expression) ? op(1007, expression, {
        ifComponent(component) {
          InvokeComponent(op, component, null, positional, hashToArgs(named), null);
        },
        ifHelper(handle) {
          op(0), Call(op, handle, positional, named), op(3, stdlibOperand("cautious-non-dynamic-append")), op(1);
        }
      }) : SwitchCases(op, () => {
        expr(op, expression), op(106);
      }, (when) => {
        when(ContentType.Component, () => {
          op(81), op(79), InvokeNonStaticComponent(op, {
            capabilities: true,
            elementBlock: null,
            positional,
            named,
            atNames: false,
            blocks: namedBlocks(null)
          });
        }), when(ContentType.Helper, () => {
          CallDynamic(op, positional, named, () => {
            op(3, stdlibOperand("cautious-non-dynamic-append"));
          });
        });
      });
    } else op(0), expr(op, value), op(3, stdlibOperand("cautious-append")), op(1);
  } else op(41, null == value ? "" : String(value));
}), STATEMENTS.add(opcodes.TrustingAppend, (op, [, value]) => {
  Array.isArray(value) ? (op(0), expr(op, value), op(3, stdlibOperand("trusting-append")), op(1)) : op(41, null == value ? "" : String(value));
}), STATEMENTS.add(opcodes.Block, (op, [, expr2, positional, named, blocks]) => {
  isGetFreeComponent(expr2) ? op(1004, expr2, (component) => {
    InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);
  }) : InvokeDynamicComponent(op, expr2, null, positional, named, blocks, false, false);
}), STATEMENTS.add(opcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {
  ReplayableIf(op, () => (expr(op, guid), void 0 === insertBefore ? PushPrimitiveReference(op, void 0) : expr(op, insertBefore), expr(op, destination), op(33, $sp, 0), 4), () => {
    op(50), InvokeStaticBlock(op, block), op(56);
  });
}), STATEMENTS.add(opcodes.If, (op, [, condition, block, inverse]) => ReplayableIf(op, () => (expr(op, condition), op(71), 1), () => {
  InvokeStaticBlock(op, block);
}, inverse ? () => {
  InvokeStaticBlock(op, inverse);
} : void 0)), STATEMENTS.add(opcodes.Each, (op, [, value, key, block, inverse]) => Replayable(op, () => (key ? expr(op, key) : PushPrimitiveReference(op, null), expr(op, value), 2), () => {
  op(72, labelOperand("BODY"), labelOperand("ELSE")), op(0), op(33, $fp, 1), op(6, labelOperand("ITER")), op(1e3, "ITER"), op(74, labelOperand("BREAK")), op(1e3, "BODY"), InvokeStaticBlockWithStack(op, block, 2), op(34, 2), op(4, labelOperand("FINALLY")), op(1e3, "BREAK"), op(1), op(73), op(4, labelOperand("FINALLY")), op(1e3, "ELSE"), inverse && InvokeStaticBlock(op, inverse);
})), STATEMENTS.add(opcodes.Let, (op, [, positional, block]) => {
  InvokeStaticBlockWithStack(op, block, CompilePositional(op, positional));
}), STATEMENTS.add(opcodes.WithDynamicVars, (op, [, named, block]) => {
  if (named) {
    let [names, expressions] = named;
    CompilePositional(op, expressions), (function(op2, names2, block2) {
      op2(59), op2(58, names2), block2(), op2(60);
    })(op, names, () => {
      InvokeStaticBlock(op, block);
    });
  } else InvokeStaticBlock(op, block);
}), STATEMENTS.add(opcodes.InvokeComponent, (op, [, expr2, positional, named, blocks]) => {
  isGetFreeComponent(expr2) ? op(1004, expr2, (component) => {
    InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);
  }) : InvokeDynamicComponent(op, expr2, null, positional, named, blocks, false, false);
});
var CompilableTemplateImpl = class {
  constructor(statements, meta2, symbolTable, moduleName = "plain block") {
    this.statements = statements, this.meta = meta2, this.symbolTable = symbolTable, this.moduleName = moduleName, this.compiled = null;
  }
  // Part of CompilableTemplate
  compile(context) {
    return (function(compilable2, context2) {
      if (null !== compilable2.compiled) return compilable2.compiled;
      compilable2.compiled = -1;
      let {
        statements,
        meta: meta2
      } = compilable2, result = compileStatements(statements, meta2, context2);
      return compilable2.compiled = result, result;
    })(this, context);
  }
};
function compilable(layout, moduleName) {
  let [statements, symbols] = layout.block;
  return new CompilableTemplateImpl(statements, meta(layout), {
    symbols
  }, moduleName);
}
function compileStatements(statements, meta2, syntaxContext) {
  let sCompiler = STATEMENTS, context = templateCompilationContext(syntaxContext, meta2), {
    encoder,
    evaluation
  } = context;
  function pushOp(...op) {
    encodeOp(encoder, evaluation, meta2, op);
  }
  for (const statement of statements) sCompiler.compile(pushOp, statement);
  return context.encoder.commit(meta2.size);
}
var StdLib = class {
  constructor(main, trustingGuardedAppend, cautiousGuardedAppend, trustingNonDynamicAppend, cautiousNonDynamicAppend) {
    this.main = main, this.trustingGuardedAppend = trustingGuardedAppend, this.cautiousGuardedAppend = cautiousGuardedAppend, this.trustingNonDynamicAppend = trustingNonDynamicAppend, this.cautiousNonDynamicAppend = cautiousNonDynamicAppend;
  }
  get "trusting-append"() {
    return this.trustingGuardedAppend;
  }
  get "cautious-append"() {
    return this.cautiousGuardedAppend;
  }
  get "trusting-non-dynamic-append"() {
    return this.trustingNonDynamicAppend;
  }
  get "cautious-non-dynamic-append"() {
    return this.cautiousNonDynamicAppend;
  }
  getAppend(trusting) {
    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;
  }
};
function StdAppend(op, trusting, nonDynamicAppend) {
  SwitchCases(op, () => op(76), (when) => {
    when(ContentType.String, () => {
      trusting ? (op(68), op(43)) : op(47);
    }), "number" == typeof nonDynamicAppend ? (when(ContentType.Component, () => {
      op(81), op(79), (function(op2) {
        op2(36, $s0), op2(33, $sp, 1), op2(35, $s0), op2(0), op2(83), op2(85, $s0), invokePreparedComponent(op2, false, false, true, () => {
          op2(92, $s0), op2(95, $s0);
        }), op2(35, $s0);
      })(op);
    }), when(ContentType.Helper, () => {
      CallDynamic(op, null, null, () => {
        op(3, nonDynamicAppend);
      });
    })) : (
      // when non-dynamic, we can no longer call the value (potentially because we've already called it)
      // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.
      (when(ContentType.Component, () => {
        op(47);
      }), when(ContentType.Helper, () => {
        op(47);
      }))
    ), when(ContentType.SafeString, () => {
      op(68), op(44);
    }), when(ContentType.Fragment, () => {
      op(68), op(45);
    }), when(ContentType.Node, () => {
      op(68), op(46);
    });
  });
}
function compileStd(context) {
  let mainHandle = build(context, (op) => (function(op2) {
    op2(75, $s0), invokePreparedComponent(op2, false, false, true);
  })(op)), trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null)), cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null)), trustingGuardedDynamicAppend = build(context, (op) => StdAppend(op, true, trustingGuardedNonDynamicAppend)), cautiousGuardedDynamicAppend = build(context, (op) => StdAppend(op, false, cautiousGuardedNonDynamicAppend));
  return new StdLib(mainHandle, trustingGuardedDynamicAppend, cautiousGuardedDynamicAppend, trustingGuardedNonDynamicAppend, cautiousGuardedNonDynamicAppend);
}
var STDLIB_META = {
  symbols: {
    locals: null,
    upvars: null
  },
  moduleName: "stdlib",
  // TODO: ??
  scopeValues: null,
  isStrictMode: true,
  owner: null,
  size: 0
};
function build(evaluation, builder) {
  let encoder = new EncoderImpl(evaluation.program.heap, STDLIB_META);
  builder(function(...op) {
    encodeOp(encoder, evaluation, STDLIB_META, op);
  });
  let result = encoder.commit(0);
  if ("number" != typeof result)
    throw new Error("Unexpected errors compiling std");
  return result;
}
var EvaluationContextImpl = class {
  constructor({
    constants,
    heap
  }, createOp, runtime) {
    this.constants = constants, this.heap = heap, this.resolver = runtime.resolver, this.createOp = createOp, this.env = runtime.env, this.program = runtime.program, this.stdlib = compileStd(this);
  }
};
var WrappedBuilder = class {
  constructor(layout, moduleName) {
    this.layout = layout, this.moduleName = moduleName, this.compiled = null;
    let {
      block
    } = layout, [, symbols] = block;
    symbols = symbols.slice();
    let attrsBlockIndex = symbols.indexOf("&attrs");
    this.attrsBlockNumber = -1 === attrsBlockIndex ? symbols.push("&attrs") : attrsBlockIndex + 1, this.symbolTable = {
      symbols
    }, this.meta = meta(layout);
  }
  compile(syntax) {
    if (null !== this.compiled) return this.compiled;
    let m = meta(this.layout), context = templateCompilationContext(syntax, m), {
      encoder,
      evaluation
    } = context;
    var op, layout, attrsBlockNumber;
    op = function(...op2) {
      encodeOp(encoder, evaluation, m, op2);
    }, layout = this.layout, attrsBlockNumber = this.attrsBlockNumber, op(1001), (function(op2, register, block) {
      op2(36, register), block(), op2(35, register);
    })(op, $s1, () => {
      op(91, $s0), op(31), op(33, $sp, 0);
    }), op(66, labelOperand("BODY")), op(36, $s1), op(89), op(49), op(99, $s0), YieldBlock(op, attrsBlockNumber, null), op(54), op(1e3, "BODY"), InvokeStaticBlock(op, [layout.block[0], []]), op(36, $s1), op(66, labelOperand("END")), op(55), op(1e3, "END"), op(35, $s1), op(1002);
    let handle = context.encoder.commit(m.size);
    return "number" != typeof handle || (this.compiled = handle), handle;
  }
};
var clientId = 0;
var templateCacheCounters = {
  cacheHit: 0,
  cacheMiss: 0
};
function templateFactory({
  id: templateId,
  moduleName,
  block,
  scope,
  isStrictMode
}) {
  let parsedBlock, id = templateId || "client-" + clientId++, ownerlessTemplate = null, templateCache = /* @__PURE__ */ new WeakMap(), factory = (owner) => {
    if (void 0 === parsedBlock && (parsedBlock = JSON.parse(block)), void 0 === owner) return null === ownerlessTemplate ? (templateCacheCounters.cacheMiss++, ownerlessTemplate = new TemplateImpl({
      id,
      block: parsedBlock,
      moduleName,
      owner: null,
      scope,
      isStrictMode
    })) : templateCacheCounters.cacheHit++, ownerlessTemplate;
    let result = templateCache.get(owner);
    return void 0 === result ? (templateCacheCounters.cacheMiss++, result = new TemplateImpl({
      id,
      block: parsedBlock,
      moduleName,
      owner,
      scope,
      isStrictMode
    }), templateCache.set(owner, result)) : templateCacheCounters.cacheHit++, result;
  };
  return factory.__id = id, factory.__meta = {
    moduleName
  }, factory;
}
var TemplateImpl = class {
  constructor(parsedLayout) {
    this.parsedLayout = parsedLayout, this.result = "ok", this.layout = null, this.wrappedLayout = null;
  }
  get moduleName() {
    return this.parsedLayout.moduleName;
  }
  get id() {
    return this.parsedLayout.id;
  }
  // TODO(template-refactors): This should be removed in the near future, it is
  // only being exposed for backwards compatibility
  get referrer() {
    return {
      moduleName: this.parsedLayout.moduleName,
      owner: this.parsedLayout.owner
    };
  }
  asLayout() {
    return this.layout ? this.layout : this.layout = compilable(assign({}, this.parsedLayout), this.moduleName);
  }
  asWrappedLayout() {
    return this.wrappedLayout ? this.wrappedLayout : this.wrappedLayout = new WrappedBuilder(assign({}, this.parsedLayout), this.moduleName);
  }
};

export {
  opcodes,
  EvaluationContextImpl,
  templateFactory
};
//# sourceMappingURL=chunk-MHMOQE3O.js.map
