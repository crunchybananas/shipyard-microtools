import "./chunk-SCN5F3LY.js";
import {
  setOwner
} from "./chunk-SNOZTKEA.js";
import "./chunk-QF4YHKGU.js";
import "./chunk-ED7J5GAS.js";
import "./chunk-2RJSWCLB.js";
import "./chunk-RS7R57CN.js";
import "./chunk-MHMOQE3O.js";
import {
  destroy,
  modifierCapabilities,
  setModifierManager
} from "./chunk-HJOPXKLZ.js";
import "./chunk-JXSOYYVP.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/modifier/index.js
var setModifierManager2 = setModifierManager;

// ../../node_modules/.pnpm/ember-modifier@4.3.0_@babel+core@7.28.5/node_modules/ember-modifier/dist/index.js
function installElement$1(state, element) {
  const installedState = state;
  installedState.element = element;
  return installedState;
}
var ClassBasedModifierManager = class {
  capabilities = modifierCapabilities("3.22");
  constructor(owner) {
    this.owner = owner;
  }
  createModifier(modifierClass, args) {
    const instance = new modifierClass(this.owner, args);
    return {
      instance,
      element: null
    };
  }
  installModifier(createdState, element, args) {
    const state = installElement$1(createdState, element);
    state.instance.modify(element, args.positional, args.named);
  }
  updateModifier(state, args) {
    state.instance.modify(state.element, args.positional, args.named);
  }
  destroyModifier({
    instance
  }) {
    destroy(instance);
  }
};
var ClassBasedModifier = class {
  // `args` is passed here for the sake of subclasses to have access to args in
  // their constructors while having constructors which are properly asssignable
  // for the superclass.
  /**
   *
   * @param owner An instance of an Owner (for service injection etc.).
   * @param args The positional and named arguments passed to the modifier.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  constructor(owner, args) {
    setOwner(this, owner);
  }
  /**
   * Called when the modifier is installed and any time any tracked state used
   * in the modifier changes.
   *
   * If you need to do first-time-only setup, create a class field representing
   * the initialization state and check it when running the hook. That is also
   * where and when you should use `registerDestructor` for any teardown you
   * need to do. For example:
   *
   * ```js
   * function disconnect(instance) {
   *  instance.observer?.disconnect();
   * }
   *
   * class IntersectionObserver extends Modifier {
   *   observer;
   *
   *   constructor(owner, args) {
   *     super(owner, args);
   *     registerDestructor(this, disconnect);
   *   }
   *
   *   modify(element, callback, options) {
   *     disconnect(this);
   *
   *     this.observer = new IntersectionObserver(callback, options);
   *     this.observer.observe(element);
   *   }
   * }
   * ```
   *
   * @param element The element to which the modifier is applied.
   * @param positional The positional arguments to the modifier.
   * @param named The named arguments to the modifier.
   */
  modify(element, positional, named) {
  }
};
setModifierManager2((owner) => new ClassBasedModifierManager(owner), ClassBasedModifier);
function installElement(state, element) {
  const installedState = state;
  installedState.element = element;
  return installedState;
}
var FunctionBasedModifierManager = class {
  capabilities = modifierCapabilities("3.22");
  createModifier(instance) {
    return {
      element: null,
      instance
    };
  }
  installModifier(createdState, element, args) {
    const state = installElement(createdState, element);
    const {
      positional,
      named
    } = args;
    const teardown = createdState.instance(element, positional, named);
    if (typeof teardown === "function") {
      state.teardown = teardown;
    }
  }
  updateModifier(state, args) {
    if (typeof state.teardown === "function") {
      state.teardown();
    }
    const teardown = state.instance(state.element, args.positional, args.named);
    if (typeof teardown === "function") {
      state.teardown = teardown;
    }
  }
  destroyModifier(state) {
    if (typeof state.teardown === "function") {
      state.teardown();
    }
  }
  getDebugName(state) {
    return state.instance.toString();
  }
  getDebugInstance(state) {
    return state;
  }
};
var MANAGER = new FunctionBasedModifierManager();
function modifier(fn, options) {
  fn.toString = () => options?.name || fn.name;
  return setModifierManager2(() => MANAGER, fn);
}
export {
  ClassBasedModifier as default,
  modifier
};
//# sourceMappingURL=ember-modifier.js.map
