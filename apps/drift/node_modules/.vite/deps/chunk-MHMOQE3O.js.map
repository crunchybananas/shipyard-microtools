{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/encoder/index.js", "../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/wire-format/index.js", "../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/opcode-compiler/index.js"],
  "sourcesContent": ["import { TYPE_SIZE, MAX_SIZE, ARG_SHIFT } from '../vm/index.js';\nclass InstructionEncoderImpl {\n  constructor(buffer) {\n    this.buffer = buffer, this.size = 0;\n  }\n  encode(type, machine, ...args) {\n    if (type > TYPE_SIZE) throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    let first = type | machine | arguments.length - 2 << ARG_SHIFT;\n    this.buffer.push(first);\n    for (const op of args) {\n      if (true && \"number\" == typeof op && op > MAX_SIZE) throw new Error(`Operand over 32-bits. Got ${op}.`);\n      this.buffer.push(op);\n    }\n    this.size = this.buffer.length;\n  }\n  patch(position, target) {\n    if (-1 !== this.buffer[position + 1]) throw new Error(\"Trying to patch operand in populated slot instead of a reserved slot.\");\n    this.buffer[position + 1] = target;\n  }\n}\nexport { InstructionEncoderImpl };", "const opcodes = {\n    Append: 1,\n    TrustingAppend: 2,\n    Comment: 3,\n    Modifier: 4,\n    StrictModifier: 5,\n    Block: 6,\n    StrictBlock: 7,\n    Component: 8,\n    OpenElement: 10,\n    OpenElementWithSplat: 11,\n    FlushElement: 12,\n    CloseElement: 13,\n    StaticAttr: 14,\n    DynamicAttr: 15,\n    ComponentAttr: 16,\n    AttrSplat: 17,\n    Yield: 18,\n    DynamicArg: 20,\n    StaticArg: 21,\n    TrustingDynamicAttr: 22,\n    TrustingComponentAttr: 23,\n    StaticComponentAttr: 24,\n    Debugger: 26,\n    Undefined: 27,\n    Call: 28,\n    Concat: 29,\n    GetSymbol: 30,\n    GetLexicalSymbol: 32,\n    GetStrictKeyword: 31,\n    GetFreeAsComponentOrHelperHead: 35,\n    GetFreeAsHelperHead: 37,\n    GetFreeAsModifierHead: 38,\n    GetFreeAsComponentHead: 39,\n    InElement: 40,\n    If: 41,\n    Each: 42,\n    Let: 44,\n    WithDynamicVars: 45,\n    InvokeComponent: 46,\n    HasBlock: 48,\n    HasBlockParams: 49,\n    Curry: 50,\n    Not: 51,\n    IfInline: 52,\n    GetDynamicVar: 53,\n    Log: 54\n  },\n  resolution = {\n    Strict: 0,\n    ResolveAsComponentOrHelperHead: 1,\n    ResolveAsHelperHead: 5,\n    ResolveAsModifierHead: 6,\n    ResolveAsComponentHead: 7\n  },\n  WellKnownAttrNames = {\n    class: 0,\n    id: 1,\n    value: 2,\n    name: 3,\n    type: 4,\n    style: 5,\n    href: 6\n  },\n  WellKnownTagNames = {\n    div: 0,\n    span: 1,\n    p: 2,\n    a: 3\n  };\nfunction is(variant) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (value) {\n    return Array.isArray(value) && value[0] === variant;\n  };\n}\n\n// Statements\nconst isFlushElement = is(opcodes.FlushElement);\nfunction isAttribute(val) {\n  return val[0] === opcodes.StaticAttr || val[0] === opcodes.DynamicAttr || val[0] === opcodes.TrustingDynamicAttr || val[0] === opcodes.ComponentAttr || val[0] === opcodes.StaticComponentAttr || val[0] === opcodes.TrustingComponentAttr || val[0] === opcodes.AttrSplat || val[0] === opcodes.Modifier;\n}\nfunction isStringLiteral(expr) {\n  return \"string\" == typeof expr;\n}\nfunction getStringFromValue(expr) {\n  return expr;\n}\nfunction isArgument(val) {\n  return val[0] === opcodes.StaticArg || val[0] === opcodes.DynamicArg;\n}\nfunction isHelper(expr) {\n  return Array.isArray(expr) && expr[0] === opcodes.Call;\n}\n\n// Expressions\nconst isGet = is(opcodes.GetSymbol);\nexport { opcodes as SexpOpcodes, resolution as VariableResolutionContext, WellKnownAttrNames, WellKnownTagNames, getStringFromValue, is, isArgument, isAttribute, isFlushElement, isGet, isHelper, isStringLiteral };", "import { EMPTY_STRING_ARRAY, reverse, enumerate, dict, EMPTY_ARRAY, assign, Stack as StackImpl } from '../util/index.js';\nimport { InstructionEncoderImpl } from '../encoder/index.js';\nimport { $v0, $fp, $s0, $sp, InternalComponentCapabilities, $s1, TYPE_SIZE, MACHINE_MASK, ARG_SHIFT, ContentType } from '../vm/index.js';\nimport { SexpOpcodes as opcodes } from '../wire-format/index.js';\nimport { hasCapability } from '../manager/index.js';\nlet debugToString;\nif (true) {\n  let getFunctionName = fn => {\n      let functionName = fn.name;\n      if (\"\" === functionName) {\n        let match = /function (\\w+)\\s*\\(/u.exec(String(fn));\n        functionName = match && match[1] || \"\";\n      }\n      return functionName.replace(/^bound /u, \"\");\n    },\n    getObjectName = obj => {\n      let name, className;\n      // If the class has a decent looking name, and the `toString` is one of the\n      // default Ember toStrings, replace the constructor portion of the toString\n      // with the class name. We check the length of the class name to prevent doing\n      // this when the value is minified.\n      return \"function\" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), \"toString\" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && (\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      name = obj.toString()), name && /<.*:ember\\d+>/u.test(name) && className && \"_\" !== className[0] && className.length > 2 && \"Class\" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;\n    },\n    getPrimitiveName = value => String(value);\n  debugToString = value => \"function\" == typeof value ? getFunctionName(value) || \"(unknown function)\" : \"object\" == typeof value && null !== value ? getObjectName(value) || \"(unknown object)\" : getPrimitiveName(value);\n}\nvar debugToString$1 = debugToString;\nfunction encodeImmediate(num) {\n  return (num |= 0) < 0 ? function (num) {\n    return -536870913 & num;\n  }(num) : function (num) {\n    return ~num;\n  }(num);\n}\nlet debugCompiler;\nfunction makeResolutionTypeVerifier(typeToVerify) {\n  return opcode => {\n    if (!function (opcode) {\n      return Array.isArray(opcode) && 2 === opcode.length;\n    }(opcode)) return false;\n    let type = opcode[0];\n    return type === opcodes.GetStrictKeyword || type === opcodes.GetLexicalSymbol || type === typeToVerify;\n  };\n}\n[1, -1].forEach(x => {\n  return num = encodeImmediate(x), (num |= 0) > -536870913 ? function (num) {\n    return ~num;\n  }(num) : function (num) {\n    return 536870912 | num;\n  }(num);\n  var num;\n});\nconst isGetFreeComponent = makeResolutionTypeVerifier(opcodes.GetFreeAsComponentHead),\n  isGetFreeModifier = makeResolutionTypeVerifier(opcodes.GetFreeAsModifierHead),\n  isGetFreeHelper = makeResolutionTypeVerifier(opcodes.GetFreeAsHelperHead),\n  isGetFreeComponentOrHelper = makeResolutionTypeVerifier(opcodes.GetFreeAsComponentOrHelperHead);\nfunction assertResolverInvariants(meta) {\n  if (true) {\n    if (!meta.symbols.upvars) throw new Error(\"Attempted to resolve a component, helper, or modifier, but no free vars were found\");\n    if (!meta.owner) throw new Error(\"Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from\");\n  }\n  return meta;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nfunction lookupBuiltInHelper(expr, resolver, meta, constants, type) {\n  let {\n      symbols: {\n        upvars: upvars\n      }\n    } = assertResolverInvariants(meta),\n    name = upvars[expr[1]],\n    helper = resolver?.lookupBuiltInHelper?.(name) ?? null;\n  if (true && null === helper)\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw meta.isStrictMode, new Error(`Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    meta.symbols.upvars[expr[1]] ?? \"{unknown variable}\"}`);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return constants.helper(helper, name);\n}\nfunction labelOperand(value) {\n  return {\n    type: 1,\n    value: value\n  };\n}\nfunction stdlibOperand(value) {\n  return {\n    type: 5,\n    value: value\n  };\n}\nfunction symbolTableOperand(value) {\n  return {\n    type: 7,\n    value: value\n  };\n}\nfunction layoutOperand(value) {\n  return {\n    type: 8,\n    value: value\n  };\n}\nclass Labels {\n  label(name, index) {\n    this.labels[name] = index;\n  }\n  target(at, target) {\n    this.targets.push({\n      at: at,\n      target: target\n    });\n  }\n  patch(heap) {\n    let {\n      targets: targets,\n      labels: labels\n    } = this;\n    for (const {\n      at: at,\n      target: target\n    } of targets) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      let address = labels[target] - at;\n      heap.getbyaddr(at), heap.setbyaddr(at, address);\n    }\n  }\n  constructor() {\n    this.labels = dict(), this.targets = [];\n  }\n}\nfunction encodeOp(encoder, context, meta, op) {\n  let {\n    program: {\n      constants: constants\n    },\n    resolver: resolver\n  } = context;\n  if (function (op) {\n    return op < 1e3;\n  }(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...operands);\n  } else switch (op[0]) {\n    case 1e3:\n      return encoder.label(op[1]);\n    case 1001:\n      return encoder.startLabels();\n    case 1002:\n      return encoder.stopLabels();\n    case 1004:\n      return function (resolver, constants, meta, [, expr, then]) {\n        isGetFreeComponent(expr);\n        let type = expr[0];\n        if (true && expr[0] === opcodes.GetStrictKeyword) throw meta.isStrictMode, new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        meta.symbols.upvars[expr[1]] ?? \"{unknown variable}\"}`);\n        if (type === opcodes.GetLexicalSymbol) {\n          let {\n              scopeValues: scopeValues,\n              owner: owner,\n              symbols: {\n                lexical: lexical\n              }\n            } = meta,\n            definition = scopeValues[expr[1]];\n          then(constants.component(definition, owner, false, lexical?.at(expr[1])));\n        } else {\n          let {\n              symbols: {\n                upvars: upvars\n              },\n              owner: owner\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            definition = resolver?.lookupComponent?.(name, owner) ?? null;\n          if (true && (\"object\" != typeof definition || null === definition)) throw meta.isStrictMode, new Error(`Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`);\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          then(constants.resolvedComponent(definition, name));\n        }\n      }\n      /**\n      * (helper)\n      * (helper arg)\n      */(resolver, constants, meta, op);\n    case 1003:\n      /**\n      * <div {{modifier}}/>\n      * <div {{modifier arg}}/>\n      * <Foo {{modifier}}/>\n      */\n      return function (resolver, constants, meta, [, expr, then]) {\n        isGetFreeModifier(expr);\n        let type = expr[0];\n        if (type === opcodes.GetLexicalSymbol) {\n          let {\n              scopeValues: scopeValues,\n              symbols: {\n                lexical: lexical\n              }\n            } = meta,\n            definition = scopeValues[expr[1]];\n          then(constants.modifier(definition, lexical?.at(expr[1]) ?? void 0));\n        } else if (type === opcodes.GetStrictKeyword) {\n          let {\n              symbols: {\n                upvars: upvars\n              }\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            modifier = resolver?.lookupBuiltInModifier?.(name) ?? null;\n          if (true && null === modifier) throw meta.isStrictMode, new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`);\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          then(constants.modifier(modifier, name));\n        } else {\n          let {\n              symbols: {\n                upvars: upvars\n              },\n              owner: owner\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            modifier = resolver?.lookupModifier?.(name, owner) ?? null;\n          if (true && null === modifier) throw meta.isStrictMode, new Error(`Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`);\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          then(constants.modifier(modifier));\n        }\n      }\n      /**\n      * {{component-or-helper arg}}\n      */(resolver, constants, meta, op);\n    case 1005:\n      return function (resolver, constants, meta, [, expr, then]) {\n        isGetFreeHelper(expr);\n        let type = expr[0];\n        if (type === opcodes.GetLexicalSymbol) {\n          let {\n              scopeValues: scopeValues\n            } = meta,\n            definition = scopeValues[expr[1]];\n          then(constants.helper(definition));\n        } else if (type === opcodes.GetStrictKeyword) then(lookupBuiltInHelper(expr, resolver, meta, constants, \"helper\"));else {\n          let {\n              symbols: {\n                upvars: upvars\n              },\n              owner: owner\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            helper = resolver?.lookupHelper?.(name, owner) ?? null;\n          if (true && null === helper) throw meta.isStrictMode, new Error(`Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`);\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          then(constants.helper(helper, name));\n        }\n      }(resolver, constants, meta, op);\n    case 1007:\n      return function (resolver, constants, meta, [, expr, {\n        ifComponent: ifComponent,\n        ifHelper: ifHelper\n      }]) {\n        isGetFreeComponentOrHelper(expr);\n        let type = expr[0];\n        if (type === opcodes.GetLexicalSymbol) {\n          let {\n              scopeValues: scopeValues,\n              owner: owner,\n              symbols: {\n                lexical: lexical\n              }\n            } = meta,\n            definition = scopeValues[expr[1]],\n            component = constants.component(definition, owner, true, lexical?.at(expr[1]));\n          if (null !== component) return void ifComponent(component);\n          let helper = constants.helper(definition, null, true);\n          if (true && null === helper) throw meta.isStrictMode, new Error(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString$1(definition)}`);\n          ifHelper(helper);\n        } else if (type === opcodes.GetStrictKeyword) ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, \"component or helper\"));else {\n          let {\n              symbols: {\n                upvars: upvars\n              },\n              owner: owner\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            definition = resolver?.lookupComponent?.(name, owner) ?? null;\n          if (null !== definition) ifComponent(constants.resolvedComponent(definition, name));else {\n            let helper = resolver?.lookupHelper?.(name, owner) ?? null;\n            if (true && null === helper) throw meta.isStrictMode, new Error(`Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n            ifHelper(constants.helper(helper, name));\n          }\n        }\n      }\n      /**\n      * {{maybeHelperOrComponent}}\n      */(resolver, constants, meta, op);\n    case 1008:\n      return function (resolver, constants, meta, [, expr, {\n        ifComponent: ifComponent,\n        ifHelper: ifHelper,\n        ifValue: ifValue\n      }]) {\n        isGetFreeComponentOrHelper(expr);\n        let type = expr[0];\n        if (type === opcodes.GetLexicalSymbol) {\n          let {\n              scopeValues: scopeValues,\n              owner: owner,\n              symbols: {\n                lexical: lexical\n              }\n            } = meta,\n            definition = scopeValues[expr[1]];\n          if (\"function\" != typeof definition && (\"object\" != typeof definition || null === definition))\n            // The value is not an object, so it can't be a component or helper.\n            return void ifValue(constants.value(definition));\n          let component = constants.component(definition, owner, true, lexical?.at(expr[1]));\n          if (null !== component) return void ifComponent(component);\n          let helper = constants.helper(definition, null, true);\n          if (null !== helper) return void ifHelper(helper);\n          ifValue(constants.value(definition));\n        } else if (type === opcodes.GetStrictKeyword) ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, \"value\"));else {\n          let {\n              symbols: {\n                upvars: upvars\n              },\n              owner: owner\n            } = assertResolverInvariants(meta),\n            name = upvars[expr[1]],\n            definition = resolver?.lookupComponent?.(name, owner) ?? null;\n          if (null !== definition) return void ifComponent(constants.resolvedComponent(definition, name));\n          let helper = resolver?.lookupHelper?.(name, owner) ?? null;\n          null !== helper && ifHelper(constants.helper(helper, name));\n        }\n      }(resolver, constants, meta, op);\n    case 1010:\n      {\n        let [, freeVar, andThen] = op;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        andThen(meta.symbols.upvars[freeVar], meta.moduleName);\n        break;\n      }\n    case 1011:\n      {\n        let [, valueIndex, then] = op,\n          value = meta.scopeValues[valueIndex];\n        then(constants.value(value));\n        break;\n      }\n    default:\n      throw new Error(`Unexpected high level opcode ${op[0]}`);\n  }\n}\nclass EncoderImpl {\n  constructor(heap, meta, stdlib) {\n    this.heap = heap, this.meta = meta, this.stdlib = stdlib, this.labelsStack = new StackImpl(), this.encoder = new InstructionEncoderImpl([]), this.errors = [], this.handle = heap.malloc();\n  }\n  error(error) {\n    this.encoder.encode(30, 0), this.errors.push(error);\n  }\n  commit(size) {\n    let handle = this.handle;\n    return this.heap.pushMachine(5), this.heap.finishMalloc(handle, size), (list = this.errors) && list.length > 0 ? {\n      errors: this.errors,\n      handle: handle\n    } : handle;\n    var list;\n  }\n  push(constants, type, ...args) {\n    let {\n      heap: heap\n    } = this;\n    if (true && type > TYPE_SIZE) throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    var value;\n    let first = type | ((value = type) >= 0 && value <= 15 ? MACHINE_MASK : 0) | args.length << ARG_SHIFT;\n    heap.pushRaw(first);\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n  operand(constants, operand) {\n    if (\"number\" == typeof operand) return operand;\n    if (\"object\" == typeof operand && null !== operand) {\n      if (Array.isArray(operand)) return constants.array(operand);\n      switch (operand.type) {\n        case 1:\n          return this.currentLabels.target(this.heap.offset, operand.value), -1;\n        case 2:\n          return constants.value(this.meta.isStrictMode);\n        case 3:\n        case 6:\n        case 7:\n        case 8:\n          return constants.value(operand.value);\n        case 4:\n          return constants.value((block = operand.value, containing = this.meta, new CompilableTemplateImpl(block[0], containing, {\n            parameters: block[1] || EMPTY_ARRAY\n          })));\n        case 5:\n          return this.stdlib[operand.value];\n      }\n    }\n    var block, containing;\n    return constants.value(operand);\n  }\n  get currentLabels() {\n    return this.labelsStack.current;\n  }\n  label(name) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n  stopLabels() {\n    this.labelsStack.pop().patch(this.heap);\n  }\n}\nfunction templateCompilationContext(evaluation, meta) {\n  return {\n    evaluation: evaluation,\n    encoder: new EncoderImpl(evaluation.program.heap, meta, evaluation.stdlib),\n    meta: meta\n  };\n}\nclass Compilers {\n  add(name, func) {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n  compile(op, sexp) {\n    let name = sexp[0],\n      index = this.names[name],\n      func = this.funcs[index];\n    sexp[0], func(op, sexp);\n  }\n  constructor() {\n    this.names = {},\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.funcs = [];\n  }\n}\nconst EXPRESSIONS = new Compilers();\nfunction withPath(op, path) {\n  if (void 0 !== path && 0 !== path.length) for (let i = 0; i < path.length; i++) op(22, path[i]);\n}\nfunction expr(op, expression) {\n  Array.isArray(expression) ? EXPRESSIONS.compile(op, expression) : (PushPrimitive(op, expression), op(31));\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nfunction PushPrimitiveReference(op, value) {\n  PushPrimitive(op, value), op(31);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nfunction PushPrimitive(op, primitive) {\n  let p = primitive;\n  var value;\n  \"number\" == typeof p && (p = (value = p) % 1 == 0 && value <= 536870911 && value >= -536870912 ? encodeImmediate(p) : function (value) {\n    return {\n      type: 6,\n      value: value\n    };\n  }(p)), op(30, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nfunction Call(op, handle, positional, named) {\n  op(0), SimpleArgs(op, positional, named, false), op(16, handle), op(1), op(36, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nfunction CallDynamic(op, positional, named, append) {\n  op(0), SimpleArgs(op, positional, named, false), op(33, $fp, 1), op(107), append ? (op(36, $v0), append(), op(1), op(34, 1)) : (op(1), op(34, 1), op(36, $v0));\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nfunction Curry(op, type, definition, positional, named) {\n  op(0), SimpleArgs(op, positional, named, false), op(86), expr(op, definition), op(77, type, {\n    type: 2,\n    value: void 0\n  }), op(1), op(36, $v0);\n}\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nfunction YieldBlock(op, to, positional) {\n  SimpleArgs(op, positional, null, true), op(23, to), op(24), op(61), op(64), op(40), op(1);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nfunction PushYieldableBlock(op, block) {\n  !function (op, parameters) {\n    null !== parameters ? op(63, symbolTableOperand({\n      parameters: parameters\n    })) : PushPrimitive(op, null);\n  }(op, block && block[1]), op(62), PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nfunction InvokeStaticBlock(op, block) {\n  op(0), PushCompilable(op, block), op(61), op(2), op(1);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nfunction InvokeStaticBlockWithStack(op, block, callerCount) {\n  let parameters = block[1],\n    calleeCount = parameters.length,\n    count = Math.min(callerCount, calleeCount);\n  if (0 !== count) {\n    if (op(0), count) {\n      op(39);\n      for (let i = 0; i < count; i++) op(33, $fp, callerCount - i), op(19, parameters[i]);\n    }\n    PushCompilable(op, block), op(61), op(2), count && op(40), op(1);\n  } else InvokeStaticBlock(op, block);\n}\nfunction PushCompilable(op, _block) {\n  null === _block ? PushPrimitive(op, null) : op(28, {\n    type: 4,\n    value: _block\n  });\n}\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nfunction SimpleArgs(op, positional, named, atNames) {\n  if (null === positional && null === named) return void op(83);\n  let flags = CompilePositional(op, positional) << 4;\n  atNames && (flags |= 8);\n  let names = EMPTY_STRING_ARRAY;\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) expr(op, val[i]);\n  }\n  op(82, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nfunction CompilePositional(op, positional) {\n  if (null === positional) return 0;\n  for (let i = 0; i < positional.length; i++) expr(op, positional[i]);\n  return positional.length;\n}\nfunction meta(layout) {\n  let [, locals, upvars, lexicalSymbols] = layout.block;\n  return {\n    symbols: {\n      locals: locals,\n      upvars: upvars,\n      lexical: lexicalSymbols\n    },\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: locals.length\n  };\n}\nEXPRESSIONS.add(opcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) expr(op, part);\n  op(27, parts.length);\n}), EXPRESSIONS.add(opcodes.Call, (op, [, expression, positional, named]) => {\n  isGetFreeHelper(expression) ? op(1005, expression, handle => {\n    Call(op, handle, positional, named);\n  }) : (expr(op, expression), CallDynamic(op, positional, named));\n}), EXPRESSIONS.add(opcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n}), EXPRESSIONS.add(opcodes.GetSymbol, (op, [, sym, path]) => {\n  op(21, sym), withPath(op, path);\n}), EXPRESSIONS.add(opcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(1011, sym, handle => {\n    op(29, handle), withPath(op, path);\n  });\n}), EXPRESSIONS.add(opcodes.GetStrictKeyword, (op, expr) => {\n  op(1010, expr[1], () => {\n    op(1005, expr, handle => {\n      Call(op, handle, null, null);\n    });\n  });\n}), EXPRESSIONS.add(opcodes.GetFreeAsHelperHead, (op, expr) => {\n  op(1010, expr[1], () => {\n    op(1005, expr, handle => {\n      Call(op, handle, null, null);\n    });\n  });\n}), EXPRESSIONS.add(opcodes.Undefined, op => PushPrimitiveReference(op, void 0)), EXPRESSIONS.add(opcodes.HasBlock, (op, [, block]) => {\n  expr(op, block), op(25);\n}), EXPRESSIONS.add(opcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block), op(24), op(61), op(26);\n}), EXPRESSIONS.add(opcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy), expr(op, truthy), expr(op, condition), op(109);\n}), EXPRESSIONS.add(opcodes.Not, (op, [, value]) => {\n  expr(op, value), op(110);\n}), EXPRESSIONS.add(opcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression), op(111);\n}), EXPRESSIONS.add(opcodes.Log, (op, [, positional]) => {\n  op(0), SimpleArgs(op, positional, null, false), op(112), op(1), op(36, $v0);\n});\nclass NamedBlocksImpl {\n  constructor(blocks) {\n    this.blocks = blocks, this.names = blocks ? Object.keys(blocks) : [];\n  }\n  get(name) {\n    return this.blocks && this.blocks[name] || null;\n  }\n  has(name) {\n    let {\n      blocks: blocks\n    } = this;\n    return null !== blocks && name in blocks;\n  }\n  with(name, block) {\n    let {\n      blocks: blocks\n    } = this;\n    return new NamedBlocksImpl(blocks ? assign({}, blocks, {\n      [name]: block\n    }) : {\n      [name]: block\n    });\n  }\n  get hasAny() {\n    return null !== this.blocks;\n  }\n}\nconst EMPTY_BLOCKS = new NamedBlocksImpl(null);\nfunction namedBlocks(blocks) {\n  if (null === blocks) return EMPTY_BLOCKS;\n  let out = dict(),\n    [keys, values] = blocks;\n  for (const [i, key] of enumerate(keys)) out[key] = values[i];\n  return new NamedBlocksImpl(out);\n}\nfunction SwitchCases(op, bootstrap, matcher) {\n  // Setup the switch DSL\n  let clauses = [],\n    count = 0;\n  // Call the callback\n  matcher(function (match, callback) {\n    clauses.push({\n      match: match,\n      callback: callback,\n      label: \"CLAUSE\" + count++\n    });\n  }),\n  // Emit the opcodes for the switch\n  op(69, 1), bootstrap(), op(1001);\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) op(67, labelOperand(clause.label), clause.match);\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = clauses[i];\n    op(1e3, clause.label), op(34, 1), clause.callback(),\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    0 !== i && op(4, labelOperand(\"END\"));\n  }\n  op(1e3, \"END\"), op(1002), op(70);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nfunction Replayable(op, args, body) {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n  op(1001), op(0),\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(6, labelOperand(\"ENDINITIAL\")),\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(69, args()),\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body(),\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(1e3, \"FINALLY\"),\n  // Finalize the DOM.\n  op(70),\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(5),\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(1e3, \"ENDINITIAL\"), op(1), op(1002);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nfunction ReplayableIf(op, args, ifTrue, ifFalse) {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(66, labelOperand(\"ELSE\")),\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue(),\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(4, labelOperand(\"FINALLY\")), op(1e3, \"ELSE\"),\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    void 0 !== ifFalse && ifFalse();\n  });\n}\nfunction InvokeComponent(op, component, _elementBlock, positional, named, _blocks) {\n  let {\n      compilable: compilable,\n      capabilities: capabilities,\n      handle: handle\n    } = component,\n    elementBlock = _elementBlock ? [_elementBlock, []] : null,\n    blocks = namedBlocks(_blocks);\n  compilable ? (op(78, handle), function (op, {\n    capabilities: capabilities,\n    layout: layout,\n    elementBlock: elementBlock,\n    positional: positional,\n    named: named,\n    blocks: blocks\n  }) {\n    let {\n      symbolTable: symbolTable\n    } = layout;\n    if (hasCapability(capabilities, InternalComponentCapabilities.prepareArgs)) return void InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock: elementBlock,\n      positional: positional,\n      named: named,\n      atNames: true,\n      blocks: blocks,\n      layout: layout\n    });\n    op(36, $s0), op(33, $sp, 1), op(35, $s0), op(0);\n    // Setup arguments\n    let {\n        symbols: symbols\n      } = symbolTable,\n      blockSymbols = [],\n      argSymbols = [],\n      argNames = [],\n      blockNames = blocks.names;\n    // As we push values onto the stack, we store the symbols associated  with them\n    // so that we can set them on the scope later on with SetVariable and SetBlock\n    // Starting with the attrs block, if it exists and is referenced in the component\n    if (null !== elementBlock) {\n      let symbol = symbols.indexOf(\"&attrs\");\n      -1 !== symbol && (PushYieldableBlock(op, elementBlock), blockSymbols.push(symbol));\n    }\n    // Followed by the other blocks, if they exist and are referenced in the component.\n    // Also store the index of the associated symbol.\n    for (const name of blockNames) {\n      let symbol = symbols.indexOf(`&${name}`);\n      -1 !== symbol && (PushYieldableBlock(op, blocks.get(name)), blockSymbols.push(symbol));\n    }\n    // Next up we have arguments. If the component has the `createArgs` capability,\n    // then it wants access to the arguments in JavaScript. We can't know whether\n    // or not an argument is used, so we have to give access to all of them.\n    if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n      // First we push positional arguments\n      let flags = CompilePositional(op, positional) << 4;\n      // setup the flags with the count of positionals, and to indicate that atNames\n      // are used\n      flags |= 8;\n      let names = EMPTY_STRING_ARRAY;\n      // Next, if named args exist, push them all. If they have an associated symbol\n      // in the invoked component (e.g. they are used within its template), we push\n      // that symbol. If not, we still push the expression as it may be used, and\n      // we store the symbol as -1 (this is used later).\n      if (null !== named) {\n        names = named[0];\n        let val = named[1];\n        for (let i = 0; i < val.length; i++) {\n          let symbol = symbols.indexOf(names[i]);\n          expr(op, val[i]), argSymbols.push(symbol);\n        }\n      }\n      // Finally, push the VM arguments themselves. These args won't need access\n      // to blocks (they aren't accessible from userland anyways), so we push an\n      // empty array instead of the actual block names.\n      op(82, names, EMPTY_STRING_ARRAY, flags),\n      // And push an extra pop operation to remove the args before we begin setting\n      // variables on the local context\n      argSymbols.push(-1);\n    } else if (null !== named) {\n      // If the component does not have the `createArgs` capability, then the only\n      // expressions we need to push onto the stack are those that are actually\n      // referenced in the template of the invoked component (e.g. have symbols).\n      let names = named[0],\n        val = named[1];\n      for (let i = 0; i < val.length; i++) {\n        let name = names[i],\n          symbol = symbols.indexOf(name);\n        -1 !== symbol && (expr(op, val[i]), argSymbols.push(symbol), argNames.push(name));\n      }\n    }\n    op(97, $s0), hasCapability(capabilities, InternalComponentCapabilities.dynamicScope) && op(59), hasCapability(capabilities, InternalComponentCapabilities.createInstance) &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    op(87, 0 | blocks.has(\"default\")), op(88, $s0), hasCapability(capabilities, InternalComponentCapabilities.createArgs) ? op(90, $s0) : op(90, $s0, argNames),\n    // Setup the new root scope for the component\n    op(37, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0),\n    // Pop the self reference off the stack and set it to the symbol for `this`\n    // in the new scope. This is why all subsequent symbols are increased by one.\n    op(19, 0);\n    // Going in reverse, now we pop the args/blocks off the stack, starting with\n    // arguments, and assign them to their symbols in the new scope.\n    for (const symbol of reverse(argSymbols))\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n    -1 === symbol ?\n    // The expression was not bound to a local symbol, it was only pushed to be\n    // used with VM args in the javascript side\n    op(34, 1) : op(19, symbol + 1);\n    // if any positional params exist, pop them off the stack as well\n    null !== positional && op(34, positional.length);\n    // Finish up by popping off and assigning blocks\n    for (const symbol of reverse(blockSymbols)) op(20, symbol + 1);\n    op(28, layoutOperand(layout)), op(61), op(2), op(100, $s0), op(1), op(40), hasCapability(capabilities, InternalComponentCapabilities.dynamicScope) && op(60), op(98), op(35, $s0);\n  }(op, {\n    capabilities: capabilities,\n    layout: compilable,\n    elementBlock: elementBlock,\n    positional: positional,\n    named: named,\n    blocks: blocks\n  })) : (op(78, handle), InvokeNonStaticComponent(op, {\n    capabilities: capabilities,\n    elementBlock: elementBlock,\n    positional: positional,\n    named: named,\n    atNames: true,\n    blocks: blocks\n  }));\n}\nfunction InvokeDynamicComponent(op, definition, _elementBlock, positional, named, _blocks, atNames, curried) {\n  let elementBlock = _elementBlock ? [_elementBlock, []] : null,\n    blocks = namedBlocks(_blocks);\n  Replayable(op, () => (expr(op, definition), op(33, $sp, 0), 2), () => {\n    op(66, labelOperand(\"ELSE\")), curried ? op(81) : op(80, {\n      type: 2,\n      value: void 0\n    }), op(79), InvokeNonStaticComponent(op, {\n      capabilities: true,\n      elementBlock: elementBlock,\n      positional: positional,\n      named: named,\n      atNames: atNames,\n      blocks: blocks\n    }), op(1e3, \"ELSE\");\n  });\n}\nfunction InvokeNonStaticComponent(op, {\n  capabilities: capabilities,\n  elementBlock: elementBlock,\n  positional: positional,\n  named: named,\n  atNames: atNames,\n  blocks: namedBlocks,\n  layout: layout\n}) {\n  let bindableBlocks = !!namedBlocks,\n    bindableAtNames = true === capabilities || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) || !(!named || 0 === named[0].length),\n    blocks = namedBlocks.with(\"attrs\", elementBlock);\n  op(36, $s0), op(33, $sp, 1), op(35, $s0), op(0), function (op, positional, named, blocks, atNames) {\n    let blockNames = blocks.names;\n    for (const name of blockNames) PushYieldableBlock(op, blocks.get(name));\n    let flags = CompilePositional(op, positional) << 4;\n    atNames && (flags |= 8), blocks.hasAny && (flags |= 7);\n    let names = EMPTY_ARRAY;\n    if (named) {\n      names = named[0];\n      let val = named[1];\n      for (let i = 0; i < val.length; i++) expr(op, val[i]);\n    }\n    op(82, names, blockNames, flags);\n  }(op, positional, named, blocks, atNames), op(85, $s0), invokePreparedComponent(op, blocks.has(\"default\"), bindableBlocks, bindableAtNames, () => {\n    layout ? (op(63, symbolTableOperand(layout.symbolTable)), op(28, layoutOperand(layout)), op(61)) : op(92, $s0), op(95, $s0);\n  }), op(35, $s0);\n}\nfunction invokePreparedComponent(op, hasBlock, bindableBlocks, bindableAtNames, populateLayout = null) {\n  op(97, $s0), op(59),\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  op(87, 0 | hasBlock),\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  populateLayout && populateLayout(), op(88, $s0), op(90, $s0), op(38, $s0), op(19, 0), bindableAtNames && op(17, $s0), bindableBlocks && op(18, $s0), op(34, 1), op(96, $s0), op(100, $s0), op(1), op(40), op(60), op(98);\n}\nconst STATEMENTS = new Compilers(),\n  INFLATE_ATTR_TABLE = [\"class\", \"id\", \"value\", \"name\", \"type\", \"style\", \"href\"],\n  INFLATE_TAG_TABLE = [\"div\", \"span\", \"p\", \"a\"];\nfunction inflateTagName(tagName) {\n  return \"string\" == typeof tagName ? tagName : INFLATE_TAG_TABLE[tagName];\n}\nfunction inflateAttrName(attrName) {\n  return \"string\" == typeof attrName ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\nfunction hashToArgs(hash) {\n  return null === hash ? null : [hash[0].map(key => `@${key}`), hash[1]];\n}\nSTATEMENTS.add(opcodes.Comment, (op, sexp) => op(42, sexp[1])), STATEMENTS.add(opcodes.CloseElement, op => op(55)), STATEMENTS.add(opcodes.FlushElement, op => op(54)), STATEMENTS.add(opcodes.Modifier, (op, [, expression, positional, named]) => {\n  isGetFreeModifier(expression) ? op(1003, expression, handle => {\n    op(0), SimpleArgs(op, positional, named, false), op(57, handle), op(1);\n  }) : (expr(op, expression), op(0), SimpleArgs(op, positional, named, false), op(33, $fp, 1), op(108), op(1));\n}), STATEMENTS.add(opcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(51, inflateAttrName(name), value, namespace ?? null);\n}), STATEMENTS.add(opcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(105, inflateAttrName(name), value, namespace ?? null);\n}), STATEMENTS.add(opcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value), op(52, inflateAttrName(name), false, namespace ?? null);\n}), STATEMENTS.add(opcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value), op(52, inflateAttrName(name), true, namespace ?? null);\n}), STATEMENTS.add(opcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value), op(53, inflateAttrName(name), false, namespace ?? null);\n}), STATEMENTS.add(opcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value), op(53, inflateAttrName(name), true, namespace ?? null);\n}), STATEMENTS.add(opcodes.OpenElement, (op, [, tag]) => {\n  op(48, inflateTagName(tag));\n}), STATEMENTS.add(opcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(89), op(48, inflateTagName(tag));\n}), STATEMENTS.add(opcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  isGetFreeComponent(expr) ? op(1004, expr, component => {\n    InvokeComponent(op, component, elementBlock, null, named, blocks);\n  }) :\n  // otherwise, the component name was an expression, so resolve the expression\n  // and invoke it as a dynamic component\n  InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n}), STATEMENTS.add(opcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params)), STATEMENTS.add(opcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null)), STATEMENTS.add(opcodes.Debugger, (op, [, locals, upvars, lexical]) => {\n  op(103, function (locals, upvars, lexical) {\n    return {\n      type: 3,\n      value: {\n        locals: locals,\n        upvars: upvars,\n        lexical: lexical\n      }\n    };\n  }(locals, upvars, lexical));\n}), STATEMENTS.add(opcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (Array.isArray(value)) {\n    if (isGetFreeComponentOrHelper(value)) op(1008, value, {\n      ifComponent(component) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n      ifHelper(handle) {\n        op(0), Call(op, handle, null, null), op(3, stdlibOperand(\"cautious-non-dynamic-append\")), op(1);\n      },\n      ifValue(handle) {\n        op(0), op(29, handle), op(3, stdlibOperand(\"cautious-non-dynamic-append\")), op(1);\n      }\n    });else if (value[0] === opcodes.Call) {\n      let [, expression, positional, named] = value;\n      isGetFreeComponentOrHelper(expression) ? op(1007, expression, {\n        ifComponent(component) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle) {\n          op(0), Call(op, handle, positional, named), op(3, stdlibOperand(\"cautious-non-dynamic-append\")), op(1);\n        }\n      }) : SwitchCases(op, () => {\n        expr(op, expression), op(106);\n      }, when => {\n        when(ContentType.Component, () => {\n          op(81), op(79), InvokeNonStaticComponent(op, {\n            capabilities: true,\n            elementBlock: null,\n            positional: positional,\n            named: named,\n            atNames: false,\n            blocks: namedBlocks(null)\n          });\n        }), when(ContentType.Helper, () => {\n          CallDynamic(op, positional, named, () => {\n            op(3, stdlibOperand(\"cautious-non-dynamic-append\"));\n          });\n        });\n      });\n    } else op(0), expr(op, value), op(3, stdlibOperand(\"cautious-append\")), op(1);\n  } else op(41, null == value ? \"\" : String(value));\n}), STATEMENTS.add(opcodes.TrustingAppend, (op, [, value]) => {\n  Array.isArray(value) ? (op(0), expr(op, value), op(3, stdlibOperand(\"trusting-append\")), op(1)) : op(41, null == value ? \"\" : String(value));\n}), STATEMENTS.add(opcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  isGetFreeComponent(expr) ? op(1004, expr, component => {\n    InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n  }) : InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n}), STATEMENTS.add(opcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(op, () => (expr(op, guid), void 0 === insertBefore ? PushPrimitiveReference(op, void 0) : expr(op, insertBefore), expr(op, destination), op(33, $sp, 0), 4), () => {\n    op(50), InvokeStaticBlock(op, block), op(56);\n  });\n}), STATEMENTS.add(opcodes.If, (op, [, condition, block, inverse]) => ReplayableIf(op, () => (expr(op, condition), op(71), 1), () => {\n  InvokeStaticBlock(op, block);\n}, inverse ? () => {\n  InvokeStaticBlock(op, inverse);\n} : void 0)), STATEMENTS.add(opcodes.Each, (op, [, value, key, block, inverse]) => Replayable(op, () => (key ? expr(op, key) : PushPrimitiveReference(op, null), expr(op, value), 2), () => {\n  op(72, labelOperand(\"BODY\"), labelOperand(\"ELSE\")), op(0), op(33, $fp, 1), op(6, labelOperand(\"ITER\")), op(1e3, \"ITER\"), op(74, labelOperand(\"BREAK\")), op(1e3, \"BODY\"), InvokeStaticBlockWithStack(op, block, 2), op(34, 2), op(4, labelOperand(\"FINALLY\")), op(1e3, \"BREAK\"), op(1), op(73), op(4, labelOperand(\"FINALLY\")), op(1e3, \"ELSE\"), inverse && InvokeStaticBlock(op, inverse);\n})), STATEMENTS.add(opcodes.Let, (op, [, positional, block]) => {\n  InvokeStaticBlockWithStack(op, block, CompilePositional(op, positional));\n}), STATEMENTS.add(opcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n    CompilePositional(op, expressions), function (op, names, block) {\n      op(59), op(58, names), block(), op(60);\n    }(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else InvokeStaticBlock(op, block);\n}), STATEMENTS.add(opcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  isGetFreeComponent(expr) ? op(1004, expr, component => {\n    InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n  }) : InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n});\nclass CompilableTemplateImpl {\n  constructor(statements, meta,\n  // Part of CompilableTemplate\n  symbolTable,\n  // Used for debugging\n  moduleName = \"plain block\") {\n    this.statements = statements, this.meta = meta, this.symbolTable = symbolTable, this.moduleName = moduleName, this.compiled = null;\n  }\n  // Part of CompilableTemplate\n  compile(context) {\n    return function (compilable, context) {\n      if (null !== compilable.compiled) return compilable.compiled;\n      compilable.compiled = -1;\n      let {\n          statements: statements,\n          meta: meta\n        } = compilable,\n        result = compileStatements(statements, meta, context);\n      return compilable.compiled = result, result;\n    }(this, context);\n  }\n}\nfunction compilable(layout, moduleName) {\n  let [statements, symbols] = layout.block;\n  return new CompilableTemplateImpl(statements, meta(layout), {\n    symbols: symbols\n  }, moduleName);\n}\nfunction compileStatements(statements, meta, syntaxContext) {\n  let sCompiler = STATEMENTS,\n    context = templateCompilationContext(syntaxContext, meta),\n    {\n      encoder: encoder,\n      evaluation: evaluation\n    } = context;\n  function pushOp(...op) {\n    encodeOp(encoder, evaluation, meta, op);\n  }\n  for (const statement of statements) sCompiler.compile(pushOp, statement);\n  return context.encoder.commit(meta.size);\n}\nconst DEFAULT_CAPABILITIES = {\n    dynamicLayout: true,\n    dynamicTag: true,\n    prepareArgs: true,\n    createArgs: true,\n    attributeHook: false,\n    elementHook: false,\n    dynamicScope: true,\n    createCaller: false,\n    updateHook: true,\n    createInstance: true,\n    wrapped: false,\n    willDestroy: false,\n    hasSubOwner: false\n  },\n  MINIMAL_CAPABILITIES = {\n    dynamicLayout: false,\n    dynamicTag: false,\n    prepareArgs: false,\n    createArgs: false,\n    attributeHook: false,\n    elementHook: false,\n    dynamicScope: false,\n    createCaller: false,\n    updateHook: false,\n    createInstance: false,\n    wrapped: false,\n    willDestroy: false,\n    hasSubOwner: false\n  };\nclass StdLib {\n  constructor(main, trustingGuardedAppend, cautiousGuardedAppend, trustingNonDynamicAppend, cautiousNonDynamicAppend) {\n    this.main = main, this.trustingGuardedAppend = trustingGuardedAppend, this.cautiousGuardedAppend = cautiousGuardedAppend, this.trustingNonDynamicAppend = trustingNonDynamicAppend, this.cautiousNonDynamicAppend = cautiousNonDynamicAppend;\n  }\n  get \"trusting-append\"() {\n    return this.trustingGuardedAppend;\n  }\n  get \"cautious-append\"() {\n    return this.cautiousGuardedAppend;\n  }\n  get \"trusting-non-dynamic-append\"() {\n    return this.trustingNonDynamicAppend;\n  }\n  get \"cautious-non-dynamic-append\"() {\n    return this.cautiousNonDynamicAppend;\n  }\n  getAppend(trusting) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nfunction StdAppend(op, trusting, nonDynamicAppend) {\n  SwitchCases(op, () => op(76), when => {\n    when(ContentType.String, () => {\n      trusting ? (op(68), op(43)) : op(47);\n    }), \"number\" == typeof nonDynamicAppend ? (when(ContentType.Component, () => {\n      op(81), op(79), function (op) {\n        op(36, $s0), op(33, $sp, 1), op(35, $s0), op(0), op(83), op(85, $s0), invokePreparedComponent(op, false, false, true, () => {\n          op(92, $s0), op(95, $s0);\n        }), op(35, $s0);\n      }(op);\n    }), when(ContentType.Helper, () => {\n      CallDynamic(op, null, null, () => {\n        op(3, nonDynamicAppend);\n      });\n    })) : (\n    // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n    // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n    when(ContentType.Component, () => {\n      op(47);\n    }), when(ContentType.Helper, () => {\n      op(47);\n    })), when(ContentType.SafeString, () => {\n      op(68), op(44);\n    }), when(ContentType.Fragment, () => {\n      op(68), op(45);\n    }), when(ContentType.Node, () => {\n      op(68), op(46);\n    });\n  });\n}\nfunction compileStd(context) {\n  let mainHandle = build(context, op => function (op) {\n      op(75, $s0), invokePreparedComponent(op, false, false, true);\n    }(op)),\n    trustingGuardedNonDynamicAppend = build(context, op => StdAppend(op, true, null)),\n    cautiousGuardedNonDynamicAppend = build(context, op => StdAppend(op, false, null)),\n    trustingGuardedDynamicAppend = build(context, op => StdAppend(op, true, trustingGuardedNonDynamicAppend)),\n    cautiousGuardedDynamicAppend = build(context, op => StdAppend(op, false, cautiousGuardedNonDynamicAppend));\n  return new StdLib(mainHandle, trustingGuardedDynamicAppend, cautiousGuardedDynamicAppend, trustingGuardedNonDynamicAppend, cautiousGuardedNonDynamicAppend);\n}\nconst STDLIB_META = {\n  symbols: {\n    locals: null,\n    upvars: null\n  },\n  moduleName: \"stdlib\",\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0\n};\nfunction build(evaluation, builder) {\n  let encoder = new EncoderImpl(evaluation.program.heap, STDLIB_META);\n  builder(function (...op) {\n    encodeOp(encoder, evaluation, STDLIB_META, op);\n  });\n  let result = encoder.commit(0);\n  if (\"number\" != typeof result)\n    // This shouldn't be possible\n    throw new Error(\"Unexpected errors compiling std\");\n  return result;\n}\nclass EvaluationContextImpl {\n  constructor({\n    constants: constants,\n    heap: heap\n  }, createOp, runtime) {\n    this.constants = constants, this.heap = heap, this.resolver = runtime.resolver, this.createOp = createOp, this.env = runtime.env, this.program = runtime.program, this.stdlib = compileStd(this);\n  }\n}\nclass WrappedBuilder {\n  constructor(layout, moduleName) {\n    this.layout = layout, this.moduleName = moduleName, this.compiled = null;\n    let {\n        block: block\n      } = layout,\n      [, symbols] = block;\n    symbols = symbols.slice();\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(\"&attrs\");\n    this.attrsBlockNumber = -1 === attrsBlockIndex ? symbols.push(\"&attrs\") : attrsBlockIndex + 1, this.symbolTable = {\n      symbols: symbols\n    }, this.meta = meta(layout);\n  }\n  compile(syntax) {\n    if (null !== this.compiled) return this.compiled;\n    let m = meta(this.layout),\n      context = templateCompilationContext(syntax, m),\n      {\n        encoder: encoder,\n        evaluation: evaluation\n      } = context;\n    var op, layout, attrsBlockNumber;\n    op = function (...op) {\n      encodeOp(encoder, evaluation, m, op);\n    }, layout = this.layout, attrsBlockNumber = this.attrsBlockNumber, op(1001), function (op, register, block) {\n      op(36, register), block(), op(35, register);\n    }(op, $s1, () => {\n      op(91, $s0), op(31), op(33, $sp, 0);\n    }), op(66, labelOperand(\"BODY\")), op(36, $s1), op(89), op(49), op(99, $s0), YieldBlock(op, attrsBlockNumber, null), op(54), op(1e3, \"BODY\"), InvokeStaticBlock(op, [layout.block[0], []]), op(36, $s1), op(66, labelOperand(\"END\")), op(55), op(1e3, \"END\"), op(35, $s1), op(1002);\n    let handle = context.encoder.commit(m.size);\n    return \"number\" != typeof handle || (this.compiled = handle), handle;\n  }\n}\nlet clientId = 0,\n  templateCacheCounters = {\n    cacheHit: 0,\n    cacheMiss: 0\n  };\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nfunction templateFactory({\n  id: templateId,\n  moduleName: moduleName,\n  block: block,\n  scope: scope,\n  isStrictMode: isStrictMode\n}) {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let parsedBlock,\n    id = templateId || \"client-\" + clientId++,\n    ownerlessTemplate = null,\n    templateCache = new WeakMap(),\n    factory = owner => {\n      if (void 0 === parsedBlock && (parsedBlock = JSON.parse(block)), void 0 === owner) return null === ownerlessTemplate ? (templateCacheCounters.cacheMiss++, ownerlessTemplate = new TemplateImpl({\n        id: id,\n        block: parsedBlock,\n        moduleName: moduleName,\n        owner: null,\n        scope: scope,\n        isStrictMode: isStrictMode\n      })) : templateCacheCounters.cacheHit++, ownerlessTemplate;\n      let result = templateCache.get(owner);\n      return void 0 === result ? (templateCacheCounters.cacheMiss++, result = new TemplateImpl({\n        id: id,\n        block: parsedBlock,\n        moduleName: moduleName,\n        owner: owner,\n        scope: scope,\n        isStrictMode: isStrictMode\n      }), templateCache.set(owner, result)) : templateCacheCounters.cacheHit++, result;\n    };\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  return factory.__id = id, factory.__meta = {\n    moduleName: moduleName\n  }, factory;\n}\nclass TemplateImpl {\n  constructor(parsedLayout) {\n    this.parsedLayout = parsedLayout, this.result = \"ok\", this.layout = null, this.wrappedLayout = null;\n  }\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n  get id() {\n    return this.parsedLayout.id;\n  }\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner\n    };\n  }\n  asLayout() {\n    return this.layout ? this.layout : this.layout = compilable(assign({}, this.parsedLayout), this.moduleName);\n  }\n  asWrappedLayout() {\n    return this.wrappedLayout ? this.wrappedLayout : this.wrappedLayout = new WrappedBuilder(assign({}, this.parsedLayout), this.moduleName);\n  }\n}\nexport { DEFAULT_CAPABILITIES, EMPTY_BLOCKS, EvaluationContextImpl, MINIMAL_CAPABILITIES, StdLib, WrappedBuilder, compilable, compileStatements, compileStd, debugCompiler, InvokeStaticBlock as invokeStaticBlock, InvokeStaticBlockWithStack as invokeStaticBlockWithStack, meta, templateCacheCounters, templateCompilationContext, templateFactory };"],
  "mappings": "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",
  "names": ["num", "opcode", "num", "meta", "expr", "op", "resolver", "constants", "value", "compilable", "capabilities", "elementBlock", "positional", "named", "blocks", "namedBlocks", "atNames", "locals", "upvars", "lexical", "names", "block", "context", "op"]
}
