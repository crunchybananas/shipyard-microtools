import {
  EventDispatcher,
  Input,
  LinkTo,
  OutletTemplate,
  OutletView,
  Renderer,
  RootTemplate,
  RouterService,
  RoutingService,
  Textarea,
  classify,
  dasherize,
  renderSettled
} from "./chunk-QF4YHKGU.js";
import {
  BucketCache,
  Controller,
  ENV,
  EmberObject,
  EmberRouter,
  EngineInstance,
  LIBRARIES,
  NAMESPACES,
  NAMESPACES_BY_ID,
  RSVP$1,
  Registry,
  RegistryProxyMixin,
  Route,
  addNamespace,
  assert,
  bind,
  environment,
  findNamespace,
  findNamespaces,
  get,
  getName,
  getOwner,
  getOwner2,
  guidFor,
  hasDOM,
  join,
  makeDictionary,
  once,
  privatize,
  processAllNamespaces,
  processNamespace,
  removeNamespace,
  run,
  schedule,
  set,
  setName,
  setOwner,
  typeOf,
  window as window2
} from "./chunk-ED7J5GAS.js";
import {
  ConcreteBounds,
  NewTreeBuilder,
  clientBuilder,
  rehydrationBuilder
} from "./chunk-2RJSWCLB.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/application/lib/lazy_load.js
var loadHooks = ENV.EMBER_LOAD_HOOKS || {};
var loaded = {};
var _loaded = loaded;
function onLoad(name, callback) {
  let object = loaded[name];
  let hooks = loadHooks[name] ??= [];
  hooks.push(callback);
  if (object) {
    callback(object);
  }
}
function runLoadHooks(name, object) {
  loaded[name] = object;
  if (window2 && typeof CustomEvent === "function") {
    let event = new CustomEvent(name, {
      detail: object
    });
    window2.dispatchEvent(event);
  }
  loadHooks[name]?.forEach((callback) => callback(object));
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/location-utils.js
function getHash(location) {
  if (location.hash !== void 0) {
    return location.hash.substring(0);
  }
  return "";
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/hash-location.js
var HashLocation = class extends EmberObject {
  _hashchangeHandler;
  _location;
  init() {
    this.location = this._location ?? window.location;
    this._hashchangeHandler = void 0;
  }
  /**
    @private
     Returns normalized location.hash
     @since 1.5.1
    @method getHash
  */
  getHash() {
    return getHash(this.location);
  }
  /**
    Returns the normalized URL, constructed from `location.hash`.
     e.g. `#/foo` => `/foo` as well as `#/foo#bar` => `/foo#bar`.
     By convention, hashed paths must begin with a forward slash, otherwise they
    are not treated as a path so we can distinguish intent.
     @private
    @method getURL
  */
  getURL() {
    let originalPath = this.getHash().substring(1);
    let outPath = originalPath;
    if (outPath[0] !== "/") {
      outPath = "/";
      if (originalPath) {
        outPath += `#${originalPath}`;
      }
    }
    return outPath;
  }
  /**
    Set the `location.hash` and remembers what was set. This prevents
    `onUpdateURL` callbacks from triggering when the hash was set by
    `HashLocation`.
     @private
    @method setURL
    @param path {String}
  */
  setURL(path) {
    this.location.hash = path;
    this.lastSetURL = path;
  }
  /**
    Uses location.replace to update the url without a page reload
    or history modification.
     @private
    @method replaceURL
    @param path {String}
  */
  replaceURL(path) {
    this.location.replace(`#${path}`);
    this.lastSetURL = path;
  }
  lastSetURL = null;
  /**
    Register a callback to be invoked when the hash changes. These
    callbacks will execute when the user presses the back or forward
    button, but not after `setURL` is invoked.
     @private
    @method onUpdateURL
    @param callback {Function}
  */
  onUpdateURL(callback) {
    this._removeEventListener();
    this._hashchangeHandler = bind(this, function(_event) {
      let path = this.getURL();
      if (this.lastSetURL === path) {
        return;
      }
      this.lastSetURL = null;
      callback(path);
    });
    window.addEventListener("hashchange", this._hashchangeHandler);
  }
  /**
    Given a URL, formats it to be placed into the page as part
    of an element's `href` attribute.
     @private
    @method formatURL
    @param url {String}
  */
  formatURL(url) {
    return `#${url}`;
  }
  /**
    Cleans up the HashLocation event listener.
     @private
    @method willDestroy
  */
  willDestroy() {
    this._removeEventListener();
  }
  _removeEventListener() {
    if (this._hashchangeHandler) {
      window.removeEventListener("hashchange", this._hashchangeHandler);
    }
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/history-location.js
var popstateFired = false;
function _uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    let r, v;
    r = Math.random() * 16 | 0;
    v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var HistoryLocation = class extends EmberObject {
  // SAFETY: both of these properties initialized via `init`.
  history;
  _previousURL;
  _popstateHandler;
  /**
    Will be pre-pended to path upon state change
     @property rootURL
    @default '/'
    @private
  */
  rootURL = "/";
  /**
    @private
     Returns normalized location.hash
     @method getHash
  */
  getHash() {
    return getHash(this.location);
  }
  init() {
    this._super(...arguments);
    let base = document.querySelector("base");
    let baseURL = "";
    if (base !== null && base.hasAttribute("href")) {
      baseURL = base.getAttribute("href") ?? "";
    }
    this.baseURL = baseURL;
    this.location = this.location ?? window.location;
    this._popstateHandler = void 0;
  }
  /**
    Used to set state on first call to setURL
     @private
    @method initState
  */
  initState() {
    let history = this.history ?? window.history;
    this.history = history;
    let {
      state
    } = history;
    let path = this.formatURL(this.getURL());
    if (state && state.path === path) {
      this._previousURL = this.getURL();
    } else {
      this.replaceState(path);
    }
  }
  /**
    Returns the current `location.pathname` without `rootURL` or `baseURL`
     @private
    @method getURL
    @return url {String}
  */
  getURL() {
    let {
      location,
      rootURL,
      baseURL
    } = this;
    let path = location.pathname;
    rootURL = rootURL.replace(/\/$/, "");
    baseURL = baseURL.replace(/\/$/, "");
    let url = path.replace(new RegExp(`^${baseURL}(?=/|$)`), "").replace(new RegExp(`^${rootURL}(?=/|$)`), "").replace(/\/\//g, "/");
    let search = location.search || "";
    url += search + this.getHash();
    return url;
  }
  /**
    Uses `history.pushState` to update the url without a page reload.
     @private
    @method setURL
    @param path {String}
  */
  setURL(path) {
    !this.history && assert("HistoryLocation.history is unexpectedly missing", this.history);
    let {
      state
    } = this.history;
    path = this.formatURL(path);
    if (!state || state.path !== path) {
      this.pushState(path);
    }
  }
  /**
    Uses `history.replaceState` to update the url without a page reload
    or history modification.
     @private
    @method replaceURL
    @param path {String}
  */
  replaceURL(path) {
    !this.history && assert("HistoryLocation.history is unexpectedly missing", this.history);
    let {
      state
    } = this.history;
    path = this.formatURL(path);
    if (!state || state.path !== path) {
      this.replaceState(path);
    }
  }
  /**
   Pushes a new state.
    @private
   @method pushState
   @param path {String}
  */
  pushState(path) {
    let state = {
      path,
      uuid: _uuid()
    };
    !this.history && assert("HistoryLocation.history is unexpectedly missing", this.history);
    this.history.pushState(state, "", path);
    this._previousURL = this.getURL();
  }
  /**
   Replaces the current state.
    @private
   @method replaceState
   @param path {String}
  */
  replaceState(path) {
    let state = {
      path,
      uuid: _uuid()
    };
    !this.history && assert("HistoryLocation.history is unexpectedly missing", this.history);
    this.history.replaceState(state, "", path);
    this._previousURL = this.getURL();
  }
  /**
    Register a callback to be invoked whenever the browser
    history changes, including using forward and back buttons.
     @private
    @method onUpdateURL
    @param callback {Function}
  */
  onUpdateURL(callback) {
    this._removeEventListener();
    this._popstateHandler = () => {
      if (!popstateFired) {
        popstateFired = true;
        if (this.getURL() === this._previousURL) {
          return;
        }
      }
      callback(this.getURL());
    };
    window.addEventListener("popstate", this._popstateHandler);
  }
  /**
    Formats url to be placed into href attribute.
     @private
    @method formatURL
    @param url {String}
    @return formatted url {String}
  */
  formatURL(url) {
    let {
      rootURL,
      baseURL
    } = this;
    if (url !== "") {
      rootURL = rootURL.replace(/\/$/, "");
      baseURL = baseURL.replace(/\/$/, "");
    } else if (baseURL[0] === "/" && rootURL[0] === "/") {
      baseURL = baseURL.replace(/\/$/, "");
    }
    return baseURL + rootURL + url;
  }
  /**
    Cleans up the HistoryLocation event listener.
     @private
    @method willDestroy
  */
  willDestroy() {
    this._removeEventListener();
  }
  _removeEventListener() {
    if (this._popstateHandler) {
      window.removeEventListener("popstate", this._popstateHandler);
    }
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/none-location.js
var NoneLocation = class extends EmberObject {
  updateCallback;
  // Set in reopen so it can be overwritten with extend
  /**
    Will be pre-pended to path.
     @private
    @property rootURL
    @default '/'
  */
  // Set in reopen so it can be overwritten with extend
  initState() {
    this._super(...arguments);
    let {
      rootURL
    } = this;
    !(rootURL.charAt(rootURL.length - 1) === "/") && assert('rootURL must end with a trailing forward slash e.g. "/app/"', rootURL.charAt(rootURL.length - 1) === "/");
  }
  /**
    Returns the current path without `rootURL`.
     @private
    @method getURL
    @return {String} path
  */
  getURL() {
    let {
      path,
      rootURL
    } = this;
    rootURL = rootURL.replace(/\/$/, "");
    return path.replace(new RegExp(`^${rootURL}(?=/|$)`), "");
  }
  /**
    Set the path and remembers what was set. Using this method
    to change the path will not invoke the `updateURL` callback.
     @private
    @method setURL
    @param path {String}
  */
  setURL(path) {
    this.path = path;
  }
  /**
    Register a callback to be invoked when the path changes. These
    callbacks will execute when the user presses the back or forward
    button, but not after `setURL` is invoked.
     @private
    @method onUpdateURL
    @param callback {Function}
  */
  onUpdateURL(callback) {
    this.updateCallback = callback;
  }
  /**
    Sets the path and calls the `updateURL` callback.
     @private
    @method handleURL
    @param url {String}
  */
  handleURL(url) {
    this.path = url;
    if (this.updateCallback) {
      this.updateCallback(url);
    }
  }
  /**
    Given a URL, formats it to be placed into the page as part
    of an element's `href` attribute.
     @private
    @method formatURL
    @param {String} url
    @return {String} url
  */
  formatURL(url) {
    let {
      rootURL
    } = this;
    if (url !== "") {
      rootURL = rootURL.replace(/\/$/, "");
    }
    return rootURL + url;
  }
};
NoneLocation.reopen({
  path: "",
  rootURL: "/"
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/application/instance.js
var ApplicationInstance = class extends EngineInstance {
  /**
    The `Application` for which this is an instance.
     @property {Application} application
    @private
  */
  /**
    The root DOM element of the Application as an element or a
    CSS selector.
     @private
    @property {String|DOMElement} rootElement
  */
  rootElement = null;
  init(properties) {
    super.init(properties);
    this.application._watchInstance(this);
    this.register("-application-instance:main", this, {
      instantiate: false
    });
  }
  /**
    Overrides the base `EngineInstance._bootSync` method with concerns relevant
    to booting application (instead of engine) instances.
     This method should only contain synchronous boot concerns. Asynchronous
    boot concerns should eventually be moved to the `boot` method, which
    returns a promise.
     Until all boot code has been made asynchronous, we need to continue to
    expose this method for use *internally* in places where we need to boot an
    instance synchronously.
     @private
  */
  _bootSync(options) {
    if (this._booted) {
      return this;
    }
    options = new _BootOptions(options);
    this.setupRegistry(options);
    if (options.rootElement) {
      this.rootElement = options.rootElement;
    } else {
      this.rootElement = this.application.rootElement;
    }
    if (options.location) {
      set(this.router, "location", options.location);
    }
    this.application.runInstanceInitializers(this);
    if (options.isInteractive) {
      this.setupEventDispatcher();
    }
    this._booted = true;
    return this;
  }
  setupRegistry(options) {
    this.constructor.setupRegistry(this.__registry__, options);
  }
  _router;
  get router() {
    if (!this._router) {
      let router = this.lookup("router:main");
      !(router instanceof EmberRouter) && assert("expected an instance of Router", router instanceof EmberRouter);
      this._router = router;
    }
    return this._router;
  }
  /**
    This hook is called by the root-most Route (a.k.a. the ApplicationRoute)
    when it has finished creating the root View. By default, we simply take the
    view and append it to the `rootElement` specified on the Application.
     In cases like FastBoot and testing, we can override this hook and implement
    custom behavior, such as serializing to a string and sending over an HTTP
    socket rather than appending to DOM.
     @param view {Ember.View} the root-most view
    @deprecated
    @private
  */
  didCreateRootView(view) {
    view.appendTo(this.rootElement);
  }
  /**
    Tells the router to start routing. The router will ask the location for the
    current URL of the page to determine the initial URL to start routing to.
    To start the app at a specific URL, call `handleURL` instead.
     @private
  */
  startRouting() {
    this.router.startRouting();
  }
  /**
    Sets up the router, initializing the child router and configuring the
    location before routing begins.
     Because setup should only occur once, multiple calls to `setupRouter`
    beyond the first call have no effect.
     This is commonly used in order to confirm things that rely on the router
    are functioning properly from tests that are primarily rendering related.
     For example, from within [ember-qunit](https://github.com/emberjs/ember-qunit)'s
    `setupRenderingTest` calling `this.owner.setupRouter()` would allow that
    rendering test to confirm that any `<LinkTo></LinkTo>`'s that are rendered
    have the correct URL.
     @public
  */
  setupRouter() {
    this.router.setupRouter();
  }
  /**
    Directs the router to route to a particular URL. This is useful in tests,
    for example, to tell the app to start at a particular URL.
     @param url {String} the URL the router should route to
    @private
  */
  handleURL(url) {
    this.setupRouter();
    return this.router.handleURL(url);
  }
  /**
    @private
  */
  setupEventDispatcher() {
    let dispatcher = this.lookup("event_dispatcher:main");
    !(dispatcher instanceof EventDispatcher) && assert("expected EventDispatcher", dispatcher instanceof EventDispatcher);
    let applicationCustomEvents = get(this.application, "customEvents");
    let instanceCustomEvents = get(this, "customEvents");
    let customEvents = Object.assign({}, applicationCustomEvents, instanceCustomEvents);
    !(this.rootElement === null || typeof this.rootElement === "string" || this.rootElement instanceof Element) && assert("[BUG] Tried to set up dispatcher with an invalid root element", this.rootElement === null || typeof this.rootElement === "string" || this.rootElement instanceof Element);
    dispatcher.setup(customEvents, this.rootElement);
    return dispatcher;
  }
  /**
    Returns the current URL of the app instance. This is useful when your
    app does not update the browsers URL bar (i.e. it uses the `'none'`
    location adapter).
     @public
    @return {String} the current URL
  */
  getURL() {
    return this.router.url;
  }
  // `instance.visit(url)` should eventually replace `instance.handleURL()`;
  // the test helpers can probably be switched to use this implementation too
  /**
    Navigate the instance to a particular URL. This is useful in tests, for
    example, or to tell the app to start at a particular URL. This method
    returns a promise that resolves with the app instance when the transition
    is complete, or rejects if the transition was aborted due to an error.
     @public
    @param url {String} the destination URL
    @return {Promise<ApplicationInstance>}
  */
  visit(url) {
    this.setupRouter();
    let bootOptions = this.__container__.lookup("-environment:main");
    let router = this.router;
    let handleTransitionResolve = () => {
      if (!bootOptions.options.shouldRender) {
        return this;
      } else {
        return renderSettled().then(() => this);
      }
    };
    let handleTransitionReject = (error) => {
      if (error.error && error.error instanceof Error) {
        throw error.error;
      } else if (error.name === "TransitionAborted" && router._routerMicrolib.activeTransition) {
        return router._routerMicrolib.activeTransition.then(handleTransitionResolve, handleTransitionReject);
      } else if (error.name === "TransitionAborted") {
        throw new Error(error.message);
      } else {
        throw error;
      }
    };
    let location = get(router, "location");
    !(typeof location !== "string") && assert("location has been initialized", typeof location !== "string");
    location.setURL(url);
    return router.handleURL(location.getURL()).then(handleTransitionResolve, handleTransitionReject);
  }
  willDestroy() {
    super.willDestroy();
    this.application._unwatchInstance(this);
  }
  /**
   @private
   @method setupRegistry
   @param {Registry} registry
   @param {BootOptions} options
  */
  static setupRegistry(registry, options = {}) {
    let coptions = options instanceof _BootOptions ? options : new _BootOptions(options);
    registry.register("-environment:main", coptions.toEnvironment(), {
      instantiate: false
    });
    registry.register("service:-document", coptions.document, {
      instantiate: false
    });
    super.setupRegistry(registry, coptions);
  }
};
var _BootOptions = class {
  /**
    Interactive mode: whether we need to set up event delegation and invoke
    lifecycle callbacks on Components.
     @property isInteractive
    @type boolean
    @default auto-detected
    @private
  */
  isInteractive;
  /**
    @property _renderMode
    @type string
    @default undefined
    @private
  */
  _renderMode;
  /**
    Run in a full browser environment.
     When this flag is set to `false`, it will disable most browser-specific
    and interactive features. Specifically:
     * It does not use `jQuery` to append the root view; the `rootElement`
      (either specified as a subsequent option or on the application itself)
      must already be an `Element` in the given `document` (as opposed to a
      string selector).
     * It does not set up an `EventDispatcher`.
     * It does not run any `Component` lifecycle hooks (such as `didInsertElement`).
     * It sets the `location` option to `"none"`. (If you would like to use
      the location adapter specified in the app's router instead, you can also
      specify `{ location: null }` to specifically opt-out.)
     @property isBrowser
    @type boolean
    @default auto-detected
    @public
  */
  isBrowser;
  /**
    If present, overrides the router's `location` property with this
    value. This is useful for environments where trying to modify the
    URL would be inappropriate.
     @property location
    @type string
    @default null
    @public
  */
  location = null;
  /**
    Disable rendering completely.
     When this flag is set to `false`, it will disable the entire rendering
    pipeline. Essentially, this puts the app into "routing-only" mode. No
    templates will be rendered, and no Components will be created.
     @property shouldRender
    @type boolean
    @default true
    @public
  */
  shouldRender;
  /**
    If present, render into the given `Document` object instead of the
    global `window.document` object.
     In practice, this is only useful in non-browser environment or in
    non-interactive mode, because Ember's `jQuery` dependency is
    implicitly bound to the current document, causing event delegation
    to not work properly when the app is rendered into a foreign
    document object (such as an iframe's `contentDocument`).
     In non-browser mode, this could be a "`Document`-like" object as
    Ember only interact with a small subset of the DOM API in non-
    interactive mode. While the exact requirements have not yet been
    formalized, the `SimpleDOM` library's implementation is known to
    work.
     @property document
    @type Document
    @default the global `document` object
    @public
  */
  document;
  /**
    If present, overrides the application's `rootElement` property on
    the instance. This is useful for testing environment, where you
    might want to append the root view to a fixture area.
     In non-browser mode, because Ember does not have access to jQuery,
    this options must be specified as a DOM `Element` object instead of
    a selector string.
     See the documentation on `Application`'s `rootElement` for
    details.
     @property rootElement
    @type String|Element
    @default null
    @public
  */
  rootElement;
  constructor(options = {}) {
    this.isInteractive = Boolean(hasDOM);
    this._renderMode = options._renderMode;
    if (options.isBrowser !== void 0) {
      this.isBrowser = Boolean(options.isBrowser);
    } else {
      this.isBrowser = Boolean(hasDOM);
    }
    if (!this.isBrowser) {
      this.isInteractive = false;
      this.location = "none";
    }
    if (options.shouldRender !== void 0) {
      this.shouldRender = Boolean(options.shouldRender);
    } else {
      this.shouldRender = true;
    }
    if (!this.shouldRender) {
      this.isInteractive = false;
    }
    if (options.document) {
      this.document = options.document;
    } else {
      this.document = typeof document !== "undefined" ? document : null;
    }
    if (options.rootElement) {
      this.rootElement = options.rootElement;
    }
    if (options.location !== void 0) {
      this.location = options.location;
    }
    if (options.isInteractive !== void 0) {
      this.isInteractive = Boolean(options.isInteractive);
    }
  }
  toEnvironment() {
    return {
      ...environment,
      // For compatibility with existing code
      hasDOM: this.isBrowser,
      isInteractive: this.isInteractive,
      _renderMode: this._renderMode,
      options: this
    };
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/invoke-BjRgvK2V.js
function canInvoke(obj, methodName) {
  return obj != null && typeof obj[methodName] === "function";
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/application/namespace.js
var Namespace = class extends EmberObject {
  static NAMESPACES = NAMESPACES;
  static NAMESPACES_BY_ID = NAMESPACES_BY_ID;
  static processAll = processAllNamespaces;
  static byName = findNamespace;
  init(properties) {
    super.init(properties);
    addNamespace(this);
  }
  toString() {
    let existing_name = get(this, "name") || get(this, "modulePrefix");
    if (existing_name) {
      !(typeof existing_name === "string") && assert("name wasn't a string", typeof existing_name === "string");
      return existing_name;
    }
    findNamespaces();
    let name = getName(this);
    if (name === void 0) {
      name = guidFor(this);
      setName(this, name);
    }
    return name;
  }
  nameClasses() {
    processNamespace(this);
  }
  destroy() {
    removeNamespace(this);
    return super.destroy();
  }
};
Namespace.prototype.isNamespace = true;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/dag-map/index.js
var DAG = (function() {
  function DAG2() {
    this._vertices = new Vertices();
  }
  DAG2.prototype.add = function(key, value, before, after) {
    if (!key) throw new Error("argument `key` is required");
    var vertices = this._vertices;
    var v = vertices.add(key);
    v.val = value;
    if (before) {
      if (typeof before === "string") {
        vertices.addEdge(v, vertices.add(before));
      } else {
        for (var i = 0; i < before.length; i++) {
          vertices.addEdge(v, vertices.add(before[i]));
        }
      }
    }
    if (after) {
      if (typeof after === "string") {
        vertices.addEdge(vertices.add(after), v);
      } else {
        for (var i = 0; i < after.length; i++) {
          vertices.addEdge(vertices.add(after[i]), v);
        }
      }
    }
  };
  DAG2.prototype.addEdges = function(key, value, before, after) {
    this.add(key, value, before, after);
  };
  DAG2.prototype.each = function(callback) {
    this._vertices.walk(callback);
  };
  DAG2.prototype.topsort = function(callback) {
    this.each(callback);
  };
  return DAG2;
})();
var Vertices = (function() {
  function Vertices2() {
    this.length = 0;
    this.stack = new IntStack();
    this.path = new IntStack();
    this.result = new IntStack();
  }
  Vertices2.prototype.add = function(key) {
    if (!key) throw new Error("missing key");
    var l = this.length | 0;
    var vertex;
    for (var i = 0; i < l; i++) {
      vertex = this[i];
      if (vertex.key === key) return vertex;
    }
    this.length = l + 1;
    return this[l] = {
      idx: l,
      key,
      val: void 0,
      out: false,
      flag: false,
      length: 0
    };
  };
  Vertices2.prototype.addEdge = function(v, w) {
    this.check(v, w.key);
    var l = w.length | 0;
    for (var i = 0; i < l; i++) {
      if (w[i] === v.idx) return;
    }
    w.length = l + 1;
    w[l] = v.idx;
    v.out = true;
  };
  Vertices2.prototype.walk = function(cb) {
    this.reset();
    for (var i = 0; i < this.length; i++) {
      var vertex = this[i];
      if (vertex.out) continue;
      this.visit(vertex, "");
    }
    this.each(this.result, cb);
  };
  Vertices2.prototype.check = function(v, w) {
    if (v.key === w) {
      throw new Error("cycle detected: " + w + " <- " + w);
    }
    if (v.length === 0) return;
    for (var i = 0; i < v.length; i++) {
      var key = this[v[i]].key;
      if (key === w) {
        throw new Error("cycle detected: " + w + " <- " + v.key + " <- " + w);
      }
    }
    this.reset();
    this.visit(v, w);
    if (this.path.length > 0) {
      var msg_1 = "cycle detected: " + w;
      this.each(this.path, function(key2) {
        msg_1 += " <- " + key2;
      });
      throw new Error(msg_1);
    }
  };
  Vertices2.prototype.reset = function() {
    this.stack.length = 0;
    this.path.length = 0;
    this.result.length = 0;
    for (var i = 0, l = this.length; i < l; i++) {
      this[i].flag = false;
    }
  };
  Vertices2.prototype.visit = function(start, search) {
    var _a = this, stack = _a.stack, path = _a.path, result = _a.result;
    stack.push(start.idx);
    while (stack.length) {
      var index = stack.pop() | 0;
      if (index >= 0) {
        var vertex = this[index];
        if (vertex.flag) continue;
        vertex.flag = true;
        path.push(index);
        if (search === vertex.key) break;
        stack.push(~index);
        this.pushIncoming(vertex);
      } else {
        path.pop();
        result.push(~index);
      }
    }
  };
  Vertices2.prototype.pushIncoming = function(incomming) {
    var stack = this.stack;
    for (var i = incomming.length - 1; i >= 0; i--) {
      var index = incomming[i];
      if (!this[index].flag) {
        stack.push(index);
      }
    }
  };
  Vertices2.prototype.each = function(indices, cb) {
    for (var i = 0, l = indices.length; i < l; i++) {
      var vertex = this[indices[i]];
      cb(vertex.key, vertex.val);
    }
  };
  return Vertices2;
})();
var IntStack = (function() {
  function IntStack2() {
    this.length = 0;
  }
  IntStack2.prototype.push = function(n) {
    this[this.length++] = n | 0;
  };
  IntStack2.prototype.pop = function() {
    return this[--this.length] | 0;
  };
  return IntStack2;
})();

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/debug/container-debug-adapter.js
var ContainerDebugAdapter = class extends EmberObject {
  constructor(owner) {
    super(owner);
    this.resolver = getOwner(this).lookup("resolver-for-debugging:main");
  }
  /**
    The resolver instance of the application
    being debugged. This property will be injected
    on creation.
     @property resolver
    @public
  */
  resolver;
  /**
    Returns true if it is possible to catalog a list of available
    classes in the resolver for a given type.
     @method canCatalogEntriesByType
    @param {String} type The type. e.g. "model", "controller", "route".
    @return {boolean} whether a list is available for this type.
    @public
  */
  canCatalogEntriesByType(type) {
    if (type === "model" || type === "template") {
      return false;
    }
    return true;
  }
  /**
    Returns the available classes a given type.
     @method catalogEntriesByType
    @param {String} type The type. e.g. "model", "controller", "route".
    @return {Array} An array of strings.
    @public
  */
  catalogEntriesByType(type) {
    let namespaces = Namespace.NAMESPACES;
    let types = [];
    let typeSuffixRegex = new RegExp(`${classify(type)}$`);
    namespaces.forEach((namespace) => {
      for (let key in namespace) {
        if (!Object.prototype.hasOwnProperty.call(namespace, key)) {
          continue;
        }
        if (typeSuffixRegex.test(key)) {
          let klass = namespace[key];
          if (typeOf(klass) === "class") {
            types.push(dasherize(key.replace(typeSuffixRegex, "")));
          }
        }
      }
    });
    return types;
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/component_lookup.js
var ComponentLookup = class extends EmberObject {
  componentFor(name, owner) {
    let fullName = `component:${name}`;
    return owner.factoryFor(fullName);
  }
  layoutFor(name, owner, options) {
    let templateFullName = `template:components/${name}`;
    return owner.lookup(templateFullName, options);
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/node/index.js
var NEEDS_EXTRA_CLOSE = /* @__PURE__ */ new WeakMap();
var SerializeBuilder = class extends NewTreeBuilder {
  __openBlock() {
    let {
      tagName
    } = this.element;
    if ("TITLE" !== tagName && "SCRIPT" !== tagName && "STYLE" !== tagName) {
      let depth = this.serializeBlockDepth++;
      this.__appendComment(`%+b:${depth}%`);
    }
    super.__openBlock();
  }
  __closeBlock() {
    let {
      tagName
    } = this.element;
    if (super.__closeBlock(), "TITLE" !== tagName && "SCRIPT" !== tagName && "STYLE" !== tagName) {
      let depth = --this.serializeBlockDepth;
      this.__appendComment(`%-b:${depth}%`);
    }
  }
  __appendHTML(html) {
    let {
      tagName
    } = this.element;
    if ("TITLE" === tagName || "SCRIPT" === tagName || "STYLE" === tagName) return super.__appendHTML(html);
    let first = this.__appendComment("%glmr%");
    if ("TABLE" === tagName) {
      let openIndex = html.indexOf("<");
      openIndex > -1 && "tr" === html.slice(openIndex + 1, openIndex + 3) && (html = `<tbody>${html}</tbody>`);
    }
    "" === html ? this.__appendComment("% %") : super.__appendHTML(html);
    let last = this.__appendComment("%glmr%");
    return new ConcreteBounds(this.element, first, last);
  }
  __appendText(string) {
    let {
      tagName
    } = this.element, current = (function(cursor) {
      let {
        element,
        nextSibling
      } = cursor;
      return null === nextSibling ? element.lastChild : nextSibling.previousSibling;
    })(this);
    return "TITLE" === tagName || "SCRIPT" === tagName || "STYLE" === tagName ? super.__appendText(string) : "" === string ? this.__appendComment("% %") : (current && 3 === current.nodeType && this.__appendComment("%|%"), super.__appendText(string));
  }
  closeElement() {
    return NEEDS_EXTRA_CLOSE.has(this.element) && (NEEDS_EXTRA_CLOSE.delete(this.element), super.closeElement()), super.closeElement();
  }
  openElement(tag) {
    return "tr" === tag && "TBODY" !== this.element.tagName && "THEAD" !== this.element.tagName && "TFOOT" !== this.element.tagName && (this.openElement("tbody"), // This prevents the closeBlock comment from being re-parented
    // under the auto inserted tbody. Rehydration builder needs to
    // account for the insertion since it is injected here and not
    // really in the template.
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    NEEDS_EXTRA_CLOSE.set(this.constructing, true), this.flushElement(null)), super.openElement(tag);
  }
  pushRemoteElement(element, cursorId, insertBefore = null) {
    let {
      dom
    } = this, script = dom.createElement("script");
    return script.setAttribute("glmr", cursorId), dom.insertBefore(element, script, insertBefore), super.pushRemoteElement(element, cursorId, insertBefore);
  }
  constructor(...args) {
    super(...args), this.serializeBlockDepth = 0;
  }
};
function serializeBuilder(env, cursor) {
  return SerializeBuilder.forInitialRender(env, cursor);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/setup-registry-DktVPnKH.js
function setupApplicationRegistry(registry) {
  registry.register("service:-dom-builder", {
    // Additionally, we *must* constrain this to require `props` on create, else
    // we *know* it cannot have an owner.
    create(props2) {
      let owner = getOwner(props2);
      !owner && assert("DomBuilderService is unexpectedly missing an owner", owner);
      let env = owner.lookup("-environment:main");
      switch (env._renderMode) {
        case "serialize":
          return serializeBuilder.bind(null);
        case "rehydrate":
          return rehydrationBuilder.bind(null);
        default:
          return clientBuilder.bind(null);
      }
    }
  });
  registry.register(privatize`template:-root`, RootTemplate);
  registry.register("renderer:-dom", Renderer);
}
function setupEngineRegistry(registry) {
  registry.optionsForType("template", {
    instantiate: false
  });
  registry.register("view:-outlet", OutletView);
  registry.register("template:-outlet", OutletTemplate);
  registry.optionsForType("helper", {
    instantiate: false
  });
  registry.register("component:input", Input);
  registry.register("component:link-to", LinkTo);
  registry.register("component:textarea", Textarea);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/engine/index.js
function props(obj) {
  let properties = [];
  for (let key in obj) {
    properties.push(key);
  }
  return properties;
}
var Engine = class extends Namespace.extend(RegistryProxyMixin) {
  static initializers = /* @__PURE__ */ Object.create(null);
  static instanceInitializers = /* @__PURE__ */ Object.create(null);
  /**
    The goal of initializers should be to register dependencies and injections.
    This phase runs once. Because these initializers may load code, they are
    allowed to defer application readiness and advance it. If you need to access
    the container or store you should use an InstanceInitializer that will be run
    after all initializers and therefore after all code is loaded and the app is
    ready.
     Initializer receives an object which has the following attributes:
    `name`, `before`, `after`, `initialize`. The only required attribute is
    `initialize`, all others are optional.
     * `name` allows you to specify under which name the initializer is registered.
    This must be a unique name, as trying to register two initializers with the
    same name will result in an error.
     ```app/initializer/named-initializer.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Running namedInitializer!');
    }
     export default {
      name: 'named-initializer',
      initialize
    };
    ```
     * `before` and `after` are used to ensure that this initializer is ran prior
    or after the one identified by the value. This value can be a single string
    or an array of strings, referencing the `name` of other initializers.
     An example of ordering initializers, we create an initializer named `first`:
     ```app/initializer/first.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('First initializer!');
    }
     export default {
      name: 'first',
      initialize
    };
    ```
     ```bash
    // DEBUG: First initializer!
    ```
     We add another initializer named `second`, specifying that it should run
    after the initializer named `first`:
     ```app/initializer/second.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Second initializer!');
    }
     export default {
      name: 'second',
      after: 'first',
      initialize
    };
    ```
     ```
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    ```
     Afterwards we add a further initializer named `pre`, this time specifying
    that it should run before the initializer named `first`:
     ```app/initializer/pre.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Pre initializer!');
    }
     export default {
      name: 'pre',
      before: 'first',
      initialize
    };
    ```
     ```bash
    // DEBUG: Pre initializer!
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    ```
     Finally we add an initializer named `post`, specifying it should run after
    both the `first` and the `second` initializers:
     ```app/initializer/post.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Post initializer!');
    }
     export default {
      name: 'post',
      after: ['first', 'second'],
      initialize
    };
    ```
     ```bash
    // DEBUG: Pre initializer!
    // DEBUG: First initializer!
    // DEBUG: Second initializer!
    // DEBUG: Post initializer!
    ```
     * `initialize` is a callback function that receives one argument,
      `application`, on which you can operate.
     Example of using `application` to register an adapter:
     ```app/initializer/api-adapter.js
    import ApiAdapter from '../utils/api-adapter';
     export function initialize(application) {
      application.register('api-adapter:main', ApiAdapter);
    }
     export default {
      name: 'post',
      after: ['first', 'second'],
      initialize
    };
    ```
     @method initializer
    @param initializer {Object}
    @public
  */
  static initializer = buildInitializerMethod("initializers", "initializer");
  /**
    Instance initializers run after all initializers have run. Because
    instance initializers run after the app is fully set up. We have access
    to the store, container, and other items. However, these initializers run
    after code has loaded and are not allowed to defer readiness.
     Instance initializer receives an object which has the following attributes:
    `name`, `before`, `after`, `initialize`. The only required attribute is
    `initialize`, all others are optional.
     * `name` allows you to specify under which name the instanceInitializer is
    registered. This must be a unique name, as trying to register two
    instanceInitializer with the same name will result in an error.
     ```app/initializer/named-instance-initializer.js
    import { debug } from '@ember/debug';
     export function initialize() {
      debug('Running named-instance-initializer!');
    }
     export default {
      name: 'named-instance-initializer',
      initialize
    };
    ```
     * `before` and `after` are used to ensure that this initializer is ran prior
    or after the one identified by the value. This value can be a single string
    or an array of strings, referencing the `name` of other initializers.
     * See Application.initializer for discussion on the usage of before
    and after.
     Example instanceInitializer to preload data into the store.
     ```app/initializer/preload-data.js
     export function initialize(application) {
        var userConfig, userConfigEncoded, store;
        // We have a HTML escaped JSON representation of the user's basic
        // configuration generated server side and stored in the DOM of the main
        // index.html file. This allows the app to have access to a set of data
        // without making any additional remote calls. Good for basic data that is
        // needed for immediate rendering of the page. Keep in mind, this data,
        // like all local models and data can be manipulated by the user, so it
        // should not be relied upon for security or authorization.
         // Grab the encoded data from the meta tag
        userConfigEncoded = document.querySelector('head meta[name=app-user-config]').attr('content');
         // Unescape the text, then parse the resulting JSON into a real object
        userConfig = JSON.parse(unescape(userConfigEncoded));
         // Lookup the store
        store = application.lookup('service:store');
         // Push the encoded JSON into the store
        store.pushPayload(userConfig);
    }
     export default {
      name: 'named-instance-initializer',
      initialize
    };
    ```
     @method instanceInitializer
    @param instanceInitializer
    @public
  */
  static instanceInitializer = buildInitializerMethod("instanceInitializers", "instance initializer");
  /**
    This creates a registry with the default Ember naming conventions.
     It also configures the registry:
     * registered views are created every time they are looked up (they are
      not singletons)
    * registered templates are not factories; the registered value is
      returned directly.
    * the router receives the application as its `namespace` property
    * all controllers receive the router as their `target` and `controllers`
      properties
    * all controllers receive the application as their `namespace` property
    * the application view receives the application controller as its
      `controller` property
    * the application view receives the application template as its
      `defaultTemplate` property
     @method buildRegistry
    @static
    @param {Application} namespace the application for which to
      build the registry
    @return {Ember.Registry} the built registry
    @private
  */
  static buildRegistry(namespace) {
    let registry = new Registry({
      resolver: resolverFor(namespace)
    });
    registry.set = set;
    registry.register("application:main", namespace, {
      instantiate: false
    });
    commonSetupRegistry(registry);
    setupEngineRegistry(registry);
    return registry;
  }
  /**
    Set this to provide an alternate class to `DefaultResolver`
     @property resolver
    @public
  */
  init(properties) {
    super.init(properties);
    this.buildRegistry();
  }
  /**
    A private flag indicating whether an engine's initializers have run yet.
     @private
    @property _initializersRan
  */
  _initializersRan = false;
  /**
    Ensure that initializers are run once, and only once, per engine.
     @private
    @method ensureInitializers
  */
  ensureInitializers() {
    if (!this._initializersRan) {
      this.runInitializers();
      this._initializersRan = true;
    }
  }
  /**
    Create an EngineInstance for this engine.
     @public
    @method buildInstance
    @return {EngineInstance} the engine instance
  */
  buildInstance(options = {}) {
    this.ensureInitializers();
    return EngineInstance.create({
      ...options,
      base: this
    });
  }
  /**
    Build and configure the registry for the current engine.
     @private
    @method buildRegistry
    @return {Ember.Registry} the configured registry
  */
  buildRegistry() {
    let registry = this.__registry__ = this.constructor.buildRegistry(this);
    return registry;
  }
  /**
    @private
    @method initializer
  */
  initializer(initializer) {
    this.constructor.initializer(initializer);
  }
  /**
    @private
    @method instanceInitializer
  */
  instanceInitializer(initializer) {
    this.constructor.instanceInitializer(initializer);
  }
  /**
    @private
    @method runInitializers
  */
  runInitializers() {
    this._runInitializer("initializers", (name, initializer) => {
      !initializer && assert(`No application initializer named '${name}'`, initializer);
      initializer.initialize(this);
    });
  }
  /**
    @private
    @since 1.12.0
    @method runInstanceInitializers
  */
  runInstanceInitializers(instance) {
    this._runInitializer("instanceInitializers", (name, initializer) => {
      !initializer && assert(`No instance initializer named '${name}'`, initializer);
      initializer.initialize(instance);
    });
  }
  _runInitializer(bucketName, cb) {
    let initializersByName = get(this.constructor, bucketName);
    let initializers = props(initializersByName);
    let graph = new DAG();
    let initializer;
    for (let name of initializers) {
      initializer = initializersByName[name];
      !initializer && assert(`missing ${bucketName}: ${name}`, initializer);
      graph.add(initializer.name, initializer, initializer.before, initializer.after);
    }
    graph.topsort(cb);
  }
};
function resolverFor(namespace) {
  let ResolverClass = namespace.Resolver;
  let props2 = {
    namespace
  };
  return ResolverClass.create(props2);
}
function buildInitializerMethod(bucketName, humanName) {
  return function(initializer) {
    let superclass = this.superclass;
    if (superclass[bucketName] !== void 0 && superclass[bucketName] === this[bucketName]) {
      let attrs = {
        [bucketName]: Object.create(this[bucketName])
      };
      this.reopenClass(attrs);
    }
    !!this[bucketName][initializer.name] && assert(`The ${humanName} '${initializer.name}' has already been registered`, !this[bucketName][initializer.name]);
    !canInvoke(initializer, "initialize") && assert(`An ${humanName} cannot be registered without an initialize function`, canInvoke(initializer, "initialize"));
    !(initializer.name !== void 0) && assert(`An ${humanName} cannot be registered without a name property`, initializer.name !== void 0);
    let initializers = this[bucketName];
    initializers[initializer.name] = initializer;
  };
}
function commonSetupRegistry(registry) {
  registry.optionsForType("component", {
    singleton: false
  });
  registry.optionsForType("view", {
    singleton: false
  });
  registry.register("controller:basic", Controller, {
    instantiate: false
  });
  registry.register("service:-routing", RoutingService);
  registry.register("resolver-for-debugging:main", registry.resolver, {
    instantiate: false
  });
  registry.register("container-debug-adapter:main", ContainerDebugAdapter);
  registry.register("component-lookup:main", ComponentLookup);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/application/index.js
var getOwner3 = getOwner2;
var setOwner2 = setOwner;
var Application = class _Application extends Engine {
  /**
    This creates a registry with the default Ember naming conventions.
     It also configures the registry:
     * registered views are created every time they are looked up (they are
      not singletons)
    * registered templates are not factories; the registered value is
      returned directly.
    * the router receives the application as its `namespace` property
    * all controllers receive the router as their `target` and `controllers`
      properties
    * all controllers receive the application as their `namespace` property
    * the application view receives the application controller as its
      `controller` property
    * the application view receives the application template as its
      `defaultTemplate` property
     @method buildRegistry
    @static
    @param {Application} namespace the application for which to
      build the registry
    @return {Ember.Registry} the built registry
    @private
  */
  static buildRegistry(namespace) {
    let registry = super.buildRegistry(namespace);
    commonSetupRegistry2(registry);
    setupApplicationRegistry(registry);
    return registry;
  }
  static initializer = buildInitializerMethod("initializers", "initializer");
  static instanceInitializer = buildInitializerMethod("instanceInitializers", "instance initializer");
  /**
    The root DOM element of the Application. This can be specified as an
    element or a [selector string](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors#reference_table_of_selectors).
     This is the element that will be passed to the Application's,
    `eventDispatcher`, which sets up the listeners for event delegation. Every
    view in your application should be a child of the element you specify here.
     @property rootElement
    @type DOMElement
    @default 'body'
    @public
  */
  /**
     @property _document
    @type Document | null
    @default 'window.document'
    @private
  */
  /**
    The `Ember.EventDispatcher` responsible for delegating events to this
    application's views.
     The event dispatcher is created by the application at initialization time
    and sets up event listeners on the DOM element described by the
    application's `rootElement` property.
     See the documentation for `Ember.EventDispatcher` for more information.
     @property eventDispatcher
    @type Ember.EventDispatcher
    @default null
    @public
  */
  /**
    The DOM events for which the event dispatcher should listen.
     By default, the application's `Ember.EventDispatcher` listens
    for a set of standard DOM events, such as `mousedown` and
    `keyup`, and delegates them to your application's `Ember.View`
    instances.
     If you would like additional bubbling events to be delegated to your
    views, set your `Application`'s `customEvents` property
    to a hash containing the DOM event name as the key and the
    corresponding view method name as the value. Setting an event to
    a value of `null` will prevent a default event listener from being
    added for that event.
     To add new events to be listened to:
     ```app/app.js
    import Application from '@ember/application';
     let App = Application.extend({
      customEvents: {
        // add support for the paste event
        paste: 'paste'
      }
    });
    ```
     To prevent default events from being listened to:
     ```app/app.js
    import Application from '@ember/application';
     let App = Application.extend({
      customEvents: {
        // remove support for mouseenter / mouseleave events
        mouseenter: null,
        mouseleave: null
      }
    });
    ```
    @property customEvents
    @type Object
    @default null
    @public
  */
  /**
    Whether the application should automatically start routing and render
    templates to the `rootElement` on DOM ready. While default by true,
    other environments such as FastBoot or a testing harness can set this
    property to `false` and control the precise timing and behavior of the boot
    process.
     @property autoboot
    @type Boolean
    @default true
    @private
  */
  /**
    Whether the application should be configured for the legacy "globals mode".
    Under this mode, the Application object serves as a global namespace for all
    classes.
     ```javascript
    import Application from '@ember/application';
    import Component from '@ember/component';
     let App = Application.create({
      ...
    });
     App.Router.reopen({
      location: 'none'
    });
     App.Router.map({
      ...
    });
     App.MyComponent = Component.extend({
      ...
    });
    ```
     This flag also exposes other internal APIs that assumes the existence of
    a special "default instance", like `App.__container__.lookup(...)`.
     This option is currently not configurable, its value is derived from
    the `autoboot` flag  disabling `autoboot` also implies opting-out of
    globals mode support, although they are ultimately orthogonal concerns.
     Some of the global modes features are already deprecated in 1.x. The
    existence of this flag is to untangle the globals mode code paths from
    the autoboot code paths, so that these legacy features can be reviewed
    for deprecation/removal separately.
     Forcing the (autoboot=true, _globalsMode=false) here and running the tests
    would reveal all the places where we are still relying on these legacy
    behavior internally (mostly just tests).
     @property _globalsMode
    @type Boolean
    @default true
    @private
  */
  /**
    An array of application instances created by `buildInstance()`. Used
    internally to ensure that all instances get destroyed.
     @property _applicationInstances
    @type Array
    @private
  */
  init(properties) {
    super.init(properties);
    this.rootElement ??= "body";
    this._document ??= null;
    this.eventDispatcher ??= null;
    this.customEvents ??= null;
    this.autoboot ??= true;
    this._document ??= hasDOM ? window.document : null;
    this._globalsMode ??= true;
    if (true) {
      if (ENV.LOG_VERSION) {
        ENV.LOG_VERSION = false;
        LIBRARIES.logVersions?.();
      }
    }
    this._readinessDeferrals = 1;
    this._booted = false;
    this._applicationInstances = /* @__PURE__ */ new Set();
    this.autoboot = this._globalsMode = Boolean(this.autoboot);
    if (this._globalsMode) {
      this._prepareForGlobalsMode();
    }
    if (this.autoboot) {
      this.waitForDOMReady();
    }
  }
  /**
    Create an ApplicationInstance for this application.
     @public
    @method buildInstance
    @return {ApplicationInstance} the application instance
  */
  buildInstance(options = {}) {
    !!this.isDestroyed && assert("You cannot build new instances of this application since it has already been destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot build new instances of this application since it is being destroyed", !this.isDestroying);
    return ApplicationInstance.create({
      ...options,
      base: this,
      application: this
    });
  }
  /**
    Start tracking an ApplicationInstance for this application.
    Used when the ApplicationInstance is created.
     @private
    @method _watchInstance
  */
  _watchInstance(instance) {
    this._applicationInstances.add(instance);
  }
  /**
    Stop tracking an ApplicationInstance for this application.
    Used when the ApplicationInstance is about to be destroyed.
     @private
    @method _unwatchInstance
  */
  _unwatchInstance(instance) {
    return this._applicationInstances.delete(instance);
  }
  Router;
  /**
    Enable the legacy globals mode by allowing this application to act
    as a global namespace. See the docs on the `_globalsMode` property
    for details.
     Most of these features are already deprecated in 1.x, so we can
    stop using them internally and try to remove them.
     @private
    @method _prepareForGlobalsMode
  */
  _prepareForGlobalsMode() {
    this.Router = (this.Router || EmberRouter).extend();
    this._buildDeprecatedInstance();
  }
  __deprecatedInstance__;
  __container__;
  /*
    Build the deprecated instance for legacy globals mode support.
    Called when creating and resetting the application.
     This is orthogonal to autoboot: the deprecated instance needs to
    be created at Application construction (not boot) time to expose
    App.__container__. If autoboot sees that this instance exists,
    it will continue booting it to avoid doing unncessary work (as
    opposed to building a new instance at boot time), but they are
    otherwise unrelated.
     @private
    @method _buildDeprecatedInstance
  */
  _buildDeprecatedInstance() {
    let instance = this.buildInstance();
    this.__deprecatedInstance__ = instance;
    this.__container__ = instance.__container__;
  }
  /**
    Automatically kick-off the boot process for the application once the
    DOM has become ready.
     The initialization itself is scheduled on the actions queue which
    ensures that code-loading finishes before booting.
     If you are asynchronously loading code, you should call `deferReadiness()`
    to defer booting, and then call `advanceReadiness()` once all of your code
    has finished loading.
     @private
    @method waitForDOMReady
  */
  waitForDOMReady() {
    const document2 = this._document;
    if (document2 === null || document2.readyState !== "loading") {
      schedule("actions", this, this.domReady);
    } else {
      !(function(d) {
        return typeof d.removeEventListener === "function";
      })(document2) && assert("[BUG] Called waitForDOMReady with an invalid document", (function(d) {
        return typeof d.removeEventListener === "function";
      })(document2));
      let callback = () => {
        document2.removeEventListener("DOMContentLoaded", callback);
        run(this, this.domReady);
      };
      document2.addEventListener("DOMContentLoaded", callback);
    }
  }
  /**
    This is the autoboot flow:
     1. Boot the app by calling `this.boot()`
    2. Create an instance (or use the `__deprecatedInstance__` in globals mode)
    3. Boot the instance by calling `instance.boot()`
    4. Invoke the `App.ready()` callback
    5. Kick-off routing on the instance
     Ideally, this is all we would need to do:
     ```javascript
    _autoBoot() {
      this.boot().then(() => {
        let instance = (this._globalsMode) ? this.__deprecatedInstance__ : this.buildInstance();
        return instance.boot();
      }).then((instance) => {
        App.ready();
        instance.startRouting();
      });
    }
    ```
     Unfortunately, we cannot actually write this because we need to participate
    in the "synchronous" boot process. While the code above would work fine on
    the initial boot (i.e. DOM ready), when `App.reset()` is called, we need to
    boot a new instance synchronously (see the documentation on `_bootSync()`
    for details).
     Because of this restriction, the actual logic of this method is located
    inside `didBecomeReady()`.
     @private
    @method domReady
  */
  domReady() {
    if (this.isDestroying || this.isDestroyed) {
      return;
    }
    this._bootSync();
  }
  /**
    Use this to defer readiness until some condition is true.
     Example:
     ```javascript
    import Application from '@ember/application';
     let App = Application.create();
     App.deferReadiness();
     fetch('/auth-token')
    .then(response => response.json())
    .then(data => {
      App.token = data.token;
      App.advanceReadiness();
    });
    ```
     This allows you to perform asynchronous setup logic and defer
    booting your application until the setup has finished.
     However, if the setup requires a loading UI, it might be better
    to use the router for this purpose.
     @method deferReadiness
    @public
  */
  deferReadiness() {
    !(this instanceof _Application) && assert("You must call deferReadiness on an instance of Application", this instanceof _Application);
    !!this.isDestroyed && assert("You cannot defer readiness since application has already destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot defer readiness since the application is being destroyed", !this.isDestroying);
    !(this._readinessDeferrals > 0) && assert("You cannot defer readiness since the `ready()` hook has already been called", this._readinessDeferrals > 0);
    this._readinessDeferrals++;
  }
  /**
    Call `advanceReadiness` after any asynchronous setup logic has completed.
    Each call to `deferReadiness` must be matched by a call to `advanceReadiness`
    or the application will never become ready and routing will not begin.
     @method advanceReadiness
    @see {Application#deferReadiness}
    @public
  */
  advanceReadiness() {
    !(this instanceof _Application) && assert("You must call advanceReadiness on an instance of Application", this instanceof _Application);
    !!this.isDestroyed && assert("You cannot advance readiness since application has already destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot advance readiness since the application is being destroyed", !this.isDestroying);
    !(this._readinessDeferrals > 0) && assert("You cannot advance readiness since the `ready()` hook has already been called", this._readinessDeferrals > 0);
    this._readinessDeferrals--;
    if (this._readinessDeferrals === 0) {
      once(this, this.didBecomeReady);
    }
  }
  _bootPromise = null;
  /**
    Initialize the application and return a promise that resolves with the `Application`
    object when the boot process is complete.
     Run any application initializers and run the application load hook. These hooks may
    choose to defer readiness. For example, an authentication hook might want to defer
    readiness until the auth token has been retrieved.
     By default, this method is called automatically on "DOM ready"; however, if autoboot
    is disabled, this is automatically called when the first application instance is
    created via `visit`.
     @public
    @method boot
    @return {Promise<Application,Error>}
  */
  boot() {
    !!this.isDestroyed && assert("You cannot boot this application since it has already been destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot boot this application since it is being destroyed", !this.isDestroying);
    if (this._bootPromise) {
      return this._bootPromise;
    }
    try {
      this._bootSync();
    } catch (_) {
    }
    !this._bootPromise && assert("has boot promise", this._bootPromise);
    return this._bootPromise;
  }
  _bootResolver = null;
  /**
    Unfortunately, a lot of existing code assumes the booting process is
    "synchronous". Specifically, a lot of tests assumes the last call to
    `app.advanceReadiness()` or `app.reset()` will result in the app being
    fully-booted when the current runloop completes.
     We would like new code (like the `visit` API) to stop making this assumption,
    so we created the asynchronous version above that returns a promise. But until
    we have migrated all the code, we would have to expose this method for use
    *internally* in places where we need to boot an app "synchronously".
     @private
  */
  _bootSync() {
    if (this._booted || this.isDestroying || this.isDestroyed) {
      return;
    }
    let defer = this._bootResolver = RSVP$1.defer();
    this._bootPromise = defer.promise;
    try {
      this.runInitializers();
      runLoadHooks("application", this);
      this.advanceReadiness();
    } catch (error) {
      defer.reject(error);
      throw error;
    }
  }
  /**
    Reset the application. This is typically used only in tests. It cleans up
    the application in the following order:
     1. Deactivate existing routes
    2. Destroy all objects in the container
    3. Create a new application container
    4. Re-route to the existing url
     Typical Example:
     ```javascript
    import Application from '@ember/application';
    let App;
     run(function() {
      App = Application.create();
    });
     module('acceptance test', {
      setup: function() {
        App.reset();
      }
    });
     test('first test', function() {
      // App is freshly reset
    });
     test('second test', function() {
      // App is again freshly reset
    });
    ```
     Advanced Example:
     Occasionally you may want to prevent the app from initializing during
    setup. This could enable extra configuration, or enable asserting prior
    to the app becoming ready.
     ```javascript
    import Application from '@ember/application';
    let App;
     run(function() {
      App = Application.create();
    });
     module('acceptance test', {
      setup: function() {
        run(function() {
          App.reset();
          App.deferReadiness();
        });
      }
    });
     test('first test', function() {
      ok(true, 'something before app is initialized');
       run(function() {
        App.advanceReadiness();
      });
       ok(true, 'something after app is initialized');
    });
    ```
     @method reset
    @public
  */
  reset() {
    !!this.isDestroyed && assert("You cannot reset this application since it has already been destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot reset this application since it is being destroyed", !this.isDestroying);
    !(this._globalsMode && this.autoboot) && assert(`Calling reset() on instances of \`Application\` is not
            supported when globals mode is disabled; call \`visit()\` to
            create new \`ApplicationInstance\`s and dispose them
            via their \`destroy()\` method instead.`, this._globalsMode && this.autoboot);
    let instance = this.__deprecatedInstance__;
    this._readinessDeferrals = 1;
    this._bootPromise = null;
    this._bootResolver = null;
    this._booted = false;
    function handleReset() {
      !instance && assert("expected instance", instance);
      run(instance, "destroy");
      this._buildDeprecatedInstance();
      schedule("actions", this, "_bootSync");
    }
    join(this, handleReset);
  }
  /**
    @private
    @method didBecomeReady
  */
  didBecomeReady() {
    if (this.isDestroying || this.isDestroyed) {
      return;
    }
    !this._bootResolver && assert("expected _bootResolver", this._bootResolver);
    try {
      if (this.autoboot) {
        let instance;
        if (this._globalsMode) {
          instance = this.__deprecatedInstance__;
          !instance && assert("expected instance", instance);
        } else {
          instance = this.buildInstance();
        }
        instance._bootSync();
        this.ready();
        instance.startRouting();
      }
      this._bootResolver.resolve(this);
      this._booted = true;
    } catch (error) {
      this._bootResolver.reject(error);
      throw error;
    }
  }
  /**
    Called when the Application has become ready, immediately before routing
    begins. The call will be delayed until the DOM has become ready.
     @event ready
    @public
  */
  ready() {
    return this;
  }
  // This method must be moved to the application instance object
  willDestroy() {
    super.willDestroy();
    if (_loaded["application"] === this) {
      _loaded["application"] = void 0;
    }
    if (this._applicationInstances.size) {
      this._applicationInstances.forEach((i) => i.destroy());
      this._applicationInstances.clear();
    }
  }
  /**
    Boot a new instance of `ApplicationInstance` for the current
    application and navigate it to the given `url`. Returns a `Promise` that
    resolves with the instance when the initial routing and rendering is
    complete, or rejects with any error that occurred during the boot process.
     When `autoboot` is disabled, calling `visit` would first cause the
    application to boot, which runs the application initializers.
     This method also takes a hash of boot-time configuration options for
    customizing the instance's behavior. See the documentation on
    `ApplicationInstance.BootOptions` for details.
     `ApplicationInstance.BootOptions` is an interface class that exists
    purely to document the available options; you do not need to construct it
    manually. Simply pass a regular JavaScript object containing of the
    desired options:
     ```javascript
    MyApp.visit("/", { location: "none", rootElement: "#container" });
    ```
     ### Supported Scenarios
     While the `BootOptions` class exposes a large number of knobs, not all
    combinations of them are valid; certain incompatible combinations might
    result in unexpected behavior.
     For example, booting the instance in the full browser environment
    while specifying a foreign `document` object (e.g. `{ isBrowser: true,
    document: iframe.contentDocument }`) does not work correctly today,
    largely due to Ember's jQuery dependency.
     Currently, there are three officially supported scenarios/configurations.
    Usages outside of these scenarios are not guaranteed to work, but please
    feel free to file bug reports documenting your experience and any issues
    you encountered to help expand support.
     #### Browser Applications (Manual Boot)
     The setup is largely similar to how Ember works out-of-the-box. Normally,
    Ember will boot a default instance for your Application on "DOM ready".
    However, you can customize this behavior by disabling `autoboot`.
     For example, this allows you to render a miniture demo of your application
    into a specific area on your marketing website:
     ```javascript
    import MyApp from 'my-app';
     $(function() {
      let App = MyApp.create({ autoboot: false });
       let options = {
        // Override the router's location adapter to prevent it from updating
        // the URL in the address bar
        location: 'none',
         // Override the default `rootElement` on the app to render into a
        // specific `div` on the page
        rootElement: '#demo'
      };
       // Start the app at the special demo URL
      App.visit('/demo', options);
    });
    ```
     Or perhaps you might want to boot two instances of your app on the same
    page for a split-screen multiplayer experience:
     ```javascript
    import MyApp from 'my-app';
     $(function() {
      let App = MyApp.create({ autoboot: false });
       let sessionId = MyApp.generateSessionID();
       let player1 = App.visit(`/matches/join?name=Player+1&session=${sessionId}`, { rootElement: '#left', location: 'none' });
      let player2 = App.visit(`/matches/join?name=Player+2&session=${sessionId}`, { rootElement: '#right', location: 'none' });
       Promise.all([player1, player2]).then(() => {
        // Both apps have completed the initial render
        $('#loading').fadeOut();
      });
    });
    ```
     Do note that each app instance maintains their own registry/container, so
    they will run in complete isolation by default.
     #### Server-Side Rendering (also known as FastBoot)
     This setup allows you to run your Ember app in a server environment using
    Node.js and render its content into static HTML for SEO purposes.
     ```javascript
    const HTMLSerializer = new SimpleDOM.HTMLSerializer(SimpleDOM.voidMap);
     function renderURL(url) {
      let dom = new SimpleDOM.Document();
      let rootElement = dom.body;
      let options = { isBrowser: false, document: dom, rootElement: rootElement };
       return MyApp.visit(options).then(instance => {
        try {
          return HTMLSerializer.serialize(rootElement.firstChild);
        } finally {
          instance.destroy();
        }
      });
    }
    ```
     In this scenario, because Ember does not have access to a global `document`
    object in the Node.js environment, you must provide one explicitly. In practice,
    in the non-browser environment, the stand-in `document` object only needs to
    implement a limited subset of the full DOM API. The `SimpleDOM` library is known
    to work.
     Since there is no DOM access in the non-browser environment, you must also
    specify a DOM `Element` object in the same `document` for the `rootElement` option
    (as opposed to a selector string like `"body"`).
     See the documentation on the `isBrowser`, `document` and `rootElement` properties
    on `ApplicationInstance.BootOptions` for details.
     #### Server-Side Resource Discovery
     This setup allows you to run the routing layer of your Ember app in a server
    environment using Node.js and completely disable rendering. This allows you
    to simulate and discover the resources (i.e. AJAX requests) needed to fulfill
    a given request and eagerly "push" these resources to the client.
     ```app/initializers/network-service.js
    import BrowserNetworkService from 'app/services/network/browser';
    import NodeNetworkService from 'app/services/network/node';
     // Inject a (hypothetical) service for abstracting all AJAX calls and use
    // the appropriate implementation on the client/server. This also allows the
    // server to log all the AJAX calls made during a particular request and use
    // that for resource-discovery purpose.
     export function initialize(application) {
      if (window) { // browser
        application.register('service:network', BrowserNetworkService);
      } else { // node
        application.register('service:network', NodeNetworkService);
      }
    };
     export default {
      name: 'network-service',
      initialize: initialize
    };
    ```
     ```app/routes/post.js
    import Route from '@ember/routing/route';
    import { service } from '@ember/service';
     // An example of how the (hypothetical) service is used in routes.
     export default class IndexRoute extends Route {
      @service network;
       model(params) {
        return this.network.fetch(`/api/posts/${params.post_id}.json`);
      }
       afterModel(post) {
        if (post.isExternalContent) {
          return this.network.fetch(`/api/external/?url=${post.externalURL}`);
        } else {
          return post;
        }
      }
    }
    ```
     ```javascript
    // Finally, put all the pieces together
     function discoverResourcesFor(url) {
      return MyApp.visit(url, { isBrowser: false, shouldRender: false }).then(instance => {
        let networkService = instance.lookup('service:network');
        return networkService.requests; // => { "/api/posts/123.json": "..." }
      });
    }
    ```
     @public
    @method visit
    @param url {String} The initial URL to navigate to
    @param options {ApplicationInstance.BootOptions}
    @return {Promise<ApplicationInstance, Error>}
  */
  visit(url, options) {
    !!this.isDestroyed && assert("You cannot visit this application since it has already been destroyed", !this.isDestroyed);
    !!this.isDestroying && assert("You cannot visit this application since it is being destroyed", !this.isDestroying);
    return this.boot().then(() => {
      let instance = this.buildInstance();
      return instance.boot(options).then(() => instance.visit(url)).catch((error) => {
        run(instance, "destroy");
        throw error;
      });
    });
  }
};
function commonSetupRegistry2(registry) {
  registry.register("router:main", EmberRouter);
  registry.register("-view-registry:main", {
    create() {
      return makeDictionary(null);
    }
  });
  registry.register("route:basic", Route);
  registry.register("event_dispatcher:main", EventDispatcher);
  registry.register("location:hash", HashLocation);
  registry.register("location:history", HistoryLocation);
  registry.register("location:none", NoneLocation);
  registry.register(privatize`-bucket-cache:main`, {
    create() {
      return new BucketCache();
    }
  });
  registry.register("service:router", RouterService);
}

export {
  _loaded,
  onLoad,
  runLoadHooks,
  getOwner3 as getOwner,
  setOwner2 as setOwner,
  Application
};
//# sourceMappingURL=chunk-SNOZTKEA.js.map
