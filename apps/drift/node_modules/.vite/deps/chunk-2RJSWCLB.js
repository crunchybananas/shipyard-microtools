import {
  opcodes,
  templateFactory
} from "./chunk-MHMOQE3O.js";
import {
  $fp,
  $pc,
  $ra,
  $s0,
  $sp,
  $t0,
  $t1,
  $v0,
  ARG_SHIFT,
  CONSTANT_TAG,
  CURRENT_TAG,
  ContentType,
  EMPTY_STRING_ARRAY,
  FALSE_REFERENCE,
  INITIAL,
  InternalComponentCapabilities,
  MACHINE_MASK,
  NULL_REFERENCE,
  OPERAND_LEN_MASK,
  StackImpl,
  TRUE_REFERENCE,
  TYPE_MASK,
  UNDEFINED_REFERENCE,
  UPDATE_TAG,
  _hasDestroyableChildren,
  assertGlobalContextWasSet,
  assign,
  associateDestroyableChild,
  beginTrackFrame,
  capabilityFlagsFrom,
  childRefFor,
  clearElement,
  consumeTag,
  createComputeRef,
  createConstRef,
  createDebugAliasRef,
  createIteratorItemRef,
  createIteratorRef,
  createPrimitiveRef,
  createUpdatableTag,
  debug,
  debugAssert,
  destroy,
  destroyChildren,
  dict,
  emptyArray,
  endTrackFrame,
  enumerate,
  getComponentTemplate,
  getInternalComponentManager,
  getInternalHelperManager,
  getInternalModifierManager,
  getPath,
  hasInternalComponentManager,
  hasInternalHelperManager,
  isConstRef,
  isDict,
  isIndexable,
  isInvokableRef,
  isLowLevelRegister,
  managerHasCapability,
  registerDestructor,
  resetTracking,
  reverse,
  setInternalComponentManager,
  setInternalHelperManager,
  setInternalModifierManager,
  setPath,
  toBool,
  track,
  updateRef,
  validateTag,
  valueForRef,
  valueForTag,
  warnIfStyleNotTrusted
} from "./chunk-HJOPXKLZ.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/program/index.js
function unwrapTemplate(template) {
  if ("error" === template.result) throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);
  return template;
}
var DEFAULT_TEMPLATE_BLOCK = [[[opcodes.Yield, 1, null]], ["&default"], []];
var DEFAULT_TEMPLATE = {
  // random uuid
  id: "1b32f5c2-7623-43d6-a0ad-9672898920a1",
  moduleName: "__default__.hbs",
  block: JSON.stringify(DEFAULT_TEMPLATE_BLOCK),
  scope: null,
  isStrictMode: true
};
var WELL_KNOWN_EMPTY_ARRAY = Object.freeze([]);
var STARTER_CONSTANTS = [false, true, null, void 0, WELL_KNOWN_EMPTY_ARRAY];
var WELL_KNOWN_EMPTY_ARRAY_POSITION = STARTER_CONSTANTS.indexOf(WELL_KNOWN_EMPTY_ARRAY);
var ConstantsImpl = class {
  value(value) {
    let indexMap = this.indexMap, index = indexMap.get(value);
    return void 0 === index && (index = this.values.push(value) - 1, indexMap.set(value, index)), index;
  }
  array(values) {
    if (0 === values.length) return WELL_KNOWN_EMPTY_ARRAY_POSITION;
    let handles = new Array(values.length);
    for (let i = 0; i < values.length; i++) handles[i] = this.value(values[i]);
    return this.value(handles);
  }
  toPool() {
    return this.values;
  }
  hasHandle(handle) {
    return this.values.length > handle;
  }
  helper(definitionState, _resolvedName = null, isOptional) {
    let handle = this.helperDefinitionCache.get(definitionState);
    if (void 0 === handle) {
      let managerOrHelper = getInternalHelperManager(definitionState, isOptional);
      if (null === managerOrHelper) return this.helperDefinitionCache.set(definitionState, null), null;
      let helper2 = "function" == typeof managerOrHelper ? managerOrHelper : managerOrHelper.getHelper(definitionState);
      handle = this.value(helper2), this.helperDefinitionCache.set(definitionState, handle), this.helperDefinitionCount++;
    }
    return handle;
  }
  modifier(definitionState, resolvedName = null, isOptional) {
    let handle = this.modifierDefinitionCache.get(definitionState);
    if (void 0 === handle) {
      let manager = getInternalModifierManager(definitionState, isOptional);
      if (null === manager) return this.modifierDefinitionCache.set(definitionState, null), null;
      let definition = {
        resolvedName,
        manager,
        state: definitionState
      };
      handle = this.value(definition), this.modifierDefinitionCache.set(definitionState, handle), this.modifierDefinitionCount++;
    }
    return handle;
  }
  component(definitionState, owner, isOptional, debugName) {
    let definition = this.componentDefinitionCache.get(definitionState);
    if (void 0 === definition) {
      let manager = getInternalComponentManager(definitionState, isOptional);
      if (null === manager) return this.componentDefinitionCache.set(definitionState, null), null;
      let template, capabilities = capabilityFlagsFrom(manager.getCapabilities(definitionState)), templateFactory2 = getComponentTemplate(definitionState), compilable = null;
      template = managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout) ? templateFactory2?.(owner) : templateFactory2?.(owner) ?? this.defaultTemplate, void 0 !== template && (template = unwrapTemplate(template), compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? template.asWrappedLayout() : template.asLayout()), definition = {
        resolvedName: null,
        handle: -1,
        manager,
        capabilities,
        state: definitionState,
        compilable
      }, definition.handle = this.value(definition), debugName && (definition.debugName = debugName), this.componentDefinitionCache.set(definitionState, definition), this.componentDefinitionCount++;
    }
    return definition;
  }
  resolvedComponent(resolvedDefinition, resolvedName) {
    let definition = this.componentDefinitionCache.get(resolvedDefinition);
    if (void 0 === definition) {
      let {
        manager,
        state,
        template
      } = resolvedDefinition, capabilities = capabilityFlagsFrom(manager.getCapabilities(resolvedDefinition)), compilable = null;
      managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout) || (template = template ?? this.defaultTemplate), null !== template && (template = unwrapTemplate(template), compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? template.asWrappedLayout() : template.asLayout()), definition = {
        resolvedName,
        handle: -1,
        manager,
        capabilities,
        state,
        compilable
      }, definition.handle = this.value(definition), this.componentDefinitionCache.set(resolvedDefinition, definition), this.componentDefinitionCount++;
    }
    return definition;
  }
  getValue(index) {
    return this.values[index];
  }
  getArray(index) {
    let reifiedArrs = this.reifiedArrs, reified = reifiedArrs[index];
    if (void 0 === reified) {
      let names = this.getValue(index);
      reified = new Array(names.length);
      for (const [i, name] of enumerate(names)) reified[i] = this.getValue(name);
      reifiedArrs[index] = reified;
    }
    return reified;
  }
  constructor() {
    this.reifiedArrs = {
      [WELL_KNOWN_EMPTY_ARRAY_POSITION]: WELL_KNOWN_EMPTY_ARRAY
    }, this.defaultTemplate = templateFactory(DEFAULT_TEMPLATE)(), // Used for tests and debugging purposes, and to be able to analyze large apps
    // This is why it's enabled even in production
    this.helperDefinitionCount = 0, this.modifierDefinitionCount = 0, this.componentDefinitionCount = 0, this.values = STARTER_CONSTANTS.slice(), this.indexMap = new Map(this.values.map((value, index) => [value, index])), this.helperDefinitionCache = /* @__PURE__ */ new WeakMap(), this.modifierDefinitionCache = /* @__PURE__ */ new WeakMap(), this.componentDefinitionCache = /* @__PURE__ */ new WeakMap();
  }
};
var RuntimeOpImpl = class {
  constructor(heap) {
    this.heap = heap, this.offset = 0;
  }
  get size() {
    return 1 + ((this.heap.getbyaddr(this.offset) & OPERAND_LEN_MASK) >> ARG_SHIFT);
  }
  get isMachine() {
    return this.heap.getbyaddr(this.offset) & MACHINE_MASK ? 1 : 0;
  }
  get type() {
    return this.heap.getbyaddr(this.offset) & TYPE_MASK;
  }
  get op1() {
    return this.heap.getbyaddr(this.offset + 1);
  }
  get op2() {
    return this.heap.getbyaddr(this.offset + 2);
  }
  get op3() {
    return this.heap.getbyaddr(this.offset + 3);
  }
};
var ProgramHeapImpl = class {
  constructor() {
    this.offset = 0, this.handle = 0, this.heap = new Int32Array(1048576), this.handleTable = [], this.handleState = [];
  }
  entries() {
    return this.offset;
  }
  pushRaw(value) {
    this.sizeCheck(), this.heap[this.offset++] = value;
  }
  pushOp(item) {
    this.pushRaw(item);
  }
  pushMachine(item) {
    this.pushRaw(item | MACHINE_MASK);
  }
  sizeCheck() {
    let {
      heap
    } = this;
    if (this.offset === this.heap.length) {
      let newHeap = new Int32Array(heap.length + 1048576);
      newHeap.set(heap, 0), this.heap = newHeap;
    }
  }
  getbyaddr(address) {
    return this.heap[address];
  }
  setbyaddr(address, value) {
    this.heap[address] = value;
  }
  malloc() {
    return this.handleTable.push(this.offset), this.handleTable.length - 1;
  }
  finishMalloc(handle) {
  }
  size() {
    return this.offset;
  }
  // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.
  getaddr(handle) {
    return this.handleTable[handle];
  }
  sizeof(handle) {
    return this.handleTable, -1;
  }
  free(handle) {
    this.handleState[handle] = 1;
  }
  /**
  * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
  * reachable memory to the bottom of the heap and freeable
  * memory to the top of the heap. When we have shifted all
  * the reachable memory to the top of the heap, we move the
  * offset to the next free position.
  */
  compact() {
    let compactedSize = 0, {
      handleTable,
      handleState,
      heap
    } = this;
    for (let i = 0; i < length; i++) {
      let offset = handleTable[i], size = handleTable[i + 1] - offset, state = handleState[i];
      if (2 !== state) if (1 === state)
        handleState[i] = 2, compactedSize += size;
      else if (0 === state) {
        for (let j = offset; j <= i + size; j++) heap[j - compactedSize] = heap[j];
        handleTable[i] = offset - compactedSize;
      } else 3 === state && (handleTable[i] = offset - compactedSize);
    }
    this.offset = this.offset - compactedSize;
  }
};
var ProgramImpl = class {
  constructor(constants, heap) {
    this.constants = constants, this.heap = heap, this._opcode = new RuntimeOpImpl(this.heap);
  }
  opcode(offset) {
    return this._opcode.offset = offset, this._opcode;
  }
};
function artifacts() {
  return {
    constants: new ConstantsImpl(),
    heap: new ProgramHeapImpl()
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/runtime/index.js
var NS_MATHML = "http://www.w3.org/1998/Math/MathML";
var NS_SVG = "http://www.w3.org/2000/svg";
var debugToString;
if (true) {
  let getFunctionName = (fn2) => {
    let functionName = fn2.name;
    if ("" === functionName) {
      let match = /function (\w+)\s*\(/u.exec(String(fn2));
      functionName = match && match[1] || "";
    }
    return functionName.replace(/^bound /u, "");
  }, getObjectName = (obj) => {
    let name, className;
    return "function" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), "toString" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && // eslint-disable-next-line @typescript-eslint/no-base-to-string
    (name = obj.toString()), name && /<.*:ember\d+>/u.test(name) && className && "_" !== className[0] && className.length > 2 && "Class" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;
  }, getPrimitiveName = (value) => String(value);
  debugToString = (value) => "function" == typeof value ? getFunctionName(value) || "(unknown function)" : "object" == typeof value && null !== value ? getObjectName(value) || "(unknown object)" : getPrimitiveName(value);
}
var debugToString$1 = debugToString;
function castToSimple(node) {
  return (function(node2) {
    node2.nodeType;
  })(node), node;
}
function unwrapHandle(handle) {
  if ("number" == typeof handle) return handle;
  {
    let error = handle.errors[0];
    throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`);
  }
}
function unwrapTemplate2(template) {
  if ("error" === template.result) throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);
  return template;
}
function buildUntouchableThis(source) {
  let context2 = null;
  if (true) {
    let assertOnProperty = (property) => {
      let access = "symbol" == typeof property || "number" == typeof property ? `[${String(property)}]` : `.${property}`;
      throw new Error(`You accessed \`this${access}\` from a function passed to the ${source}, but the function itself was not bound to a valid \`this\` context. Consider updating to use a bound function (for instance, use an arrow function, \`() => {}\`).`);
    };
    context2 = new Proxy({}, {
      get(_target, property) {
        assertOnProperty(property);
      },
      set: (_target, property) => (assertOnProperty(property), false),
      has: (_target, property) => (assertOnProperty(property), false)
    });
  }
  return context2;
}
function decodeImmediate(num) {
  return (num |= 0) > -536870913 ? (function(num2) {
    return ~num2;
  })(num) : (function(num2) {
    return 536870912 | num2;
  })(num);
}
[1, -1].forEach((x) => {
  return decodeImmediate((num = x, (num |= 0) < 0 ? (function(num2) {
    return -536870913 & num2;
  })(num) : (function(num2) {
    return ~num2;
  })(num)));
  var num;
});
var APPEND_OPCODES = new class {
  constructor() {
    this.evaluateOpcode = new Array(113).fill(null);
  }
  add(name, evaluate, kind = "syscall") {
    this.evaluateOpcode[name] = {
      syscall: "machine" !== kind,
      evaluate
    };
  }
  evaluate(vm, opcode, type) {
    let operation = this.evaluateOpcode[type];
    operation.syscall ? (opcode.isMachine, operation.syscall, opcode.isMachine, opcode.type, operation.evaluate(vm, opcode)) : (opcode.isMachine, operation.syscall, opcode.isMachine, opcode.type, operation.evaluate(vm.lowlevel, opcode));
  }
}();
var TYPE = Symbol("TYPE");
var INNER = Symbol("INNER");
var OWNER = Symbol("OWNER");
var ARGS = Symbol("ARGS");
var RESOLVED = Symbol("RESOLVED");
var CURRIED_VALUES = /* @__PURE__ */ new WeakSet();
function isCurriedValue(value) {
  return CURRIED_VALUES.has(value);
}
function isCurriedType(value, type) {
  return isCurriedValue(value) && value[TYPE] === type;
}
var CurriedValue = class {
  /** @internal */
  constructor(type, inner, owner, args, resolved = false) {
    CURRIED_VALUES.add(this), this[TYPE] = type, this[INNER] = inner, this[OWNER] = owner, this[ARGS] = args, this[RESOLVED] = resolved;
  }
};
function resolveCurriedValue(curriedValue) {
  let positional, named, definition, owner, resolved, currentWrapper = curriedValue;
  for (; ; ) {
    let {
      [ARGS]: curriedArgs,
      [INNER]: inner
    } = currentWrapper;
    if (null !== curriedArgs) {
      let {
        named: curriedNamed,
        positional: curriedPositional
      } = curriedArgs;
      curriedPositional.length > 0 && (positional = void 0 === positional ? curriedPositional : curriedPositional.concat(positional)), void 0 === named && (named = []), named.unshift(curriedNamed);
    }
    if (!isCurriedValue(inner)) {
      definition = inner, owner = currentWrapper[OWNER], resolved = currentWrapper[RESOLVED];
      break;
    }
    currentWrapper = inner;
  }
  return {
    definition,
    owner,
    resolved,
    positional,
    named
  };
}
function curry(type, spec, owner, args, resolved = false) {
  return new CurriedValue(type, spec, owner, args, resolved);
}
var DynamicScopeImpl = class _DynamicScopeImpl {
  constructor(bucket) {
    this.bucket = bucket ? assign({}, bucket) : {};
  }
  get(key) {
    return this.bucket[key];
  }
  set(key, reference) {
    return this.bucket[key] = reference;
  }
  child() {
    return new _DynamicScopeImpl(this.bucket);
  }
};
var ScopeImpl = class _ScopeImpl {
  static root(owner, {
    self,
    size = 0
  }) {
    let refs = new Array(size + 1).fill(UNDEFINED_REFERENCE);
    return new _ScopeImpl(owner, refs, null).init({
      self
    });
  }
  static sized(owner, size = 0) {
    let refs = new Array(size + 1).fill(UNDEFINED_REFERENCE);
    return new _ScopeImpl(owner, refs, null);
  }
  constructor(owner, slots, callerScope) {
    this.owner = owner, this.slots = slots, this.callerScope = callerScope;
  }
  init({
    self
  }) {
    return this.slots[0] = self, this;
  }
  /**
  * @debug
  */
  snapshot() {
    return this.slots.slice();
  }
  getSelf() {
    return this.get(0);
  }
  getSymbol(symbol) {
    return this.get(symbol);
  }
  getBlock(symbol) {
    let block = this.get(symbol);
    return block === UNDEFINED_REFERENCE ? null : block;
  }
  bind(symbol, value) {
    this.set(symbol, value);
  }
  bindSelf(self) {
    this.set(0, self);
  }
  bindSymbol(symbol, value) {
    this.set(symbol, value);
  }
  bindBlock(symbol, value) {
    this.set(symbol, value);
  }
  bindCallerScope(scope) {
    this.callerScope = scope;
  }
  getCallerScope() {
    return this.callerScope;
  }
  child() {
    return new _ScopeImpl(this.owner, this.slots.slice(), this.callerScope);
  }
  get(index) {
    if (index >= this.slots.length) throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);
    return this.slots[index];
  }
  set(index, value) {
    if (index >= this.slots.length) throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);
    this.slots[index] = value;
  }
};
var CursorImpl = class {
  constructor(element, nextSibling) {
    this.element = element, this.nextSibling = nextSibling;
  }
};
var ConcreteBounds = class {
  constructor(parentNode, first, last) {
    this.parentNode = parentNode, this.first = first, this.last = last;
  }
  parentElement() {
    return this.parentNode;
  }
  firstNode() {
    return this.first;
  }
  lastNode() {
    return this.last;
  }
};
function move(bounds, reference) {
  let parent = bounds.parentElement(), first = bounds.firstNode(), last = bounds.lastNode(), current = first;
  for (; ; ) {
    let next = current.nextSibling;
    if (parent.insertBefore(current, reference), current === last) return next;
    current = next;
  }
}
function clear(bounds) {
  let parent = bounds.parentElement(), first = bounds.firstNode(), last = bounds.lastNode(), current = first;
  for (; ; ) {
    let next = current.nextSibling;
    if (parent.removeChild(current), current === last) return next;
    current = next;
  }
}
function hasCustomDebugRenderTreeLifecycle(manager) {
  return "getDebugCustomRenderTree" in manager;
}
var GUID = 0;
var Ref = class {
  constructor(value) {
    this.id = GUID++, this.value = value;
  }
  get() {
    return this.value;
  }
  release() {
    if (null === this.value) throw new Error("BUG: double release?");
    this.value = null;
  }
  toString() {
    let label = `Ref ${this.id}`;
    if (null === this.value) return `${label} (released)`;
    try {
      return `${label}: ${this.value}`;
    } catch {
      return label;
    }
  }
};
var DebugRenderTreeImpl = class {
  begin() {
    this.reset();
  }
  create(state, node) {
    let internalNode = assign({}, node, {
      bounds: null,
      refs: /* @__PURE__ */ new Set()
    });
    this.nodes.set(state, internalNode), this.appendChild(internalNode, state), this.enter(state);
  }
  update(state) {
    this.enter(state);
  }
  didRender(state, bounds) {
    if (this.stack.current !== state)
      throw new Error(`BUG: expecting ${this.stack.current}, got ${state}`);
    this.nodeFor(state).bounds = bounds, this.exit();
  }
  willDestroy(state) {
    this.refs.get(state).release();
  }
  commit() {
    this.reset();
  }
  capture() {
    return this.captureRefs(this.roots);
  }
  reset() {
    if (0 !== this.stack.size) {
      let root = this.stack.toArray()[0], ref = this.refs.get(root);
      for (void 0 !== ref && this.roots.delete(ref); !this.stack.isEmpty(); ) this.stack.pop();
    }
  }
  enter(state) {
    this.stack.push(state);
  }
  exit() {
    if (0 === this.stack.size) throw new Error("BUG: unbalanced pop");
    this.stack.pop();
  }
  nodeFor(state) {
    return this.nodes.get(state);
  }
  appendChild(node, state) {
    if (this.refs.has(state)) throw new Error("BUG: child already appended");
    let parent = this.stack.current, ref = new Ref(state);
    if (this.refs.set(state, ref), parent) {
      let parentNode = this.nodeFor(parent);
      parentNode.refs.add(ref), node.parent = parentNode;
    } else this.roots.add(ref);
  }
  captureRefs(refs) {
    let captured = [];
    return refs.forEach((ref) => {
      let state = ref.get();
      state ? captured.push(this.captureNode(`render-node:${ref.id}`, state)) : refs.delete(ref);
    }), captured;
  }
  captureNode(id, state) {
    let node = this.nodeFor(state), {
      type,
      name,
      args,
      instance,
      refs
    } = node, template = this.captureTemplate(node), bounds = this.captureBounds(node), children = this.captureRefs(refs);
    return {
      id,
      type,
      name,
      args: reifyArgsDebug(args),
      instance,
      template,
      bounds,
      children
    };
  }
  captureTemplate({
    template
  }) {
    return template || null;
  }
  captureBounds(node) {
    let bounds = node.bounds;
    return {
      parentElement: bounds.parentElement(),
      firstNode: bounds.firstNode(),
      lastNode: bounds.lastNode()
    };
  }
  constructor() {
    this.stack = new StackImpl(), this.refs = /* @__PURE__ */ new WeakMap(), this.roots = /* @__PURE__ */ new Set(), this.nodes = /* @__PURE__ */ new WeakMap();
  }
};
function getDebugName(definition, manager = definition.manager) {
  return definition.resolvedName ?? definition.debugName ?? manager.getDebugName(definition.state);
}
function normalizeStringValue(value) {
  return isEmpty$2(value) ? "" : String(value);
}
function isEmpty$2(value) {
  return null == value || "function" != typeof value.toString;
}
function isIndexable2(value) {
  return null !== value && "object" == typeof value;
}
function isSafeString(value) {
  return isIndexable2(value) && "function" == typeof value.toHTML;
}
function isString(value) {
  return "string" == typeof value;
}
APPEND_OPCODES.add(39, (vm) => vm.pushChildScope()), APPEND_OPCODES.add(40, (vm) => vm.popScope()), APPEND_OPCODES.add(59, (vm) => vm.pushDynamicScope()), APPEND_OPCODES.add(60, (vm) => vm.popDynamicScope()), APPEND_OPCODES.add(28, (vm, {
  op1: other
}) => {
  vm.stack.push(vm.constants.getValue(other));
}), APPEND_OPCODES.add(29, (vm, {
  op1: other
}) => {
  vm.stack.push(createConstRef(vm.constants.getValue(other), false));
}), APPEND_OPCODES.add(30, (vm, {
  op1: primitive
}) => {
  let stack = vm.stack;
  if (primitive >= 0) {
    let value = vm.constants.getValue(primitive);
    stack.push(value);
  } else
    stack.push(decodeImmediate(primitive));
}), APPEND_OPCODES.add(31, (vm) => {
  let ref, stack = vm.stack, value = stack.pop();
  ref = void 0 === value ? UNDEFINED_REFERENCE : null === value ? NULL_REFERENCE : true === value ? TRUE_REFERENCE : false === value ? FALSE_REFERENCE : createPrimitiveRef(value), stack.push(ref);
}), APPEND_OPCODES.add(33, (vm, {
  op1: register,
  op2: offset
}) => {
  let position = vm.fetchValue(register) - offset;
  vm.stack.dup(position);
}), APPEND_OPCODES.add(34, (vm, {
  op1: count
}) => {
  vm.stack.pop(count);
}), APPEND_OPCODES.add(35, (vm, {
  op1: register
}) => {
  vm.load(register);
}), APPEND_OPCODES.add(36, (vm, {
  op1: register
}) => {
  vm.fetch(register);
}), APPEND_OPCODES.add(58, (vm, {
  op1: _names
}) => {
  let names = vm.constants.getArray(_names);
  vm.bindDynamicScope(names);
}), APPEND_OPCODES.add(69, (vm, {
  op1: args
}) => {
  vm.enter(args);
}), APPEND_OPCODES.add(70, (vm) => {
  vm.exit();
}), APPEND_OPCODES.add(63, (vm, {
  op1: _table
}) => {
  vm.stack.push(vm.constants.getValue(_table));
}), APPEND_OPCODES.add(62, (vm) => {
  vm.stack.push(vm.scope());
}), APPEND_OPCODES.add(61, (vm) => {
  let stack = vm.stack, block = stack.pop();
  block ? stack.push(vm.compile(block)) : stack.push(null);
}), APPEND_OPCODES.add(64, (vm) => {
  let {
    stack
  } = vm, handle = stack.pop(), scope = stack.pop(), table = stack.pop(), args = stack.pop();
  if (null === table || null === handle)
    return vm.lowlevel.pushFrame(), void vm.pushScope(scope ?? vm.scope());
  let invokingScope = scope;
  {
    let locals = table.parameters, localsCount = locals.length;
    if (localsCount > 0) {
      invokingScope = invokingScope.child();
      for (let i = 0; i < localsCount; i++) invokingScope.bindSymbol(locals[i], args.at(i));
    }
  }
  vm.lowlevel.pushFrame(), vm.pushScope(invokingScope), vm.call(handle);
}), APPEND_OPCODES.add(65, (vm, {
  op1: target
}) => {
  let reference = vm.stack.pop(), value = Boolean(valueForRef(reference));
  isConstRef(reference) ? value && vm.lowlevel.goto(target) : (value && vm.lowlevel.goto(target), vm.updateWith(new Assert(reference)));
}), APPEND_OPCODES.add(66, (vm, {
  op1: target
}) => {
  let reference = vm.stack.pop(), value = Boolean(valueForRef(reference));
  isConstRef(reference) ? value || vm.lowlevel.goto(target) : (value || vm.lowlevel.goto(target), vm.updateWith(new Assert(reference)));
}), APPEND_OPCODES.add(67, (vm, {
  op1: target,
  op2: comparison
}) => {
  vm.stack.peek() === comparison && vm.lowlevel.goto(target);
}), APPEND_OPCODES.add(68, (vm) => {
  let reference = vm.stack.peek();
  isConstRef(reference) || vm.updateWith(new Assert(reference));
}), APPEND_OPCODES.add(71, (vm) => {
  let {
    stack
  } = vm, valueRef = stack.pop();
  stack.push(createComputeRef(() => toBool(valueForRef(valueRef))));
});
var Assert = class {
  constructor(ref) {
    this.ref = ref, this.last = valueForRef(ref);
  }
  evaluate(vm) {
    let {
      last,
      ref
    } = this;
    last !== valueForRef(ref) && vm.throw();
  }
};
var AssertFilter = class {
  constructor(ref, filter) {
    this.ref = ref, this.filter = filter, this.last = filter(valueForRef(ref));
  }
  evaluate(vm) {
    let {
      last,
      ref,
      filter
    } = this;
    last !== filter(valueForRef(ref)) && vm.throw();
  }
};
var JumpIfNotModifiedOpcode = class {
  finalize(tag, target) {
    this.target = target, this.didModify(tag);
  }
  evaluate(vm) {
    let {
      tag,
      target,
      lastRevision
    } = this;
    !vm.alwaysRevalidate && validateTag(tag, lastRevision) && (consumeTag(tag), vm.goto(target));
  }
  didModify(tag) {
    this.tag = tag, this.lastRevision = valueForTag(this.tag), consumeTag(tag);
  }
  constructor() {
    this.tag = CONSTANT_TAG, this.lastRevision = INITIAL;
  }
};
var BeginTrackFrameOpcode = class {
  constructor(debugLabel) {
    this.debugLabel = debugLabel;
  }
  evaluate() {
    beginTrackFrame(this.debugLabel);
  }
};
var EndTrackFrameOpcode = class {
  constructor(target) {
    this.target = target;
  }
  evaluate() {
    let tag = endTrackFrame();
    this.target.didModify(tag);
  }
};
APPEND_OPCODES.add(41, (vm, {
  op1: text
}) => {
  vm.tree().appendText(vm.constants.getValue(text));
}), APPEND_OPCODES.add(42, (vm, {
  op1: text
}) => {
  vm.tree().appendComment(vm.constants.getValue(text));
}), APPEND_OPCODES.add(48, (vm, {
  op1: tag
}) => {
  vm.tree().openElement(vm.constants.getValue(tag));
}), APPEND_OPCODES.add(49, (vm) => {
  let tagName = valueForRef(vm.stack.pop());
  vm.tree().openElement(tagName);
}), APPEND_OPCODES.add(50, (vm) => {
  let elementRef = vm.stack.pop(), insertBeforeRef = vm.stack.pop(), guidRef = vm.stack.pop(), element = valueForRef(elementRef), insertBefore = valueForRef(insertBeforeRef), guid = valueForRef(guidRef);
  isConstRef(elementRef) || vm.updateWith(new Assert(elementRef)), void 0 === insertBefore || isConstRef(insertBeforeRef) || vm.updateWith(new Assert(insertBeforeRef));
  let block = vm.tree().pushRemoteElement(element, guid, insertBefore);
  if (vm.associateDestroyable(block), void 0 !== vm.env.debugRenderTree) {
    let args = createCapturedArgs(void 0 === insertBefore ? {} : {
      insertBefore: insertBeforeRef
    }, [elementRef]);
    vm.env.debugRenderTree.create(block, {
      type: "keyword",
      name: "in-element",
      args,
      instance: null
    }), registerDestructor(block, () => {
      vm.env.debugRenderTree?.willDestroy(block);
    });
  }
}), APPEND_OPCODES.add(56, (vm) => {
  let bounds = vm.tree().popRemoteElement();
  void 0 !== vm.env.debugRenderTree && // The RemoteBlock is also its bounds
  vm.env.debugRenderTree.didRender(bounds, bounds);
}), APPEND_OPCODES.add(54, (vm) => {
  let operations = vm.fetchValue($t0), modifiers = null;
  operations && (modifiers = operations.flush(vm), vm.loadValue($t0, null)), vm.tree().flushElement(modifiers);
}), APPEND_OPCODES.add(55, (vm) => {
  let modifiers = vm.tree().closeElement();
  null !== modifiers && modifiers.forEach((modifier) => {
    vm.env.scheduleInstallModifier(modifier);
    const d = modifier.manager.getDestroyable(modifier.state);
    null !== d && vm.associateDestroyable(d);
  });
}), APPEND_OPCODES.add(57, (vm, {
  op1: handle
}) => {
  if (!vm.env.isInteractive) return;
  let owner = vm.getOwner(), args = vm.stack.pop(), definition = vm.constants.getValue(handle), {
    manager
  } = definition, {
    constructing
  } = vm.tree(), capturedArgs = args.capture(), state = manager.create(owner, constructing, definition.state, capturedArgs), instance = {
    manager,
    state,
    definition
  };
  vm.fetchValue($t0).addModifier(vm, instance, capturedArgs);
  let tag = manager.getTag(state);
  return null !== tag ? (consumeTag(tag), vm.updateWith(new UpdateModifierOpcode(tag, instance))) : void 0;
}), APPEND_OPCODES.add(108, (vm) => {
  if (!vm.env.isInteractive) return;
  let {
    stack
  } = vm, ref = stack.pop(), args = stack.pop().capture(), {
    positional: outerPositional,
    named: outerNamed
  } = args, {
    constructing
  } = vm.tree(), initialOwner = vm.getOwner(), instanceRef = createComputeRef(() => {
    let owner, hostDefinition, value = valueForRef(ref);
    if (!isIndexable(value)) return;
    if (isCurriedType(value, 2)) {
      let {
        definition: resolvedDefinition,
        owner: curriedOwner,
        positional,
        named
      } = resolveCurriedValue(value);
      hostDefinition = resolvedDefinition, owner = curriedOwner, void 0 !== positional && (args.positional = positional.concat(outerPositional)), void 0 !== named && // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      (args.named = Object.assign({}, ...named, outerNamed));
    } else hostDefinition = value, owner = initialOwner;
    let manager = getInternalModifierManager(hostDefinition, true);
    if (null === manager) throw true ? new Error(`Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was \`{{${ref.debugLabel}}}\`, and the incorrect definition is the value at the path \`${ref.debugLabel}\`, which was: ${debugToString$1?.(hostDefinition)}`) : new Error("BUG: modifier manager expected");
    let definition = {
      resolvedName: null,
      manager,
      state: hostDefinition
    }, state = manager.create(owner, constructing, definition.state, args);
    return {
      manager,
      state,
      definition
    };
  }), instance = valueForRef(instanceRef), tag = null;
  return void 0 !== instance && (vm.fetchValue($t0).addModifier(vm, instance, args), tag = instance.manager.getTag(instance.state), null !== tag && consumeTag(tag)), !isConstRef(ref) || tag ? vm.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef)) : void 0;
});
var UpdateModifierOpcode = class {
  constructor(tag, modifier) {
    this.tag = tag, this.modifier = modifier, this.lastUpdated = valueForTag(tag);
  }
  evaluate(vm) {
    let {
      modifier,
      tag,
      lastUpdated
    } = this;
    consumeTag(tag), validateTag(tag, lastUpdated) || (vm.env.scheduleUpdateModifier(modifier), this.lastUpdated = valueForTag(tag));
  }
};
var UpdateDynamicModifierOpcode = class {
  constructor(tag, instance, instanceRef) {
    this.tag = tag, this.instance = instance, this.instanceRef = instanceRef, this.lastUpdated = valueForTag(tag ?? CURRENT_TAG);
  }
  evaluate(vm) {
    let {
      tag,
      lastUpdated,
      instance,
      instanceRef
    } = this, newInstance = valueForRef(instanceRef);
    if (newInstance !== instance) {
      if (void 0 !== instance) {
        let destroyable = instance.manager.getDestroyable(instance.state);
        null !== destroyable && destroy(destroyable);
      }
      if (void 0 !== newInstance) {
        let {
          manager,
          state
        } = newInstance, destroyable = manager.getDestroyable(state);
        null !== destroyable && associateDestroyableChild(this, destroyable), tag = manager.getTag(state), null !== tag && (this.lastUpdated = valueForTag(tag)), this.tag = tag, vm.env.scheduleInstallModifier(newInstance);
      }
      this.instance = newInstance;
    } else null === tag || validateTag(tag, lastUpdated) || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    (vm.env.scheduleUpdateModifier(instance), this.lastUpdated = valueForTag(tag));
    null !== tag && consumeTag(tag);
  }
};
APPEND_OPCODES.add(51, (vm, {
  op1: _name,
  op2: _value,
  op3: _namespace
}) => {
  let name = vm.constants.getValue(_name), value = vm.constants.getValue(_value), namespace = _namespace ? vm.constants.getValue(_namespace) : null;
  vm.tree().setStaticAttribute(name, value, namespace);
}), APPEND_OPCODES.add(52, (vm, {
  op1: _name,
  op2: _trusting,
  op3: _namespace
}) => {
  let name = vm.constants.getValue(_name), trusting = vm.constants.getValue(_trusting), reference = vm.stack.pop(), value = valueForRef(reference), namespace = _namespace ? vm.constants.getValue(_namespace) : null, attribute = vm.tree().setDynamicAttribute(name, value, trusting, namespace);
  isConstRef(reference) || vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute, vm.env));
});
var UpdateDynamicAttributeOpcode = class {
  constructor(reference, attribute, env) {
    let initialized = false;
    this.updateRef = createComputeRef(() => {
      let value = valueForRef(reference);
      initialized ? attribute.update(value, env) : initialized = true;
    }), valueForRef(this.updateRef);
  }
  evaluate() {
    valueForRef(this.updateRef);
  }
};
APPEND_OPCODES.add(78, (vm, {
  op1: handle
}) => {
  let definition = vm.constants.getValue(handle), {
    manager,
    capabilities
  } = definition, instance = {
    definition,
    manager,
    capabilities,
    state: null,
    handle: null,
    table: null,
    lookup: null
  };
  vm.stack.push(instance);
}), APPEND_OPCODES.add(80, (vm, {
  op1: _isStrict
}) => {
  let definition, stack = vm.stack, component = valueForRef(stack.pop()), constants = vm.constants, owner = vm.getOwner(), isStrict = constants.getValue(_isStrict);
  if (vm.loadValue($t1, null), "string" == typeof component) {
    if (isStrict) throw new Error(`Attempted to resolve a dynamic component with a string definition, \`${component}\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`);
    let resolvedDefinition = (function(resolver, constants2, name, owner2) {
      let definition2 = resolver?.lookupComponent?.(name, owner2) ?? null;
      if (!definition2) throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component, but nothing was found.`);
      return constants2.resolvedComponent(definition2, name);
    })(vm.context.resolver, constants, component, owner);
    definition = resolvedDefinition;
  } else definition = isCurriedValue(component) ? component : constants.component(component, owner);
  stack.push(definition);
}), APPEND_OPCODES.add(81, (vm) => {
  let definition, stack = vm.stack, ref = stack.pop(), value = valueForRef(ref), constants = vm.constants;
  if ("function" != typeof value && ("object" != typeof value || null === value)) throw new Error(`Expected a component definition, but received ${value}. You may have accidentally done <${ref.debugLabel}>, where "${ref.debugLabel}" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.`);
  if (isCurriedValue(value)) definition = value;
  else if (definition = constants.component(value, vm.getOwner(), true), null === definition) throw new Error(`Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was \`<${ref.debugLabel}>\` or \`{{${ref.debugLabel}}}\`, and the incorrect definition is the value at the path \`${ref.debugLabel}\`, which was: ${debugToString$1?.(value) ?? value}`);
  stack.push(definition);
}), APPEND_OPCODES.add(79, (vm) => {
  let capabilities, manager, {
    stack
  } = vm, definition = stack.pop();
  isCurriedValue(definition) ? manager = capabilities = null : (manager = definition.manager, capabilities = definition.capabilities), stack.push({
    definition,
    capabilities,
    manager,
    state: null,
    handle: null,
    table: null
  });
}), APPEND_OPCODES.add(82, (vm, {
  op1: _names,
  op2: _blockNames,
  op3: flags
}) => {
  let stack = vm.stack, names = vm.constants.getArray(_names), positionalCount = flags >> 4, atNames = 8 & flags, blockNames = 7 & flags ? vm.constants.getArray(_blockNames) : EMPTY_STRING_ARRAY;
  vm.args.setup(stack, names, blockNames, positionalCount, !!atNames), stack.push(vm.args);
}), APPEND_OPCODES.add(83, (vm) => {
  let {
    stack
  } = vm;
  stack.push(vm.args.empty(stack));
}), APPEND_OPCODES.add(86, (vm) => {
  let stack = vm.stack, capturedArgs = stack.pop().capture();
  stack.push(capturedArgs);
}), APPEND_OPCODES.add(85, (vm, {
  op1: register
}) => {
  let stack = vm.stack, instance = vm.fetchValue(register), args = stack.pop(), {
    definition
  } = instance;
  if (isCurriedType(definition, 0)) {
    definition.manager;
    let constants = vm.constants, {
      definition: resolvedDefinition,
      owner,
      resolved,
      positional,
      named
    } = resolveCurriedValue(definition);
    if (resolved) definition = resolvedDefinition;
    else if ("string" == typeof resolvedDefinition) {
      let resolvedValue = vm.context.resolver?.lookupComponent?.(resolvedDefinition, owner) ?? null;
      definition = constants.resolvedComponent(resolvedValue, resolvedDefinition);
    } else definition = constants.component(resolvedDefinition, owner);
    void 0 !== named && // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    args.named.merge(assign({}, ...named)), void 0 !== positional && (args.realloc(positional.length), args.positional.prepend(positional));
    let {
      manager: manager2
    } = definition;
    instance.definition = definition, instance.manager = manager2, instance.capabilities = definition.capabilities, // Save off the owner that this component was curried with. Later on,
    // we'll fetch the value of this register and set it as the owner on the
    // new root scope.
    vm.loadValue($t1, owner);
  }
  let {
    manager,
    state
  } = definition, capabilities = instance.capabilities;
  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.prepareArgs)) return void stack.push(args);
  let blocks = args.blocks.values, blockNames = args.blocks.names, preparedArgs = manager.prepareArgs(state, args);
  if (preparedArgs) {
    args.clear();
    for (let i = 0; i < blocks.length; i++) stack.push(blocks[i]);
    let {
      positional,
      named
    } = preparedArgs, positionalCount = positional.length;
    for (let i = 0; i < positionalCount; i++) stack.push(positional[i]);
    let names = Object.keys(named);
    for (let i = 0; i < names.length; i++) stack.push(named[names[i]]);
    args.setup(stack, names, blockNames, positionalCount, false);
  }
  stack.push(args);
}), APPEND_OPCODES.add(87, (vm, {
  op1: flags
}) => {
  let instance = vm.fetchValue($s0), {
    definition,
    manager,
    capabilities
  } = instance;
  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance))
    return;
  let dynamicScope = null;
  managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicScope) && (dynamicScope = vm.dynamicScope());
  let hasDefaultBlock = 1 & flags, args = null;
  managerHasCapability(manager, capabilities, InternalComponentCapabilities.createArgs) && (args = vm.stack.peek());
  let self = null;
  managerHasCapability(manager, capabilities, InternalComponentCapabilities.createCaller) && (self = vm.getSelf());
  let state = manager.create(vm.getOwner(), definition.state, args, vm.env, dynamicScope, self, !!hasDefaultBlock);
  instance.state = state, managerHasCapability(manager, capabilities, InternalComponentCapabilities.updateHook) && vm.updateWith(new UpdateComponentOpcode(state, manager, dynamicScope));
}), APPEND_OPCODES.add(88, (vm, {
  op1: register
}) => {
  let {
    manager,
    state,
    capabilities
  } = vm.fetchValue(register), d = manager.getDestroyable(state);
  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.willDestroy) && null !== d && "string" in d) throw new Error("BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into");
  d && vm.associateDestroyable(d);
}), APPEND_OPCODES.add(97, (vm, {
  op1: register
}) => {
  let name;
  if (true) {
    let {
      definition,
      manager
    } = vm.fetchValue(register);
    name = getDebugName(definition, manager);
  }
  vm.beginCacheGroup(name), vm.tree().pushAppendingBlock();
}), APPEND_OPCODES.add(89, (vm) => {
  vm.loadValue($t0, new ComponentElementOperations());
}), APPEND_OPCODES.add(53, (vm, {
  op1: _name,
  op2: _trusting,
  op3: _namespace
}) => {
  let name = vm.constants.getValue(_name), trusting = vm.constants.getValue(_trusting), reference = vm.stack.pop(), namespace = _namespace ? vm.constants.getValue(_namespace) : null;
  vm.fetchValue($t0).setAttribute(name, reference, trusting, namespace);
}), APPEND_OPCODES.add(105, (vm, {
  op1: _name,
  op2: _value,
  op3: _namespace
}) => {
  let name = vm.constants.getValue(_name), value = vm.constants.getValue(_value), namespace = _namespace ? vm.constants.getValue(_namespace) : null;
  vm.fetchValue($t0).setStaticAttribute(name, value, namespace);
});
var ComponentElementOperations = class {
  setAttribute(name, value, trusting, namespace) {
    let deferred = {
      value,
      namespace,
      trusting
    };
    "class" === name && this.classes.push(value), this.attributes[name] = deferred;
  }
  setStaticAttribute(name, value, namespace) {
    let deferred = {
      value,
      namespace
    };
    "class" === name && this.classes.push(value), this.attributes[name] = deferred;
  }
  addModifier(vm, modifier, capturedArgs) {
    if (this.modifiers.push(modifier), void 0 !== vm.env.debugRenderTree) {
      const {
        manager,
        definition,
        state
      } = modifier;
      if (null === state || "object" != typeof state && "function" != typeof state) return;
      let {
        element,
        constructing
      } = vm.tree(), name = definition.resolvedName ?? manager.getDebugName(definition.state), instance = manager.getDebugInstance(state), bounds = new ConcreteBounds(element, constructing, constructing);
      vm.env.debugRenderTree.create(state, {
        type: "modifier",
        name,
        args: capturedArgs,
        instance
      }), vm.env.debugRenderTree.didRender(state, bounds), // For tearing down the debugRenderTree
      vm.associateDestroyable(state), vm.updateWith(new DebugRenderTreeUpdateOpcode(state)), vm.updateWith(new DebugRenderTreeDidRenderOpcode(state, bounds)), registerDestructor(state, () => {
        vm.env.debugRenderTree?.willDestroy(state);
      });
    }
  }
  flush(vm) {
    let type, attributes = this.attributes;
    for (let name in this.attributes) {
      if ("type" === name) {
        type = attributes[name];
        continue;
      }
      let attr = this.attributes[name];
      "class" === name ? setDeferredAttr(vm, "class", mergeClasses(this.classes), attr.namespace, attr.trusting) : setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);
    }
    return void 0 !== type && setDeferredAttr(vm, "type", type.value, type.namespace, type.trusting), this.modifiers;
  }
  constructor() {
    this.attributes = dict(), this.classes = [], this.modifiers = [];
  }
};
function mergeClasses(classes) {
  return 0 === classes.length ? "" : 1 === classes.length ? classes[0] : (function(classes2) {
    return classes2.every((c) => "string" == typeof c);
  })(classes) ? classes.join(" ") : (list = classes, createComputeRef(() => {
    let ret = [];
    for (const ref of list) {
      let value = normalizeStringValue("string" == typeof ref ? ref : valueForRef(ref));
      value && ret.push(value);
    }
    return 0 === ret.length ? null : ret.join(" ");
  }));
  var list;
}
function setDeferredAttr(vm, name, value, namespace, trusting = false) {
  if ("string" == typeof value) vm.tree().setStaticAttribute(name, value, namespace);
  else {
    let attribute = vm.tree().setDynamicAttribute(name, valueForRef(value), trusting, namespace);
    isConstRef(value) || vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));
  }
}
function bindBlock(symbolName, blockName, state, blocks, vm) {
  let symbol = state.table.symbols.indexOf(symbolName), block = blocks.get(blockName);
  -1 !== symbol && vm.scope().bindBlock(symbol + 1, block), state.lookup && (state.lookup[symbolName] = block);
}
APPEND_OPCODES.add(99, (vm, {
  op1: register
}) => {
  let {
    definition,
    state
  } = vm.fetchValue(register), {
    manager
  } = definition, operations = vm.fetchValue($t0);
  manager.didCreateElement(state, vm.tree().constructing, operations);
}), APPEND_OPCODES.add(90, (vm, {
  op1: register,
  op2: _names
}) => {
  let instance = vm.fetchValue(register), {
    definition,
    state
  } = instance, {
    manager
  } = definition, selfRef = manager.getSelf(state);
  if (void 0 !== vm.env.debugRenderTree) {
    let args, moduleName, instance2 = vm.fetchValue(register), {
      definition: definition2,
      manager: manager2
    } = instance2;
    if (vm.stack.peek() === vm.args) args = vm.args.capture();
    else {
      let names = vm.constants.getArray(_names);
      vm.args.setup(vm.stack, names, [], 0, true), args = vm.args.capture();
    }
    let compilable = definition2.compilable;
    if (null === compilable) {
      managerHasCapability(manager2, instance2.capabilities, InternalComponentCapabilities.dynamicLayout);
      let resolver = vm.context.resolver;
      compilable = null === resolver ? null : manager2.getDynamicLayout(state, resolver), moduleName = null !== compilable ? compilable.moduleName : "__default__.hbs";
    } else moduleName = compilable.moduleName;
    if (vm.associateDestroyable(instance2), hasCustomDebugRenderTreeLifecycle(manager2)) manager2.getDebugCustomRenderTree(instance2.definition.state, instance2.state, args, moduleName).forEach((node) => {
      let {
        bucket
      } = node;
      vm.env.debugRenderTree.create(bucket, node), registerDestructor(instance2, () => {
        vm.env.debugRenderTree?.willDestroy(bucket);
      }), vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));
    });
    else {
      let name = getDebugName(definition2, manager2);
      vm.env.debugRenderTree.create(instance2, {
        type: "component",
        name,
        args,
        template: moduleName,
        instance: valueForRef(selfRef)
      }), registerDestructor(instance2, () => {
        vm.env.debugRenderTree?.willDestroy(instance2);
      }), vm.updateWith(new DebugRenderTreeUpdateOpcode(instance2));
    }
  }
  vm.stack.push(selfRef);
}), APPEND_OPCODES.add(91, (vm, {
  op1: register
}) => {
  let {
    definition,
    state
  } = vm.fetchValue(register), {
    manager
  } = definition, tagName = manager.getTagName(state);
  vm.stack.push(tagName);
}), // Dynamic Invocation Only
APPEND_OPCODES.add(92, (vm, {
  op1: register
}) => {
  let instance = vm.fetchValue(register), {
    manager,
    definition
  } = instance, {
    stack
  } = vm, {
    compilable
  } = definition;
  if (null === compilable) {
    let {
      capabilities
    } = instance;
    managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout);
    let resolver = vm.context.resolver;
    compilable = null === resolver ? null : manager.getDynamicLayout(instance.state, resolver), null === compilable && (compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? unwrapTemplate2(vm.constants.defaultTemplate).asWrappedLayout() : unwrapTemplate2(vm.constants.defaultTemplate).asLayout());
  }
  let handle = compilable.compile(vm.context);
  stack.push(compilable.symbolTable), stack.push(handle);
}), APPEND_OPCODES.add(75, (vm, {
  op1: register
}) => {
  let definition = vm.stack.pop(), invocation = vm.stack.pop(), {
    manager,
    capabilities
  } = definition, state = {
    definition,
    manager,
    capabilities,
    state: null,
    handle: invocation.handle,
    table: invocation.symbolTable,
    lookup: null
  };
  vm.loadValue(register, state);
}), APPEND_OPCODES.add(95, (vm, {
  op1: register
}) => {
  let {
    stack
  } = vm, handle = stack.pop(), table = stack.pop(), state = vm.fetchValue(register);
  state.handle = handle, state.table = table;
}), APPEND_OPCODES.add(38, (vm, {
  op1: register
}) => {
  let owner, {
    table,
    manager,
    capabilities,
    state
  } = vm.fetchValue(register);
  managerHasCapability(manager, capabilities, InternalComponentCapabilities.hasSubOwner) ? (owner = manager.getOwner(state), vm.loadValue($t1, null)) : (
    // Check the temp register to see if an owner was resolved from currying
    (owner = vm.fetchValue($t1), null === owner ? (
      // If an owner wasn't found, default to using the current owner. This
      // will happen for normal dynamic component invocation,
      // e.g. <SomeClassicEmberComponent/>
      owner = vm.getOwner()
    ) : (
      // Else the owner was found, so clear the temp register. This will happen
      // if we are loading a curried component, e.g. <@someCurriedComponent/>
      vm.loadValue($t1, null)
    ))
  ), vm.pushRootScope(table.symbols.length + 1, owner);
}), APPEND_OPCODES.add(17, (vm, {
  op1: register
}) => {
  let state = vm.fetchValue(register), scope = vm.scope(), args = vm.stack.peek(), callerNames = args.named.atNames;
  for (let i = callerNames.length - 1; i >= 0; i--) {
    let atName = callerNames[i], symbol = state.table.symbols.indexOf(atName), value = args.named.get(atName, true);
    -1 !== symbol && scope.bindSymbol(symbol + 1, value), state.lookup && (state.lookup[atName] = value);
  }
}), APPEND_OPCODES.add(18, (vm, {
  op1: register
}) => {
  let state = vm.fetchValue(register), {
    blocks
  } = vm.stack.peek();
  for (const [i] of enumerate(blocks.names)) bindBlock(blocks.symbolNames[i], blocks.names[i], state, blocks, vm);
}), // Dynamic Invocation Only
APPEND_OPCODES.add(96, (vm, {
  op1: register
}) => {
  let state = vm.fetchValue(register);
  vm.call(state.handle);
}), APPEND_OPCODES.add(100, (vm, {
  op1: register
}) => {
  let instance = vm.fetchValue(register), {
    manager,
    state,
    capabilities
  } = instance, bounds = vm.tree().popBlock();
  void 0 !== vm.env.debugRenderTree && (hasCustomDebugRenderTreeLifecycle(manager) ? manager.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS).reverse().forEach((node) => {
    let {
      bucket
    } = node;
    vm.env.debugRenderTree.didRender(bucket, bounds), vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));
  }) : (vm.env.debugRenderTree.didRender(instance, bounds), vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds)))), managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance) && // eslint-disable-next-line @typescript-eslint/no-unsafe-call -- @fixme
  (manager.didRenderLayout(state, bounds), vm.env.didCreate(instance), vm.updateWith(new DidUpdateLayoutOpcode(instance, bounds)));
}), APPEND_OPCODES.add(98, (vm) => {
  vm.commitCacheGroup();
});
var UpdateComponentOpcode = class {
  constructor(component, manager, dynamicScope) {
    this.component = component, this.manager = manager, this.dynamicScope = dynamicScope;
  }
  evaluate(_vm) {
    let {
      component,
      manager,
      dynamicScope
    } = this;
    manager.update(component, dynamicScope);
  }
};
var DidUpdateLayoutOpcode = class {
  constructor(component, bounds) {
    this.component = component, this.bounds = bounds;
  }
  evaluate(vm) {
    let {
      component,
      bounds
    } = this, {
      manager,
      state
    } = component;
    manager.didUpdateLayout(state, bounds), vm.env.didUpdate(component);
  }
};
var DebugRenderTreeUpdateOpcode = class {
  constructor(bucket) {
    this.bucket = bucket;
  }
  evaluate(vm) {
    vm.env.debugRenderTree?.update(this.bucket);
  }
};
var DebugRenderTreeDidRenderOpcode = class {
  constructor(bucket, bounds) {
    this.bucket = bucket, this.bounds = bounds;
  }
  evaluate(vm) {
    vm.env.debugRenderTree?.didRender(this.bucket, this.bounds);
  }
};
var VMArgumentsImpl = class {
  constructor() {
    this.stack = null, this.positional = new PositionalArgumentsImpl(), this.named = new NamedArgumentsImpl(), this.blocks = new BlockArgumentsImpl();
  }
  empty(stack) {
    let base = stack.registers[$sp] + 1;
    return this.named.empty(stack, base), this.positional.empty(stack, base), this.blocks.empty(stack, base), this;
  }
  setup(stack, names, blockNames, positionalCount, atNames) {
    this.stack = stack;
    let named = this.named, namedCount = names.length, namedBase = stack.registers[$sp] - namedCount + 1;
    named.setup(stack, namedBase, namedCount, names, atNames);
    let positionalBase = namedBase - positionalCount;
    this.positional.setup(stack, positionalBase, positionalCount);
    let blocks = this.blocks, blocksCount = blockNames.length, blocksBase = positionalBase - 3 * blocksCount;
    blocks.setup(stack, blocksBase, blocksCount, blockNames);
  }
  get base() {
    return this.blocks.base;
  }
  get length() {
    return this.positional.length + this.named.length + 3 * this.blocks.length;
  }
  at(pos) {
    return this.positional.at(pos);
  }
  realloc(offset) {
    let {
      stack
    } = this;
    if (offset > 0 && null !== stack) {
      let {
        positional,
        named
      } = this, newBase = positional.base + offset;
      for (let i = positional.length + named.length - 1; i >= 0; i--) stack.copy(i + positional.base, i + newBase);
      positional.base += offset, named.base += offset, stack.registers[$sp] += offset;
    }
  }
  capture() {
    let positional = 0 === this.positional.length ? EMPTY_POSITIONAL : this.positional.capture();
    return {
      named: 0 === this.named.length ? EMPTY_NAMED : this.named.capture(),
      positional
    };
  }
  clear() {
    let {
      stack,
      length: length2
    } = this;
    length2 > 0 && null !== stack && stack.pop(length2);
  }
};
var EMPTY_REFERENCES = emptyArray();
var PositionalArgumentsImpl = class {
  constructor() {
    this.base = 0, this.length = 0, this.stack = null, this._references = null;
  }
  empty(stack, base) {
    this.stack = stack, this.base = base, this.length = 0, this._references = EMPTY_REFERENCES;
  }
  setup(stack, base, length2) {
    this.stack = stack, this.base = base, this.length = length2, this._references = 0 === length2 ? EMPTY_REFERENCES : null;
  }
  at(position) {
    let {
      base,
      length: length2,
      stack
    } = this;
    return position < 0 || position >= length2 ? UNDEFINED_REFERENCE : stack.get(position, base);
  }
  capture() {
    return this.references;
  }
  prepend(other) {
    let additions = other.length;
    if (additions > 0) {
      let {
        base,
        length: length2,
        stack
      } = this;
      this.base = base -= additions, this.length = length2 + additions;
      for (let i = 0; i < additions; i++)
        stack.set(other[i], i, base);
      this._references = null;
    }
  }
  get references() {
    let references = this._references;
    if (!references) {
      let {
        stack,
        base,
        length: length2
      } = this;
      references = this._references = stack.slice(base, base + length2);
    }
    return references;
  }
};
var NamedArgumentsImpl = class {
  constructor() {
    this.base = 0, this.length = 0, this._references = null, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY;
  }
  empty(stack, base) {
    this.stack = stack, this.base = base, this.length = 0, this._references = EMPTY_REFERENCES, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY;
  }
  setup(stack, base, length2, names, atNames) {
    this.stack = stack, this.base = base, this.length = length2, 0 === length2 ? (this._references = EMPTY_REFERENCES, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY) : (this._references = null, atNames ? (this._names = null, this._atNames = names) : (this._names = names, this._atNames = null));
  }
  get names() {
    let names = this._names;
    return names || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    (names = this._names = this._atNames.map(this.toSyntheticName)), names;
  }
  get atNames() {
    let atNames = this._atNames;
    return atNames || // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    (atNames = this._atNames = this._names.map(this.toAtName)), atNames;
  }
  has(name) {
    return -1 !== this.names.indexOf(name);
  }
  get(name, atNames = false) {
    let {
      base,
      stack
    } = this, idx = (atNames ? this.atNames : this.names).indexOf(name);
    if (-1 === idx) return UNDEFINED_REFERENCE;
    let ref = stack.get(idx, base);
    return true ? createDebugAliasRef(atNames ? name : `@${name}`, ref) : ref;
  }
  capture() {
    let {
      names,
      references
    } = this, map = dict();
    for (const [i, name] of enumerate(names))
      map[name] = true ? createDebugAliasRef(`@${name}`, references[i]) : references[i];
    return map;
  }
  merge(other) {
    let keys = Object.keys(other);
    if (keys.length > 0) {
      let {
        names,
        length: length2,
        stack
      } = this, newNames = names.slice();
      for (const name of keys) -1 === newNames.indexOf(name) && (length2 = newNames.push(name), stack.push(other[name]));
      this.length = length2, this._references = null, this._names = newNames, this._atNames = null;
    }
  }
  get references() {
    let references = this._references;
    if (!references) {
      let {
        base,
        length: length2,
        stack
      } = this;
      references = this._references = stack.slice(base, base + length2);
    }
    return references;
  }
  toSyntheticName(name) {
    return name.slice(1);
  }
  toAtName(name) {
    return `@${name}`;
  }
};
function toSymbolName(name) {
  return `&${name}`;
}
var EMPTY_BLOCK_VALUES = emptyArray();
var BlockArgumentsImpl = class {
  constructor() {
    this.internalValues = null, this._symbolNames = null, this.internalTag = null, this.names = EMPTY_STRING_ARRAY, this.length = 0, this.base = 0;
  }
  empty(stack, base) {
    this.stack = stack, this.names = EMPTY_STRING_ARRAY, this.base = base, this.length = 0, this._symbolNames = null, this.internalTag = CONSTANT_TAG, this.internalValues = EMPTY_BLOCK_VALUES;
  }
  setup(stack, base, length2, names) {
    this.stack = stack, this.names = names, this.base = base, this.length = length2, this._symbolNames = null, 0 === length2 ? (this.internalTag = CONSTANT_TAG, this.internalValues = EMPTY_BLOCK_VALUES) : (this.internalTag = null, this.internalValues = null);
  }
  get values() {
    let values = this.internalValues;
    if (!values) {
      let {
        base,
        length: length2,
        stack
      } = this;
      values = this.internalValues = stack.slice(base, base + 3 * length2);
    }
    return values;
  }
  has(name) {
    return -1 !== this.names.indexOf(name);
  }
  get(name) {
    let idx = this.names.indexOf(name);
    if (-1 === idx) return null;
    let {
      base,
      stack
    } = this, table = stack.get(3 * idx, base), scope = stack.get(3 * idx + 1, base), handle = stack.get(3 * idx + 2, base);
    return null === handle ? null : [handle, scope, table];
  }
  capture() {
    return new CapturedBlockArgumentsImpl(this.names, this.values);
  }
  get symbolNames() {
    let symbolNames = this._symbolNames;
    return null === symbolNames && (symbolNames = this._symbolNames = this.names.map(toSymbolName)), symbolNames;
  }
};
var CapturedBlockArgumentsImpl = class {
  constructor(names, values) {
    this.names = names, this.values = values, this.length = names.length;
  }
  has(name) {
    return -1 !== this.names.indexOf(name);
  }
  get(name) {
    let idx = this.names.indexOf(name);
    return -1 === idx ? null : [this.values[3 * idx + 2], this.values[3 * idx + 1], this.values[3 * idx]];
  }
};
function createCapturedArgs(named, positional) {
  return {
    named,
    positional
  };
}
function reifyNamed(named) {
  let reified = dict();
  for (const [key, value] of Object.entries(named)) reified[key] = valueForRef(value);
  return reified;
}
function reifyPositional(positional) {
  return positional.map(valueForRef);
}
var ARGUMENT_ERROR = Symbol("ARGUMENT_ERROR");
function isArgumentError(arg) {
  return null !== arg && "object" == typeof arg && arg[ARGUMENT_ERROR];
}
function ArgumentErrorImpl(error) {
  return {
    [ARGUMENT_ERROR]: true,
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    error
  };
}
function reifyArgsDebug(args) {
  return {
    named: (function(named) {
      let reified = dict();
      for (const [key, value] of Object.entries(named)) try {
        reified[key] = valueForRef(value);
      } catch (e) {
        reified[key] = ArgumentErrorImpl(e);
      }
      return reified;
    })(args.named),
    positional: (positional = args.positional, positional.map((p) => {
      try {
        return valueForRef(p);
      } catch (e) {
        return ArgumentErrorImpl(e);
      }
    }))
  };
  var positional;
}
var EMPTY_NAMED = Object.freeze(/* @__PURE__ */ Object.create(null));
var EMPTY_POSITIONAL = EMPTY_REFERENCES;
var EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);
function castToString(value) {
  return "string" == typeof value ? value : "function" != typeof value.toString ? "" : String(value);
}
function resolveHelper(definition, ref) {
  let helper2, managerOrHelper = getInternalHelperManager(definition, true);
  return helper2 = null === managerOrHelper ? null : "function" == typeof managerOrHelper ? managerOrHelper : managerOrHelper.getHelper(definition), debugAssert(null !== helper2, () => `Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was \`{{${ref.debugLabel}}}\` or \`(${ref.debugLabel})\`, and the incorrect definition is the value at the path \`${ref.debugLabel}\`, which was: ${debugToString$1?.(definition)}`), helper2;
}
function isUndefinedReference(input) {
  return input === UNDEFINED_REFERENCE;
}
APPEND_OPCODES.add(77, (vm, {
  op1: type,
  op2: _isStrict
}) => {
  let stack = vm.stack, definition = stack.pop(), capturedArgs = stack.pop(), owner = vm.getOwner(), resolver = vm.context.resolver, isStrict = false;
  // strict check only happens in DEBUG builds, no reason to load it otherwise
  isStrict = vm.constants.getValue(_isStrict), vm.loadValue($v0, (function(type2, inner, owner2, args, resolver2, isStrict2) {
    let lastValue, curriedDefinition;
    return createComputeRef(() => {
      let value = valueForRef(inner);
      if (value === lastValue) return curriedDefinition;
      if (isCurriedType(value, type2)) curriedDefinition = args ? curry(type2, value, owner2, args) : args;
      else if (0 === type2 && "string" == typeof value && value) {
        if (true) {
          if (isStrict2) throw new Error(`Attempted to resolve a dynamic component with a string definition, \`${value}\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`);
          if (!resolver2.lookupComponent?.(value, owner2)) throw new Error(`Attempted to resolve \`${value}\`, which was expected to be a component, but nothing was found.`);
        }
        curriedDefinition = curry(type2, value, owner2, args);
      } else curriedDefinition = isIndexable(value) ? curry(type2, value, owner2, args) : null;
      return lastValue = value, curriedDefinition;
    });
  })(type, definition, owner, capturedArgs, resolver, isStrict));
}), APPEND_OPCODES.add(107, (vm) => {
  let helperRef, stack = vm.stack, ref = stack.pop(), args = stack.pop().capture(), initialOwner = vm.getOwner(), helperInstanceRef = createComputeRef(() => {
    void 0 !== helperRef && destroy(helperRef);
    let definition = valueForRef(ref);
    if (isCurriedType(definition, 1)) {
      let {
        definition: resolvedDef,
        owner,
        positional,
        named
      } = resolveCurriedValue(definition), helper2 = resolveHelper(resolvedDef, ref);
      void 0 !== named && // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      (args.named = assign({}, ...named, args.named)), void 0 !== positional && (args.positional = positional.concat(args.positional)), helperRef = helper2(args, owner), associateDestroyableChild(helperInstanceRef, helperRef);
    } else if (isIndexable(definition)) {
      let helper2 = resolveHelper(definition, ref);
      helperRef = helper2(args, initialOwner), _hasDestroyableChildren(helperRef) && associateDestroyableChild(helperInstanceRef, helperRef);
    } else helperRef = UNDEFINED_REFERENCE;
  }), helperValueRef = createComputeRef(() => (valueForRef(helperInstanceRef), valueForRef(helperRef)));
  vm.associateDestroyable(helperInstanceRef), vm.loadValue($v0, helperValueRef);
}), APPEND_OPCODES.add(16, (vm, {
  op1: handle
}) => {
  let stack = vm.stack, value = vm.constants.getValue(handle)(stack.pop().capture(), vm.getOwner(), vm.dynamicScope());
  _hasDestroyableChildren(value) && vm.associateDestroyable(value), vm.loadValue($v0, value);
}), APPEND_OPCODES.add(21, (vm, {
  op1: symbol
}) => {
  let expr = vm.referenceForSymbol(symbol);
  vm.stack.push(expr);
}), APPEND_OPCODES.add(19, (vm, {
  op1: symbol
}) => {
  let expr = vm.stack.pop();
  vm.scope().bindSymbol(symbol, expr);
}), APPEND_OPCODES.add(20, (vm, {
  op1: symbol
}) => {
  let handle = vm.stack.pop(), scope = vm.stack.pop(), table = vm.stack.pop();
  vm.scope().bindBlock(symbol, [handle, scope, table]);
}), APPEND_OPCODES.add(37, (vm, {
  op1: size
}) => {
  vm.pushRootScope(size, vm.getOwner());
}), APPEND_OPCODES.add(22, (vm, {
  op1: _key
}) => {
  let key = vm.constants.getValue(_key), expr = vm.stack.pop();
  vm.stack.push(childRefFor(expr, key));
}), APPEND_OPCODES.add(23, (vm, {
  op1: _block
}) => {
  let {
    stack
  } = vm, block = vm.scope().getBlock(_block);
  stack.push(block);
}), APPEND_OPCODES.add(24, (vm) => {
  let {
    stack
  } = vm, block = stack.pop();
  if (block && !isUndefinedReference(block)) {
    let [handleOrCompilable, scope, table] = block;
    stack.push(table), stack.push(scope), stack.push(handleOrCompilable);
  } else stack.push(null), stack.push(null), stack.push(null);
}), APPEND_OPCODES.add(25, (vm) => {
  let {
    stack
  } = vm, block = stack.pop();
  block && !isUndefinedReference(block) ? stack.push(TRUE_REFERENCE) : stack.push(FALSE_REFERENCE);
}), APPEND_OPCODES.add(26, (vm) => {
  vm.stack.pop(), vm.stack.pop();
  let table = vm.stack.pop(), hasBlockParams = table && table.parameters.length;
  vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);
}), APPEND_OPCODES.add(27, (vm, {
  op1: count
}) => {
  let out = new Array(count);
  for (let i = count; i > 0; i--) out[i - 1] = vm.stack.pop();
  var partsRefs;
  vm.stack.push((partsRefs = out, createComputeRef(() => {
    const parts = [];
    for (const ref of partsRefs) {
      const value = valueForRef(ref);
      null != value && parts.push(castToString(value));
    }
    return parts.length > 0 ? parts.join("") : null;
  })));
}), APPEND_OPCODES.add(109, (vm) => {
  let condition = vm.stack.pop(), truthy = vm.stack.pop(), falsy = vm.stack.pop();
  vm.stack.push(createComputeRef(() => toBool(valueForRef(condition)) ? valueForRef(truthy) : valueForRef(falsy)));
}), APPEND_OPCODES.add(110, (vm) => {
  let ref = vm.stack.pop();
  vm.stack.push(createComputeRef(() => !toBool(valueForRef(ref))));
}), APPEND_OPCODES.add(111, (vm) => {
  let scope = vm.dynamicScope(), stack = vm.stack, nameRef = stack.pop();
  stack.push(createComputeRef(() => {
    let name = String(valueForRef(nameRef));
    return valueForRef(scope.get(name));
  }));
}), APPEND_OPCODES.add(112, (vm) => {
  let {
    positional
  } = vm.stack.pop().capture();
  vm.loadValue($v0, createComputeRef(() => {
    console.log(...reifyPositional(positional));
  }));
});
var DynamicTextContent = class {
  constructor(node, reference, lastValue) {
    this.node = node, this.reference = reference, this.lastValue = lastValue;
  }
  evaluate() {
    let normalized, value = valueForRef(this.reference), {
      lastValue
    } = this;
    value !== lastValue && (normalized = isEmpty$2(value) ? "" : isString(value) ? value : String(value), normalized !== lastValue) && (this.node.nodeValue = this.lastValue = normalized);
  }
};
function toContentType(value) {
  return (function(value2) {
    return isString(value2) || isEmpty$2(value2) || "boolean" == typeof value2 || "number" == typeof value2;
  })(value) ? ContentType.String : isCurriedType(value, 0) || hasInternalComponentManager(value) ? ContentType.Component : isCurriedType(value, 1) || hasInternalHelperManager(value) ? ContentType.Helper : isSafeString(value) ? ContentType.SafeString : (function(value2) {
    return isIndexable2(value2) && 11 === value2.nodeType;
  })(value) ? ContentType.Fragment : (function(value2) {
    return isIndexable2(value2) && "number" == typeof value2.nodeType;
  })(value) ? ContentType.Node : ContentType.String;
}
function toDynamicContentType(value) {
  if (!isIndexable(value)) return ContentType.String;
  if (isCurriedType(value, 0) || hasInternalComponentManager(value)) return ContentType.Component;
  if (!isCurriedType(value, 1) && !hasInternalHelperManager(value)) throw new Error(
    // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme
    `Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: ${value}`
  );
  return ContentType.Helper;
}
function debugCallback(context2, get2) {
  console.info("Use `context`, and `get(<path>)` to debug this template."), get2("this");
  debugger;
}
APPEND_OPCODES.add(76, (vm) => {
  let reference = vm.stack.peek();
  vm.stack.push(toContentType(valueForRef(reference))), isConstRef(reference) || vm.updateWith(new AssertFilter(reference, toContentType));
}), APPEND_OPCODES.add(106, (vm) => {
  let reference = vm.stack.peek();
  vm.stack.push(toDynamicContentType(valueForRef(reference))), isConstRef(reference) || vm.updateWith(new AssertFilter(reference, toDynamicContentType));
}), APPEND_OPCODES.add(43, (vm) => {
  let reference = vm.stack.pop(), rawValue = valueForRef(reference), value = isEmpty$2(rawValue) ? "" : String(rawValue);
  vm.tree().appendDynamicHTML(value);
}), APPEND_OPCODES.add(44, (vm) => {
  let reference = vm.stack.pop(), rawValue = valueForRef(reference).toHTML(), value = isEmpty$2(rawValue) ? "" : rawValue;
  vm.tree().appendDynamicHTML(value);
}), APPEND_OPCODES.add(47, (vm) => {
  let reference = vm.stack.pop(), rawValue = valueForRef(reference), value = isEmpty$2(rawValue) ? "" : String(rawValue), node = vm.tree().appendDynamicText(value);
  isConstRef(reference) || vm.updateWith(new DynamicTextContent(node, reference, value));
}), APPEND_OPCODES.add(45, (vm) => {
  let reference = vm.stack.pop(), value = valueForRef(reference);
  vm.tree().appendDynamicFragment(value);
}), APPEND_OPCODES.add(46, (vm) => {
  let reference = vm.stack.pop(), value = valueForRef(reference);
  vm.tree().appendDynamicNode(value);
});
var callback = debugCallback;
var ScopeInspector = class {
  #symbols;
  constructor(scope, symbols) {
    this.scope = scope, this.#symbols = symbols;
  }
  get(path) {
    let ref, {
      scope
    } = this, symbols = this.#symbols, parts = path.split("."), [head, ...tail] = path.split(".");
    return "this" === head ? ref = scope.getSelf() : symbols.locals[head] ? ref = scope.getSymbol(symbols.locals[head]) : (ref = this.scope.getSelf(), tail = parts), tail.reduce((r, part) => childRefFor(r, part), ref);
  }
};
APPEND_OPCODES.add(103, (vm, {
  op1: _debugInfo
}) => {
  let debuggerInfo = vm.constants.getValue(_debugInfo), inspector = new ScopeInspector(vm.scope(), debuggerInfo);
  callback(valueForRef(vm.getSelf()), (path) => valueForRef(inspector.get(path)));
}), APPEND_OPCODES.add(72, (vm, {
  op1: relativeStart,
  op2: elseTarget
}) => {
  let stack = vm.stack, listRef = stack.pop(), keyRef = stack.pop(), keyValue = valueForRef(keyRef), key = null === keyValue ? "@identity" : String(keyValue), iteratorRef = createIteratorRef(listRef, key), iterator = valueForRef(iteratorRef);
  vm.updateWith(new AssertFilter(iteratorRef, (iterator2) => iterator2.isEmpty())), iterator.isEmpty() ? (
    // TODO: Fix this offset, should be accurate
    vm.lowlevel.goto(elseTarget + 1)
  ) : (vm.enterList(iteratorRef, relativeStart), vm.stack.push(iterator));
}), APPEND_OPCODES.add(73, (vm) => {
  vm.exitList();
}), APPEND_OPCODES.add(74, (vm, {
  op1: breaks
}) => {
  let item = vm.stack.peek().next();
  null !== item ? vm.registerItem(vm.enterItem(item)) : vm.lowlevel.goto(breaks);
});
var CAPABILITIES = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: false,
  attributeHook: false,
  elementHook: false,
  createCaller: false,
  dynamicScope: false,
  updateHook: false,
  createInstance: false,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
var TemplateOnlyComponentManager = class {
  getCapabilities() {
    return CAPABILITIES;
  }
  getDebugName({
    name
  }) {
    return name;
  }
  getSelf() {
    return NULL_REFERENCE;
  }
  getDestroyable() {
    return null;
  }
};
var TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager();
var TemplateOnlyComponentDefinition = class {
  constructor(moduleName = "@glimmer/component/template-only", name = "(unknown template-only component)") {
    this.moduleName = moduleName, this.name = name;
  }
  toString() {
    return this.moduleName;
  }
};
function templateOnlyComponent(moduleName, name) {
  return new TemplateOnlyComponentDefinition(moduleName, name);
}
setInternalComponentManager(TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition.prototype);
var SVG_INTEGRATION_POINTS = {
  foreignObject: 1,
  desc: 1,
  title: 1
};
var BLACKLIST_TABLE = /* @__PURE__ */ Object.create(null);
var DOMOperations = class {
  constructor(document2) {
    this.document = document2, this.setupUselessElement();
  }
  // split into separate method so that NodeDOMTreeConstruction
  // can override it.
  setupUselessElement() {
    this.uselessElement = this.document.createElement("div");
  }
  createElement(tag, context2) {
    let isElementInSVGNamespace, isHTMLIntegrationPoint, isElementInMathMlNamespace, ns;
    if (context2 ? (isElementInSVGNamespace = context2.namespaceURI === NS_SVG || "svg" === tag, isElementInMathMlNamespace = context2.namespaceURI === NS_MATHML || "math" === tag, isHTMLIntegrationPoint = !!SVG_INTEGRATION_POINTS[context2.tagName]) : (isElementInSVGNamespace = "svg" === tag, isElementInMathMlNamespace = "math" === tag, isHTMLIntegrationPoint = false), !isElementInMathMlNamespace && !isElementInSVGNamespace || isHTMLIntegrationPoint) return this.document.createElement(tag);
    if (BLACKLIST_TABLE[tag]) throw new Error(`Cannot create a ${tag} inside an SVG context`);
    return ns = isElementInMathMlNamespace ? NS_MATHML : NS_SVG, this.document.createElementNS(ns, tag);
  }
  insertBefore(parent, node, reference) {
    parent.insertBefore(node, reference);
  }
  insertHTMLBefore(parent, nextSibling, html) {
    if ("" === html) {
      const comment = this.createComment("");
      return parent.insertBefore(comment, nextSibling), new ConcreteBounds(parent, comment, comment);
    }
    const prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
    let last;
    if (null === nextSibling) parent.insertAdjacentHTML("beforeend", html), last = parent.lastChild;
    else if (nextSibling instanceof HTMLElement) nextSibling.insertAdjacentHTML("beforebegin", html), last = nextSibling.previousSibling;
    else {
      const {
        uselessElement
      } = this;
      parent.insertBefore(uselessElement, nextSibling), uselessElement.insertAdjacentHTML("beforebegin", html), last = uselessElement.previousSibling, parent.removeChild(uselessElement);
    }
    const first = prev ? prev.nextSibling : parent.firstChild;
    return new ConcreteBounds(parent, first, last);
  }
  createTextNode(text) {
    return this.document.createTextNode(text);
  }
  createComment(data) {
    return this.document.createComment(data);
  }
};
function applySVGInnerHTMLFix(document2, DOMClass, svgNamespace) {
  if (!document2) return DOMClass;
  if (!(function(document3, svgNamespace2) {
    const svg = document3.createElementNS(svgNamespace2, "svg");
    try {
      svg.insertAdjacentHTML("beforeend", "<circle></circle>");
    } catch {
    } finally {
      return 1 !== svg.childNodes.length || svg.firstChild.namespaceURI !== NS_SVG;
    }
  })(document2, svgNamespace)) return DOMClass;
  const div = document2.createElement("div");
  return class extends DOMClass {
    insertHTMLBefore(parent, nextSibling, html) {
      return "" === html || parent.namespaceURI !== svgNamespace ? super.insertHTMLBefore(parent, nextSibling, html) : (function(parent2, div2, html2, reference) {
        let source;
        if ("FOREIGNOBJECT" === parent2.tagName.toUpperCase()) {
          const wrappedHtml = "<svg><foreignObject>" + html2 + "</foreignObject></svg>";
          clearElement(div2), div2.insertAdjacentHTML("afterbegin", wrappedHtml), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
          source = div2.firstChild.firstChild;
        } else {
          const wrappedHtml = "<svg>" + html2 + "</svg>";
          clearElement(div2), div2.insertAdjacentHTML("afterbegin", wrappedHtml), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
          source = div2.firstChild;
        }
        return (function(source2, target, nextSibling2) {
          const first = source2.firstChild;
          let last = first, current = first;
          for (; current; ) {
            const next = current.nextSibling;
            target.insertBefore(current, nextSibling2), last = current, current = next;
          }
          return new ConcreteBounds(target, first, last);
        })(source, parent2, reference);
      })(parent, div, html, nextSibling);
    }
  };
}
function applyTextNodeMergingFix(document2, DOMClass) {
  return document2 && (function(document3) {
    const mergingTextDiv = document3.createElement("div");
    return mergingTextDiv.appendChild(document3.createTextNode("first")), mergingTextDiv.insertAdjacentHTML("beforeend", "second"), 2 !== mergingTextDiv.childNodes.length;
  })(document2) ? class extends DOMClass {
    constructor(document3) {
      super(document3), this.uselessComment = document3.createComment("");
    }
    insertHTMLBefore(parent, nextSibling, html) {
      if ("" === html) return super.insertHTMLBefore(parent, nextSibling, html);
      let didSetUselessComment = false;
      const nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
      nextPrevious && nextPrevious instanceof Text && (didSetUselessComment = true, parent.insertBefore(this.uselessComment, nextSibling));
      const bounds = super.insertHTMLBefore(parent, nextSibling, html);
      return didSetUselessComment && parent.removeChild(this.uselessComment), bounds;
    }
  } : DOMClass;
}
var doc$1 = "undefined" == typeof document ? null : castToSimple(document);
var appliedTreeConstruction = class extends DOMOperations {
  createElementNS(namespace, tag) {
    return this.document.createElementNS(namespace, tag);
  }
  setAttribute(element, name, value, namespace = null) {
    namespace ? element.setAttributeNS(namespace, name, value) : element.setAttribute(name, value);
  }
};
appliedTreeConstruction = applyTextNodeMergingFix(doc$1, appliedTreeConstruction), appliedTreeConstruction = applySVGInnerHTMLFix(doc$1, appliedTreeConstruction, NS_SVG);
var DOMTreeConstruction = appliedTreeConstruction;
["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach((tag) => BLACKLIST_TABLE[tag] = 1);
var doc = "undefined" == typeof document ? null : castToSimple(document);
var DOMChangesImpl = class extends DOMOperations {
  constructor(document1) {
    super(document1), this.document = document1, this.namespace = null;
  }
  setAttribute(element, name, value) {
    element.setAttribute(name, value);
  }
  removeAttribute(element, name) {
    element.removeAttribute(name);
  }
  insertAfter(element, node, reference) {
    this.insertBefore(element, node, reference.nextSibling);
  }
};
var helper = DOMChangesImpl;
helper = applyTextNodeMergingFix(doc, helper), helper = applySVGInnerHTMLFix(doc, helper, NS_SVG);
function normalizeProperty(element, slotName) {
  let type, normalized;
  if (slotName in element) normalized = slotName, type = "prop";
  else {
    let lower = slotName.toLowerCase();
    lower in element ? (type = "prop", normalized = lower) : (type = "attr", normalized = slotName);
  }
  return "prop" !== type || "style" !== normalized.toLowerCase() && !(function(tagName, propName) {
    let tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return !(!tag || !tag[propName.toLowerCase()]);
  })(element.tagName, normalized) || (type = "attr"), {
    normalized,
    type
  };
}
var ATTR_OVERRIDES = {
  INPUT: {
    form: true,
    // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
    // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
    // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
    autocorrect: true,
    // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
    // Safari 9.1.3: 'list' in document.createElement('input') === false
    list: true
  },
  // element.form is actually a legitimate readOnly property, that is to be
  // mutated, but must be mutated by setAttribute...
  SELECT: {
    form: true
  },
  OPTION: {
    form: true
  },
  TEXTAREA: {
    form: true
  },
  LABEL: {
    form: true
  },
  FIELDSET: {
    form: true
  },
  LEGEND: {
    form: true
  },
  OBJECT: {
    form: true
  },
  OUTPUT: {
    form: true
  },
  BUTTON: {
    form: true
  }
};
var TRANSACTION = Symbol("TRANSACTION");
var TransactionImpl = class {
  didCreate(component) {
    this.createdComponents.push(component);
  }
  didUpdate(component) {
    this.updatedComponents.push(component);
  }
  scheduleInstallModifier(modifier) {
    this.scheduledInstallModifiers.push(modifier);
  }
  scheduleUpdateModifier(modifier) {
    this.scheduledUpdateModifiers.push(modifier);
  }
  commit() {
    let {
      createdComponents,
      updatedComponents
    } = this;
    for (const {
      manager,
      state
    } of createdComponents) manager.didCreate(state);
    for (const {
      manager,
      state
    } of updatedComponents) manager.didUpdate(state);
    let {
      scheduledInstallModifiers,
      scheduledUpdateModifiers
    } = this;
    for (const {
      manager,
      state,
      definition
    } of scheduledInstallModifiers) {
      let modifierTag = manager.getTag(state);
      if (null !== modifierTag) {
        let tag = track(() => manager.install(state), `- While rendering:
  (instance of a \`${definition.resolvedName || manager.getDebugName(definition.state)}\` modifier)`);
        UPDATE_TAG(modifierTag, tag);
      } else manager.install(state);
    }
    for (const {
      manager,
      state,
      definition
    } of scheduledUpdateModifiers) {
      let modifierTag = manager.getTag(state);
      if (null !== modifierTag) {
        let tag = track(() => manager.update(state), `- While rendering:
  (instance of a \`${definition.resolvedName || manager.getDebugName(definition.state)}\` modifier)`);
        UPDATE_TAG(modifierTag, tag);
      } else manager.update(state);
    }
  }
  constructor() {
    this.scheduledInstallModifiers = [], this.scheduledUpdateModifiers = [], this.createdComponents = [], this.updatedComponents = [];
  }
};
var EnvironmentImpl = class {
  constructor(options, delegate) {
    if (this.delegate = delegate, this[_TRANSACTION] = null, this.isInteractive = delegate.isInteractive, this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTreeImpl() : void 0, this.isArgumentCaptureError = this.delegate.enableDebugTooling ? isArgumentError : void 0, options.appendOperations) this.appendOperations = options.appendOperations, this.updateOperations = options.updateOperations;
    else if (options.document) this.appendOperations = new DOMTreeConstruction(options.document), this.updateOperations = new DOMChangesImpl(options.document);
    else if (true) throw new Error("you must pass document or appendOperations to a new runtime");
  }
  getAppendOperations() {
    return this.appendOperations;
  }
  getDOM() {
    return this.updateOperations;
  }
  begin() {
    this[TRANSACTION], this.debugRenderTree?.begin(), this[TRANSACTION] = new TransactionImpl();
  }
  get transaction() {
    return this[TRANSACTION];
  }
  didCreate(component) {
    this.transaction.didCreate(component);
  }
  didUpdate(component) {
    this.transaction.didUpdate(component);
  }
  scheduleInstallModifier(modifier) {
    this.isInteractive && this.transaction.scheduleInstallModifier(modifier);
  }
  scheduleUpdateModifier(modifier) {
    this.isInteractive && this.transaction.scheduleUpdateModifier(modifier);
  }
  commit() {
    let transaction = this.transaction;
    this[TRANSACTION] = null, transaction.commit(), this.debugRenderTree?.commit(), this.delegate.onTransactionCommit();
  }
};
_TRANSACTION = TRANSACTION;
function runtimeOptions(options, delegate, artifacts2, resolver) {
  return {
    env: new EnvironmentImpl(options, delegate),
    program: new ProgramImpl(artifacts2.constants, artifacts2.heap),
    resolver
  };
}
function inTransaction(env, block) {
  if (env[TRANSACTION]) block();
  else {
    env.begin();
    try {
      block();
    } finally {
      env.commit();
    }
  }
}
var _TRANSACTION;
function internalHelper(helper2) {
  return setInternalHelperManager(helper2, {});
}
var array = internalHelper(({
  positional
}) => createComputeRef(() => reifyPositional(positional), null, "array"));
var normalizeTextValue = (value) => ((value2) => null == value2 || "function" != typeof value2.toString)(value) ? "" : String(value);
var concat = internalHelper(({
  positional
}) => createComputeRef(() => reifyPositional(positional).map(normalizeTextValue).join(""), null, "concat"));
var context = buildUntouchableThis("`fn` helper");
var fn = internalHelper(({
  positional
}) => {
  let callbackRef = positional[0];
  return createComputeRef(() => (...invocationArgs) => {
    let [fn2, ...args] = reifyPositional(positional);
    if ((function(callbackRef2) {
      if (!callbackRef2 || !isInvokableRef(callbackRef2) && "function" != typeof valueForRef(callbackRef2)) throw new Error(`You must pass a function as the \`fn\` helper's first argument, you passed ${callbackRef2 ? valueForRef(callbackRef2) : callbackRef2}. While rendering:

${callbackRef2?.debugLabel}`);
    })(callbackRef), !isInvokableRef(callbackRef))
      return fn2.call(context, ...args, ...invocationArgs);
    {
      let value = args.length > 0 ? args[0] : invocationArgs[0];
      updateRef(callbackRef, value);
    }
  }, null, "fn");
});
var get = internalHelper(({
  positional
}) => {
  let sourceRef = positional[0] ?? UNDEFINED_REFERENCE, pathRef = positional[1] ?? UNDEFINED_REFERENCE;
  return createComputeRef(() => {
    let source = valueForRef(sourceRef);
    if (isDict(source)) return getPath(source, String(valueForRef(pathRef)));
  }, (value) => {
    let source = valueForRef(sourceRef);
    if (isDict(source)) return setPath(source, String(valueForRef(pathRef)), value);
  }, "get");
});
var hash = internalHelper(({
  named
}) => {
  let ref = createComputeRef(() => reifyNamed(named), null, "hash"), children = /* @__PURE__ */ new Map();
  for (let name in named) children.set(name, named[name]);
  return ref.children = children, ref;
});
var untouchableContext = buildUntouchableThis("`on` modifier");
var OnModifierState = class {
  constructor(element, args) {
    this.tag = createUpdatableTag(), this.listener = null, this.element = element, this.args = args, registerDestructor(this, () => {
      let {
        element: element2,
        listener
      } = this;
      if (listener) {
        let {
          eventName,
          callback: callback2,
          options
        } = listener;
        removeEventListener(element2, eventName, callback2, options);
      }
    });
  }
  // Update this.listener if needed
  updateListener() {
    let {
      element,
      args,
      listener
    } = this;
    args.positional[0];
    let eventName = valueForRef(args.positional[0]);
    args.positional[1];
    let once, passive, capture, userProvidedCallback = valueForRef(args.positional[1]);
    if (2 !== args.positional.length) throw new Error(`You can only pass two positional arguments (event name and callback) to the \`on\` modifier, but you provided ${args.positional.length}. Consider using the \`fn\` helper to provide additional arguments to the \`on\` callback.`);
    if (true) {
      let {
        once: _once,
        passive: _passive,
        capture: _capture,
        ...extra
      } = reifyNamed(args.named);
      if (once = _once, passive = _passive, capture = _capture, Object.keys(extra).length > 0) throw new Error(`You can only \`once\`, \`passive\` or \`capture\` named arguments to the \`on\` modifier, but you provided ${Object.keys(extra).join(", ")}.`);
    } else {
      let {
        once: _once,
        passive: _passive,
        capture: _capture
      } = args.named;
      _once && (once = valueForRef(_once)), _passive && (passive = valueForRef(_passive)), _capture && (capture = valueForRef(_capture));
    }
    let options, shouldUpdate = false;
    if (shouldUpdate = null === listener || eventName !== listener.eventName || userProvidedCallback !== listener.userProvidedCallback || once !== listener.once || passive !== listener.passive || capture !== listener.capture, // we want to handle both `true` and `false` because both have a meaning:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=770208
    shouldUpdate && (void 0 === once && void 0 === passive && void 0 === capture || (options = {
      once,
      passive,
      capture
    })), shouldUpdate) {
      let callback2 = userProvidedCallback;
      if (callback2 = userProvidedCallback.bind(untouchableContext), passive) {
        let _callback = callback2;
        callback2 = (event) => (event.preventDefault = () => {
          throw new Error(`You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': 

${userProvidedCallback.name || "{anonymous function}"}`);
        }, _callback(event));
      }
      this.listener = {
        eventName,
        callback: callback2,
        userProvidedCallback,
        once,
        passive,
        capture,
        options
      }, listener && removeEventListener(element, listener.eventName, listener.callback, listener.options), (function(element2, eventName2, callback3, options2) {
        adds++, element2.addEventListener(eventName2, callback3, options2);
      })(element, eventName, callback2, options);
    }
  }
};
var adds = 0;
var removes = 0;
function removeEventListener(element, eventName, callback2, options) {
  removes++, element.removeEventListener(eventName, callback2, options);
}
var on = setInternalModifierManager(new class {
  getDebugName() {
    return "on";
  }
  getDebugInstance() {
    return null;
  }
  get counters() {
    return {
      adds,
      removes
    };
  }
  create(_owner, element, _state, args) {
    return new OnModifierState(element, args);
  }
  getTag({
    tag
  }) {
    return tag;
  }
  install(state) {
    state.updateListener();
  }
  update(state) {
    state.updateListener();
  }
  getDestroyable(state) {
    return state;
  }
}(), {});
var LowLevelVM = class {
  constructor(stack, context2, externs, registers) {
    this.stack = stack, this.externs = externs, this.currentOpSize = 0, this.context = context2, this.registers = registers;
  }
  fetchRegister(register) {
    return this.registers[register];
  }
  loadRegister(register, value) {
    this.registers[register] = value;
  }
  setPc(pc) {
    this.registers[$pc] = pc;
  }
  // Start a new frame and save $ra and $fp on the stack
  pushFrame() {
    this.stack.push(this.registers[$ra]), this.stack.push(this.registers[$fp]), this.registers[$fp] = this.registers[$sp] - 1;
  }
  // Restore $ra, $sp and $fp
  popFrame() {
    this.registers[$sp] = this.registers[$fp] - 1, this.registers[$ra] = this.stack.get(0), this.registers[$fp] = this.stack.get(1);
  }
  pushSmallFrame() {
    this.stack.push(this.registers[$ra]);
  }
  popSmallFrame() {
    this.registers[$ra] = this.stack.pop();
  }
  // Jump to an address in `program`
  goto(offset) {
    this.setPc(this.target(offset));
  }
  target(offset) {
    return this.registers[$pc] + offset - this.currentOpSize;
  }
  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
  call(handle) {
    this.registers[$ra] = this.registers[$pc], this.setPc(this.context.program.heap.getaddr(handle));
  }
  // Put a specific `program` address in $ra
  returnTo(offset) {
    this.registers[$ra] = this.target(offset);
  }
  // Return to the `program` address stored in $ra
  return() {
    this.setPc(this.registers[$ra]);
  }
  nextStatement() {
    let {
      registers,
      context: context2
    } = this, pc = registers[$pc];
    if (-1 === pc) return null;
    let opcode = context2.program.opcode(pc), operationSize = this.currentOpSize = opcode.size;
    return this.registers[$pc] += operationSize, opcode;
  }
  evaluateOuter(opcode, vm) {
    this.evaluateInner(opcode, vm);
  }
  evaluateInner(opcode, vm) {
    opcode.isMachine ? this.evaluateMachine(opcode, vm) : this.evaluateSyscall(opcode, vm);
  }
  evaluateMachine(opcode, vm) {
    switch (opcode.type) {
      case 0:
        return void this.pushFrame();
      case 1:
        return void this.popFrame();
      case 3:
        return void this.call(opcode.op1);
      case 2:
        return void vm.call(this.stack.pop());
      case 4:
        return void this.goto(opcode.op1);
      case 5:
        return void vm.return();
      case 6:
        return void this.returnTo(opcode.op1);
    }
  }
  evaluateSyscall(opcode, vm) {
    APPEND_OPCODES.evaluate(vm, opcode, opcode.type);
  }
};
var badProtocols = ["javascript:", "vbscript:"];
var badTags = ["A", "BODY", "LINK", "IMG", "IFRAME", "BASE", "FORM"];
var badTagsForDataURI = ["EMBED"];
var badAttributes = ["href", "src", "background", "action"];
var badAttributesForDataURI = ["src"];
function has(array2, item) {
  return -1 !== array2.indexOf(item);
}
function checkURI(tagName, attribute) {
  return (null === tagName || has(badTags, tagName)) && has(badAttributes, attribute);
}
function checkDataURI(tagName, attribute) {
  return null !== tagName && has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
}
function requiresSanitization(tagName, attribute) {
  return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
}
var _protocolForUrlImplementation;
var DebugStyleAttributeManager;
function sanitizeAttributeValue(element, attribute, value) {
  if (null == value) return value;
  if (isSafeString(value)) return value.toHTML();
  const tagName = element.tagName.toUpperCase();
  let str = normalizeStringValue(value);
  if (checkURI(tagName, attribute)) {
    let protocol = (url = str, _protocolForUrlImplementation || (_protocolForUrlImplementation = (function() {
      const weirdURL = URL;
      if ("object" == typeof weirdURL && null !== weirdURL && // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check
      // thinks it is `never` without this `as unknown as any`
      "function" == typeof weirdURL.parse) {
        let nodeURL = weirdURL;
        return (url2) => {
          let protocol2 = null;
          return "string" == typeof url2 && (protocol2 = nodeURL.parse(url2).protocol), null === protocol2 ? ":" : protocol2;
        };
      }
      if ("function" == typeof weirdURL) return (_url) => {
        try {
          return new weirdURL(_url).protocol;
        } catch {
          return ":";
        }
      };
      throw new Error('@glimmer/runtime needs a valid "globalThis.URL"');
    })()), _protocolForUrlImplementation(url));
    if (has(badProtocols, protocol)) return `unsafe:${str}`;
  }
  var url;
  return checkDataURI(tagName, attribute) ? `unsafe:${str}` : str;
}
function dynamicAttribute(element, attr, namespace, isTrusting = false) {
  const {
    tagName,
    namespaceURI
  } = element, attribute = {
    element,
    name: attr,
    namespace
  };
  if ("style" === attr && !isTrusting) return new DebugStyleAttributeManager(attribute);
  if (namespaceURI === NS_SVG) return buildDynamicAttribute(tagName, attr, attribute);
  const {
    type,
    normalized
  } = normalizeProperty(element, attr);
  return "attr" === type ? buildDynamicAttribute(tagName, normalized, attribute) : (function(tagName2, name, attribute2) {
    return requiresSanitization(tagName2, name) ? new SafeDynamicProperty(name, attribute2) : /* @__PURE__ */ (function(tagName3, attribute3) {
      return ("INPUT" === tagName3 || "TEXTAREA" === tagName3) && "value" === attribute3;
    })(tagName2, name) ? new InputValueDynamicAttribute(name, attribute2) : /* @__PURE__ */ (function(tagName3, attribute3) {
      return "OPTION" === tagName3 && "selected" === attribute3;
    })(tagName2, name) ? new OptionSelectedDynamicAttribute(name, attribute2) : new DefaultDynamicProperty(name, attribute2);
  })(tagName, normalized, attribute);
}
function buildDynamicAttribute(tagName, name, attribute) {
  return requiresSanitization(tagName, name) ? new SafeDynamicAttribute(attribute) : new SimpleDynamicAttribute(attribute);
}
var DynamicAttribute = class {
  constructor(attribute) {
    this.attribute = attribute;
  }
};
var SimpleDynamicAttribute = class extends DynamicAttribute {
  set(dom, value, _env) {
    const normalizedValue = normalizeValue(value);
    if (null !== normalizedValue) {
      const {
        name,
        namespace
      } = this.attribute;
      dom.__setAttribute(name, normalizedValue, namespace);
    }
  }
  update(value, _env) {
    const normalizedValue = normalizeValue(value), {
      element,
      name
    } = this.attribute;
    null === normalizedValue ? element.removeAttribute(name) : element.setAttribute(name, normalizedValue);
  }
};
var DefaultDynamicProperty = class extends DynamicAttribute {
  constructor(normalizedName, attribute) {
    super(attribute), this.normalizedName = normalizedName;
  }
  set(dom, value, _env) {
    null != value && (this.value = value, dom.__setProperty(this.normalizedName, value));
  }
  update(value, _env) {
    const {
      element
    } = this.attribute;
    this.value !== value && (element[this.normalizedName] = this.value = value, null == value && this.removeAttribute());
  }
  removeAttribute() {
    const {
      element,
      namespace
    } = this.attribute;
    namespace ? element.removeAttributeNS(namespace, this.normalizedName) : element.removeAttribute(this.normalizedName);
  }
};
var SafeDynamicProperty = class extends DefaultDynamicProperty {
  set(dom, value, env) {
    const {
      element,
      name
    } = this.attribute, sanitized = sanitizeAttributeValue(element, name, value);
    super.set(dom, sanitized, env);
  }
  update(value, env) {
    const {
      element,
      name
    } = this.attribute, sanitized = sanitizeAttributeValue(element, name, value);
    super.update(sanitized, env);
  }
};
var SafeDynamicAttribute = class extends SimpleDynamicAttribute {
  set(dom, value, env) {
    const {
      element,
      name
    } = this.attribute, sanitized = sanitizeAttributeValue(element, name, value);
    super.set(dom, sanitized, env);
  }
  update(value, env) {
    const {
      element,
      name
    } = this.attribute, sanitized = sanitizeAttributeValue(element, name, value);
    super.update(sanitized, env);
  }
};
var InputValueDynamicAttribute = class extends DefaultDynamicProperty {
  set(dom, value) {
    dom.__setProperty("value", normalizeStringValue(value));
  }
  update(value) {
    const input = this.attribute.element, currentValue = input.value, normalizedValue = normalizeStringValue(value);
    currentValue !== normalizedValue && (input.value = normalizedValue);
  }
};
var OptionSelectedDynamicAttribute = class extends DefaultDynamicProperty {
  set(dom, value) {
    null != value && false !== value && dom.__setProperty("selected", true);
  }
  update(value) {
    this.attribute.element.selected = !!value;
  }
};
function normalizeValue(value) {
  return false === value || null == value || void 0 === value.toString ? null : true === value ? "" : (
    // onclick function etc in SSR
    "function" == typeof value ? null : String(value)
  );
}
DebugStyleAttributeManager = class extends SimpleDynamicAttribute {
  set(dom, value, env) {
    warnIfStyleNotTrusted(value), super.set(dom, value, env);
  }
  update(value, env) {
    warnIfStyleNotTrusted(value), super.update(value, env);
  }
};
var First = class {
  constructor(node) {
    this.node = node;
  }
  firstNode() {
    return this.node;
  }
};
var Last = class {
  constructor(node) {
    this.node = node;
  }
  lastNode() {
    return this.node;
  }
};
var NewTreeBuilder = class {
  static forInitialRender(env, cursor) {
    return new this(env, cursor.element, cursor.nextSibling).initialize();
  }
  static resume(env, block) {
    let stack = new this(env, block.parentElement(), block.reset(env)).initialize();
    return stack.pushBlock(block), stack;
  }
  constructor(env, parentNode, nextSibling) {
    this.constructing = null, this.operations = null, this.cursors = new StackImpl(), this.modifierStack = new StackImpl(), this.blockStack = new StackImpl(), this.pushElement(parentNode, nextSibling), this.env = env, this.dom = env.getAppendOperations(), this.updateOperations = env.getDOM();
  }
  initialize() {
    return this.pushAppendingBlock(), this;
  }
  debugBlocks() {
    return this.blockStack.toArray();
  }
  get element() {
    return this.cursors.current.element;
  }
  get nextSibling() {
    return this.cursors.current.nextSibling;
  }
  get hasBlocks() {
    return this.blockStack.size > 0;
  }
  block() {
    return this.blockStack.current;
  }
  popElement() {
    this.cursors.pop(), this.cursors.current;
  }
  pushAppendingBlock() {
    return this.pushBlock(new AppendingBlockImpl(this.element));
  }
  pushResettableBlock() {
    return this.pushBlock(new ResettableBlockImpl(this.element));
  }
  pushBlockList(list) {
    return this.pushBlock(new AppendingBlockList(this.element, list));
  }
  pushBlock(block, isRemote = false) {
    let current = this.blockStack.current;
    return null !== current && (isRemote || current.didAppendBounds(block)), this.__openBlock(), this.blockStack.push(block), block;
  }
  popBlock() {
    return this.block().finalize(this), this.__closeBlock(), this.blockStack.pop();
  }
  __openBlock() {
  }
  __closeBlock() {
  }
  // todo return seems unused
  openElement(tag) {
    let element = this.__openElement(tag);
    return this.constructing = element, element;
  }
  __openElement(tag) {
    return this.dom.createElement(tag, this.element);
  }
  flushElement(modifiers) {
    let parent = this.element, element = this.constructing;
    this.__flushElement(parent, element), this.constructing = null, this.operations = null, this.pushModifiers(modifiers), this.pushElement(element, null), this.didOpenElement(element);
  }
  __flushElement(parent, constructing) {
    this.dom.insertBefore(parent, constructing, this.nextSibling);
  }
  closeElement() {
    return this.willCloseElement(), this.popElement(), this.popModifiers();
  }
  pushRemoteElement(element, guid, insertBefore) {
    return this.__pushRemoteElement(element, guid, insertBefore);
  }
  __pushRemoteElement(element, _guid, insertBefore) {
    if (this.pushElement(element, insertBefore), void 0 === insertBefore) for (; element.lastChild; ) element.removeChild(element.lastChild);
    let block = new RemoteBlock(element);
    return this.pushBlock(block, true);
  }
  popRemoteElement() {
    const block = this.popBlock();
    return this.popElement(), block;
  }
  pushElement(element, nextSibling = null) {
    this.cursors.push(new CursorImpl(element, nextSibling));
  }
  pushModifiers(modifiers) {
    this.modifierStack.push(modifiers);
  }
  popModifiers() {
    return this.modifierStack.pop();
  }
  didAppendBounds(bounds) {
    return this.block().didAppendBounds(bounds), bounds;
  }
  didAppendNode(node) {
    return this.block().didAppendNode(node), node;
  }
  didOpenElement(element) {
    return this.block().openElement(element), element;
  }
  willCloseElement() {
    this.block().closeElement();
  }
  appendText(string) {
    return this.didAppendNode(this.__appendText(string));
  }
  __appendText(text) {
    let {
      dom,
      element,
      nextSibling
    } = this, node = dom.createTextNode(text);
    return dom.insertBefore(element, node, nextSibling), node;
  }
  __appendNode(node) {
    return this.dom.insertBefore(this.element, node, this.nextSibling), node;
  }
  __appendFragment(fragment) {
    let first = fragment.firstChild;
    if (first) {
      let ret = new ConcreteBounds(this.element, first, fragment.lastChild);
      return this.dom.insertBefore(this.element, fragment, this.nextSibling), ret;
    }
    {
      const comment = this.__appendComment("");
      return new ConcreteBounds(this.element, comment, comment);
    }
  }
  __appendHTML(html) {
    return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
  }
  appendDynamicHTML(value) {
    let bounds = this.trustedContent(value);
    this.didAppendBounds(bounds);
  }
  appendDynamicText(value) {
    let node = this.untrustedContent(value);
    return this.didAppendNode(node), node;
  }
  appendDynamicFragment(value) {
    let bounds = this.__appendFragment(value);
    this.didAppendBounds(bounds);
  }
  appendDynamicNode(value) {
    let node = this.__appendNode(value), bounds = new ConcreteBounds(this.element, node, node);
    this.didAppendBounds(bounds);
  }
  trustedContent(value) {
    return this.__appendHTML(value);
  }
  untrustedContent(value) {
    return this.__appendText(value);
  }
  appendComment(string) {
    return this.didAppendNode(this.__appendComment(string));
  }
  __appendComment(string) {
    let {
      dom,
      element,
      nextSibling
    } = this, node = dom.createComment(string);
    return dom.insertBefore(element, node, nextSibling), node;
  }
  __setAttribute(name, value, namespace) {
    this.dom.setAttribute(this.constructing, name, value, namespace);
  }
  __setProperty(name, value) {
    this.constructing[name] = value;
  }
  setStaticAttribute(name, value, namespace) {
    this.__setAttribute(name, value, namespace);
  }
  setDynamicAttribute(name, value, trusting, namespace) {
    let attribute = dynamicAttribute(this.constructing, name, namespace, trusting);
    return attribute.set(this, value, this.env), attribute;
  }
};
var AppendingBlockImpl = class {
  constructor(parent) {
    this.parent = parent, this.first = null, this.last = null, this.nesting = 0;
  }
  parentElement() {
    return this.parent;
  }
  firstNode() {
    return this.first.firstNode();
  }
  lastNode() {
    return this.last.lastNode();
  }
  openElement(element) {
    this.didAppendNode(element), this.nesting++;
  }
  closeElement() {
    this.nesting--;
  }
  didAppendNode(node) {
    0 === this.nesting && (this.first || (this.first = new First(node)), this.last = new Last(node));
  }
  didAppendBounds(bounds) {
    0 === this.nesting && (this.first || (this.first = bounds), this.last = bounds);
  }
  finalize(stack) {
    null === this.first && stack.appendComment("");
  }
};
var RemoteBlock = class extends AppendingBlockImpl {
  constructor(parent) {
    super(parent), registerDestructor(this, () => {
      this.parentElement() === this.firstNode().parentNode && clear(this);
    });
  }
};
var ResettableBlockImpl = class extends AppendingBlockImpl {
  constructor(parent) {
    super(parent);
  }
  reset() {
    destroy(this);
    let nextSibling = clear(this);
    return this.first = null, this.last = null, this.nesting = 0, nextSibling;
  }
};
var AppendingBlockList = class {
  constructor(parent, boundList) {
    this.parent = parent, this.boundList = boundList, this.parent = parent, this.boundList = boundList;
  }
  parentElement() {
    return this.parent;
  }
  firstNode() {
    return this.boundList[0].firstNode();
  }
  lastNode() {
    let boundList = this.boundList;
    return boundList[boundList.length - 1].lastNode();
  }
  openElement(_element) {
  }
  closeElement() {
  }
  didAppendNode(_node) {
  }
  didAppendBounds(_bounds) {
  }
  finalize(_stack) {
    this.boundList.length;
  }
};
function clientBuilder(env, cursor) {
  return NewTreeBuilder.forInitialRender(env, cursor);
}
var UpdatingVM = class {
  constructor(env, {
    alwaysRevalidate = false
  }) {
    this.frameStack = new StackImpl(), this.env = env, this.dom = env.getDOM(), this.alwaysRevalidate = alwaysRevalidate;
  }
  execute(opcodes2, handler) {
    if (true) {
      let hasErrored = true;
      try {
        debug.runInTrackingTransaction(() => this._execute(opcodes2, handler), "- While rendering:"), // using a boolean here to avoid breaking ergonomics of "pause on uncaught exceptions"
        // which would happen with a `catch` + `throw`
        hasErrored = false;
      } finally {
        hasErrored && // eslint-disable-next-line no-console
        console.error(`

Error occurred:

${resetTracking()}

`);
      }
    } else this._execute(opcodes2, handler);
  }
  _execute(opcodes2, handler) {
    let {
      frameStack
    } = this;
    for (this.try(opcodes2, handler); !frameStack.isEmpty(); ) {
      let opcode = this.frame.nextStatement();
      void 0 !== opcode ? opcode.evaluate(this) : frameStack.pop();
    }
  }
  get frame() {
    return this.frameStack.current;
  }
  goto(index) {
    this.frame.goto(index);
  }
  try(ops, handler) {
    this.frameStack.push(new UpdatingVMFrame(ops, handler));
  }
  throw() {
    this.frame.handleException(), this.frameStack.pop();
  }
};
var BlockOpcode = class {
  constructor(state, context2, bounds, children) {
    this.state = state, this.context = context2, this.children = children, this.bounds = bounds;
  }
  parentElement() {
    return this.bounds.parentElement();
  }
  firstNode() {
    return this.bounds.firstNode();
  }
  lastNode() {
    return this.bounds.lastNode();
  }
  evaluate(vm) {
    vm.try(this.children, null);
  }
};
var TryOpcode = class extends BlockOpcode {
  evaluate(vm) {
    vm.try(this.children, this);
  }
  handleException() {
    let {
      state,
      bounds,
      context: {
        env
      }
    } = this;
    destroyChildren(this);
    let tree = NewTreeBuilder.resume(env, bounds), vm = state.evaluate(tree), children = this.children = [], result = vm.execute((vm2) => {
      vm2.updateWith(this), vm2.pushUpdating(children);
    });
    associateDestroyableChild(this, result.drop);
  }
  constructor(...args) {
    super(...args), this.type = "try";
  }
};
var ListItemOpcode = class extends TryOpcode {
  constructor(state, context2, bounds, key, memo, value) {
    super(state, context2, bounds, []), this.key = key, this.memo = memo, this.value = value, this.retained = false, this.index = -1;
  }
  shouldRemove() {
    return !this.retained;
  }
  reset() {
    this.retained = false;
  }
};
var ListBlockOpcode = class extends BlockOpcode {
  constructor(state, context2, bounds, children, iterableRef) {
    super(state, context2, bounds, children), this.iterableRef = iterableRef, this.type = "list-block", this.opcodeMap = /* @__PURE__ */ new Map(), this.marker = null, this.lastIterator = valueForRef(iterableRef);
  }
  initializeChild(opcode) {
    opcode.index = this.children.length - 1, this.opcodeMap.set(opcode.key, opcode);
  }
  evaluate(vm) {
    let iterator = valueForRef(this.iterableRef);
    if (this.lastIterator !== iterator) {
      let {
        bounds
      } = this, {
        dom
      } = vm, marker = this.marker = dom.createComment("");
      dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode()), this.sync(iterator), this.parentElement().removeChild(marker), this.marker = null, this.lastIterator = iterator;
    }
    super.evaluate(vm);
  }
  sync(iterator) {
    let {
      opcodeMap: itemMap,
      children
    } = this, currentOpcodeIndex = 0, seenIndex = 0;
    for (this.children = this.bounds.boundList = []; ; ) {
      let item = iterator.next();
      if (null === item) break;
      let opcode = children[currentOpcodeIndex], {
        key
      } = item;
      for (; void 0 !== opcode && opcode.retained; ) opcode = children[++currentOpcodeIndex];
      if (void 0 !== opcode && opcode.key === key) this.retainItem(opcode, item), currentOpcodeIndex++;
      else if (itemMap.has(key)) {
        let itemOpcode = itemMap.get(key);
        if (itemOpcode.index < seenIndex) this.moveItem(itemOpcode, item, opcode);
        else {
          seenIndex = itemOpcode.index;
          let seenUnretained = false;
          for (let i = currentOpcodeIndex + 1; i < seenIndex; i++) if (!children[i].retained) {
            seenUnretained = true;
            break;
          }
          seenUnretained ? (this.moveItem(itemOpcode, item, opcode), currentOpcodeIndex++) : (this.retainItem(itemOpcode, item), currentOpcodeIndex = seenIndex + 1);
        }
      } else this.insertItem(item, opcode);
    }
    for (const opcode of children) opcode.retained ? opcode.reset() : this.deleteItem(opcode);
  }
  retainItem(opcode, item) {
    let {
      children
    } = this;
    updateRef(opcode.memo, item.memo), updateRef(opcode.value, item.value), opcode.retained = true, opcode.index = children.length, children.push(opcode);
  }
  insertItem(item, before) {
    let {
      opcodeMap,
      bounds,
      state,
      children,
      context: {
        env
      }
    } = this, {
      key
    } = item, nextSibling = void 0 === before ? this.marker : before.firstNode(), elementStack = NewTreeBuilder.forInitialRender(env, {
      element: bounds.parentElement(),
      nextSibling
    });
    state.evaluate(elementStack).execute((vm) => {
      let opcode = vm.enterItem(item);
      opcode.index = children.length, children.push(opcode), opcodeMap.set(key, opcode), associateDestroyableChild(this, opcode);
    });
  }
  moveItem(opcode, item, before) {
    let currentSibling, nextSibling, {
      children
    } = this;
    updateRef(opcode.memo, item.memo), updateRef(opcode.value, item.value), opcode.retained = true, void 0 === before ? move(opcode, this.marker) : (currentSibling = opcode.lastNode().nextSibling, nextSibling = before.firstNode(), // Items are moved throughout the algorithm, so there are cases where the
    // the items already happen to be siblings (e.g. an item in between was
    // moved before this move happened). Check to see if they are siblings
    // first before doing the move.
    currentSibling !== nextSibling && move(opcode, nextSibling)), opcode.index = children.length, children.push(opcode);
  }
  deleteItem(opcode) {
    destroy(opcode), clear(opcode), this.opcodeMap.delete(opcode.key);
  }
};
var UpdatingVMFrame = class {
  constructor(ops, exceptionHandler) {
    this.ops = ops, this.exceptionHandler = exceptionHandler, this.current = 0;
  }
  goto(index) {
    this.current = index;
  }
  nextStatement() {
    return this.ops[this.current++];
  }
  handleException() {
    this.exceptionHandler && this.exceptionHandler.handleException();
  }
};
var RenderResultImpl = class {
  constructor(env, updating, bounds, drop) {
    this.env = env, this.updating = updating, this.bounds = bounds, this.drop = drop, associateDestroyableChild(this, drop), registerDestructor(this, () => clear(this.bounds));
  }
  rerender({
    alwaysRevalidate = false
  } = {
    alwaysRevalidate: false
  }) {
    let {
      env,
      updating
    } = this;
    new UpdatingVM(env, {
      alwaysRevalidate
    }).execute(updating, this);
  }
  parentElement() {
    return this.bounds.parentElement();
  }
  firstNode() {
    return this.bounds.firstNode();
  }
  lastNode() {
    return this.bounds.lastNode();
  }
  handleException() {
  }
};
var EvaluationStackImpl = class {
  static restore(snapshot, pc) {
    const stack = new this(snapshot.slice(), [0, -1, snapshot.length - 1, 0]);
    return stack.registers[$pc] = pc, stack.registers[$sp] = snapshot.length - 1, stack.registers[$fp] = -1, stack;
  }
  // fp -> sp
  constructor(stack = [], registers) {
    this.stack = stack, this.registers = registers;
  }
  push(value) {
    this.stack[++this.registers[$sp]] = value;
  }
  dup(position = this.registers[$sp]) {
    this.stack[++this.registers[$sp]] = this.stack[position];
  }
  copy(from, to) {
    this.stack[to] = this.stack[from];
  }
  pop(n = 1) {
    let top = this.stack[this.registers[$sp]];
    return this.registers[$sp] -= n, top;
  }
  peek(offset = 0) {
    return this.stack[this.registers[$sp] - offset];
  }
  get(offset, base = this.registers[$fp]) {
    return this.stack[base + offset];
  }
  set(value, offset, base = this.registers[$fp]) {
    this.stack[base + offset] = value;
  }
  slice(start, end) {
    return this.stack.slice(start, end);
  }
  capture(items) {
    let end = this.registers[$sp] + 1, start = end - items;
    return this.stack.slice(start, end);
  }
  reset() {
    this.stack.length = 0;
  }
};
var Stacks = class {
  constructor(scope, dynamicScope) {
    this.drop = {}, this.scope = new StackImpl(), this.dynamicScope = new StackImpl(), this.updating = new StackImpl(), this.cache = new StackImpl(), this.list = new StackImpl(), this.destroyable = new StackImpl(), this.scope.push(scope), this.dynamicScope.push(dynamicScope), this.destroyable.push(this.drop);
  }
};
var VM = class _VM {
  #stacks;
  get stack() {
    return this.lowlevel.stack;
  }
  /* Registers */
  get pc() {
    return this.lowlevel.fetchRegister($pc);
  }
  #registers;
  /**
  * Fetch a value from a syscall register onto the stack.
  *
  * ## Opcodes
  *
  * - Append: `Fetch`
  *
  * ## State changes
  *
  * [!] push Eval Stack <- $register
  */
  fetch(register) {
    let value = this.fetchValue(register);
    this.stack.push(value);
  }
  /**
  * Load a value from the stack into a syscall register.
  *
  * ## Opcodes
  *
  * - Append: `Load`
  *
  * ## State changes
  *
  * [!] pop Eval Stack -> `value`
  * [$] $register <- `value`
  */
  load(register) {
    let value = this.stack.pop();
    this.loadValue(register, value);
  }
  /**
  * Load a value into a syscall register.
  *
  * ## State changes
  *
  * [$] $register <- `value`
  *
  * @utility
  */
  loadValue(register, value) {
    this.#registers[register] = value;
  }
  fetchValue(register) {
    return isLowLevelRegister(register) ? this.lowlevel.fetchRegister(register) : this.#registers[register];
  }
  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
  call(handle) {
    null !== handle && this.lowlevel.call(handle);
  }
  // Return to the `program` address stored in $ra
  return() {
    this.lowlevel.return();
  }
  #tree;
  constructor({
    scope,
    dynamicScope,
    stack,
    pc
  }, context2, tree) {
    this.#registers = [null, null, null, null, null, null, null, null, null], // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    assertGlobalContextWasSet();
    let evalStack = EvaluationStackImpl.restore(stack, pc);
    this.#tree = tree, this.context = context2, this.#stacks = new Stacks(scope, dynamicScope), this.args = new VMArgumentsImpl(), this.lowlevel = new LowLevelVM(evalStack, context2, void 0, evalStack.registers), this.pushUpdating();
  }
  static initial(context2, options) {
    let scope = ScopeImpl.root(options.owner, options.scope ?? {
      self: UNDEFINED_REFERENCE,
      size: 0
    });
    const state = /* @__PURE__ */ (function(pc, scope2, dynamicScope) {
      return {
        pc,
        scope: scope2,
        dynamicScope,
        stack: []
      };
    })(context2.program.heap.getaddr(options.handle), scope, options.dynamicScope);
    return new _VM(state, context2, options.tree);
  }
  compile(block) {
    return unwrapHandle(block.compile(this.context));
  }
  get constants() {
    return this.context.program.constants;
  }
  get program() {
    return this.context.program;
  }
  get env() {
    return this.context.env;
  }
  captureClosure(args, pc = this.lowlevel.fetchRegister($pc)) {
    return {
      pc,
      scope: this.scope(),
      dynamicScope: this.dynamicScope(),
      stack: this.stack.capture(args)
    };
  }
  capture(args, pc = this.lowlevel.fetchRegister($pc)) {
    return new Closure(this.captureClosure(args, pc), this.context);
  }
  /**
  * ## Opcodes
  *
  * - Append: `BeginComponentTransaction`
  *
  * ## State Changes
  *
  * [ ] create `guard` (`JumpIfNotModifiedOpcode`)
  * [ ] create `tracker` (`BeginTrackFrameOpcode`)
  * [!] push Updating Stack <- `guard`
  * [!] push Updating Stack <- `tracker`
  * [!] push Cache Stack <- `guard`
  * [!] push Tracking Stack
  */
  beginCacheGroup(name) {
    let opcodes2 = this.updating(), guard = new JumpIfNotModifiedOpcode();
    opcodes2.push(guard), opcodes2.push(new BeginTrackFrameOpcode(name)), this.#stacks.cache.push(guard), beginTrackFrame(name);
  }
  /**
  * ## Opcodes
  *
  * - Append: `CommitComponentTransaction`
  *
  * ## State Changes
  *
  * Create a new `EndTrackFrameOpcode` (`end`)
  *
  * [!] pop CacheStack -> `guard`
  * [!] pop Tracking Stack -> `tag`
  * [ ] create `end` (`EndTrackFrameOpcode`) with `guard`
  * [-] consume `tag`
  */
  commitCacheGroup() {
    let opcodes2 = this.updating(), guard = this.#stacks.cache.pop(), tag = endTrackFrame();
    opcodes2.push(new EndTrackFrameOpcode(guard)), guard.finalize(tag, opcodes2.length);
  }
  /**
  * ## Opcodes
  *
  * - Append: `Enter`
  *
  * ## State changes
  *
  * [!] push Element Stack as `block`
  * [ ] create `try` (`TryOpcode`) with `block`, capturing `args` from the Eval Stack
  *
  * Did Enter (`try`):
  * [-] associate destroyable `try`
  * [!] push Destroyable Stack <- `try`
  * [!] push Updating List <- `try`
  * [!] push Updating Stack <- `try.children`
  */
  enter(args) {
    let state = this.capture(args), block = this.tree().pushResettableBlock(), tryOpcode = new TryOpcode(state, this.context, block, []);
    this.didEnter(tryOpcode);
  }
  /**
  * ## Opcodes
  *
  * - Append: `Iterate`
  * - Update: `ListBlock`
  *
  * ## State changes
  *
  * Create a new ref for the iterator item (`value`).
  * Create a new ref for the iterator key (`key`).
  *
  * [ ] create `valueRef` (`Reference`) from `value`
  * [ ] create `keyRef` (`Reference`) from `key`
  * [!] push Eval Stack <- `valueRef`
  * [!] push Eval Stack <- `keyRef`
  * [!] push Element Stack <- `UpdatableBlock` as `block`
  * [ ] capture `closure` with *2* items from the Eval Stack
  * [ ] create `iteration` (`ListItemOpcode`) with `closure`, `block`, `key`, `keyRef` and `valueRef`
  *
  * Did Enter (`iteration`):
  * [-] associate destroyable `iteration`
  * [!] push Destroyable Stack <- `iteration`
  * [!] push Updating List <- `iteration`
  * [!] push Updating Stack <- `iteration.children`
  */
  enterItem({
    key,
    value,
    memo
  }) {
    let {
      stack
    } = this, valueRef = createIteratorItemRef(value), memoRef = createIteratorItemRef(memo);
    stack.push(valueRef), stack.push(memoRef);
    let state = this.capture(2), block = this.tree().pushResettableBlock(), opcode = new ListItemOpcode(state, this.context, block, key, memoRef, valueRef);
    return this.didEnter(opcode), opcode;
  }
  registerItem(opcode) {
    this.listBlock().initializeChild(opcode);
  }
  /**
  * ## Opcodes
  *
  * - Append: `EnterList`
  *
  * ## State changes
  *
  * [ ] capture `closure` with *0* items from the Eval Stack, and `$pc` from `offset`
  * [ ] create `updating` (empty `Array`)
  * [!] push Element Stack <- `list` (`BlockList`) with `updating`
  * [ ] create `list` (`ListBlockOpcode`) with `closure`, `list`, `updating` and `iterableRef`
  * [!] push List Stack <- `list`
  *
  * Did Enter (`list`):
  * [-] associate destroyable `list`
  * [!] push Destroyable Stack <- `list`
  * [!] push Updating List <- `list`
  * [!] push Updating Stack <- `list.children`
  */
  enterList(iterableRef, offset) {
    let updating = [], addr = this.lowlevel.target(offset), state = this.capture(0, addr), list = this.tree().pushBlockList(updating), opcode = new ListBlockOpcode(state, this.context, list, updating, iterableRef);
    this.#stacks.list.push(opcode), this.didEnter(opcode);
  }
  /**
  * ## Opcodes
  *
  * - Append: `Enter`
  * - Append: `Iterate`
  * - Append: `EnterList`
  * - Update: `ListBlock`
  *
  * ## State changes
  *
  * [-] associate destroyable `opcode`
  * [!] push Destroyable Stack <- `opcode`
  * [!] push Updating List <- `opcode`
  * [!] push Updating Stack <- `opcode.children`
  *
  */
  didEnter(opcode) {
    this.associateDestroyable(opcode), this.#stacks.destroyable.push(opcode), this.updateWith(opcode), this.pushUpdating(opcode.children);
  }
  /**
  * ## Opcodes
  *
  * - Append: `Exit`
  * - Append: `ExitList`
  *
  * ## State changes
  *
  * [!] pop Destroyable Stack
  * [!] pop Element Stack
  * [!] pop Updating Stack
  */
  exit() {
    this.#stacks.destroyable.pop(), this.#tree.popBlock(), this.popUpdating();
  }
  /**
  * ## Opcodes
  *
  * - Append: `ExitList`
  *
  * ## State changes
  *
  * Pop List:
  * [!] pop Destroyable Stack
  * [!] pop Element Stack
  * [!] pop Updating Stack
  *
  * [!] pop List Stack
  */
  exitList() {
    this.exit(), this.#stacks.list.pop();
  }
  /**
  * ## Opcodes
  *
  * - Append: `RootScope`
  * - Append: `VirtualRootScope`
  *
  * ## State changes
  *
  * [!] push Scope Stack
  */
  pushRootScope(size, owner) {
    let scope = ScopeImpl.sized(owner, size);
    return this.#stacks.scope.push(scope), scope;
  }
  /**
  * ## Opcodes
  *
  * - Append: `ChildScope`
  *
  * ## State changes
  *
  * [!] push Scope Stack <- `child` of current Scope
  */
  pushChildScope() {
    this.#stacks.scope.push(this.scope().child());
  }
  /**
  * ## Opcodes
  *
  * - Append: `Yield`
  *
  * ## State changes
  *
  * [!] push Scope Stack <- `scope`
  */
  pushScope(scope) {
    this.#stacks.scope.push(scope);
  }
  /**
  * ## Opcodes
  *
  * - Append: `PopScope`
  *
  * ## State changes
  *
  * [!] pop Scope Stack
  */
  popScope() {
    this.#stacks.scope.pop();
  }
  /**
  * ## Opcodes
  *
  * - Append: `PushDynamicScope`
  *
  * ## State changes:
  *
  * [!] push Dynamic Scope Stack <- child of current Dynamic Scope
  */
  pushDynamicScope() {
    let child = this.dynamicScope().child();
    return this.#stacks.dynamicScope.push(child), child;
  }
  /**
  * ## Opcodes
  *
  * - Append: `BindDynamicScope`
  *
  * ## State changes:
  *
  * [!] pop Dynamic Scope Stack `names.length` times
  */
  bindDynamicScope(names) {
    let scope = this.dynamicScope();
    for (const name of reverse(names)) scope.set(name, this.stack.pop());
  }
  /**
  * ## State changes
  *
  * - [!] push Updating Stack
  *
  * @utility
  */
  pushUpdating(list = []) {
    this.#stacks.updating.push(list);
  }
  /**
  * ## State changes
  *
  * [!] pop Updating Stack
  *
  * @utility
  */
  popUpdating() {
    return this.#stacks.updating.pop();
  }
  /**
  * ## State changes
  *
  * [!] push Updating List
  *
  * @utility
  */
  updateWith(opcode) {
    this.updating().push(opcode);
  }
  listBlock() {
    return this.#stacks.list.current;
  }
  /**
  * ## State changes
  *
  * [-] associate destroyable `child`
  *
  * @utility
  */
  associateDestroyable(child) {
    let parent = this.#stacks.destroyable.current;
    associateDestroyableChild(parent, child);
  }
  updating() {
    return this.#stacks.updating.current;
  }
  /**
  * Get Tree Builder
  */
  tree() {
    return this.#tree;
  }
  /**
  * Get current Scope
  */
  scope() {
    return this.#stacks.scope.current;
  }
  /**
  * Get current Dynamic Scope
  */
  dynamicScope() {
    return this.#stacks.dynamicScope.current;
  }
  popDynamicScope() {
    this.#stacks.dynamicScope.pop();
  }
  /// SCOPE HELPERS
  getOwner() {
    return this.scope().owner;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getSelf() {
    return this.scope().getSelf();
  }
  referenceForSymbol(symbol) {
    return this.scope().getSymbol(symbol);
  }
  /// EXECUTION
  execute(initialize) {
    if (false) return this._execute(initialize);
    {
      let hasErrored = true;
      try {
        let value = this._execute(initialize);
        return hasErrored = false, value;
      } finally {
        if (hasErrored) {
          let elements = this.tree();
          for (; elements.hasBlocks; ) elements.popBlock();
          console.error(`

Error occurred:

${resetTracking()}

`);
        }
      }
    }
  }
  _execute(initialize) {
    let result;
    initialize && initialize(this);
    do {
      result = this.next();
    } while (!result.done);
    return result.value;
  }
  next() {
    let result, {
      env
    } = this, opcode = this.lowlevel.nextStatement();
    return null !== opcode ? (this.lowlevel.evaluateOuter(opcode, this), result = {
      done: false,
      value: null
    }) : (
      // Unload the stack
      (this.stack.reset(), result = {
        done: true,
        value: new RenderResultImpl(env, this.popUpdating(), this.#tree.popBlock(), this.#stacks.drop)
      })
    ), result;
  }
};
var Closure = class {
  constructor(state, context2) {
    this.state = state, this.context = context2;
  }
  evaluate(tree) {
    return new VM(this.state, this.context, tree);
  }
};
var TemplateIteratorImpl = class {
  constructor(vm) {
    this.vm = vm;
  }
  next() {
    return this.vm.next();
  }
  sync() {
    return true ? debug.runInTrackingTransaction(() => this.vm.execute(), "- While rendering:") : this.vm.execute();
  }
};
function renderMain(context2, owner, self, tree, layout, dynamicScope = new DynamicScopeImpl()) {
  let handle = unwrapHandle(layout.compile(context2)), numSymbols = layout.symbolTable.symbols.length, vm = VM.initial(context2, {
    scope: {
      self,
      size: numSymbols
    },
    dynamicScope,
    tree,
    handle,
    owner
  });
  return new TemplateIteratorImpl(vm);
}
function renderComponent(context2, tree, owner, definition, args = {}, dynamicScope = new DynamicScopeImpl()) {
  return (function(vm, context3, owner2, definition2, args2) {
    const argList = Object.keys(args2).map((key) => [key, args2[key]]), blockNames = ["main", "else", "attrs"], argNames = argList.map(([name]) => `@${name}`);
    let reified = vm.constants.component(definition2, owner2, void 0, "{ROOT}");
    vm.lowlevel.pushFrame();
    for (let i = 0; i < 3 * blockNames.length; i++) vm.stack.push(null);
    vm.stack.push(null), // For each argument, push its backing reference on to the stack
    argList.forEach(([, reference]) => {
      vm.stack.push(reference);
    }), // Configure VM based on blocks and args just pushed on to the stack.
    vm.args.setup(vm.stack, argNames, blockNames, 0, true);
    const compilable = reified.compilable, invocation = {
      handle: unwrapHandle(compilable.compile(context3)),
      symbolTable: compilable.symbolTable
    };
    return vm.stack.push(vm.args), vm.stack.push(invocation), vm.stack.push(reified), new TemplateIteratorImpl(vm);
  })(VM.initial(context2, {
    tree,
    handle: context2.stdlib.main,
    dynamicScope,
    owner
  }), context2, owner, definition, (function(record) {
    const root = createConstRef(record, "args");
    return Object.keys(record).reduce((acc, key) => (acc[key] = childRefFor(root, key), acc), {});
  })(args));
}
var RehydratingCursor = class extends CursorImpl {
  constructor(element, nextSibling, startingBlockDepth) {
    super(element, nextSibling), this.startingBlockDepth = startingBlockDepth, this.candidate = null, this.injectedOmittedNode = false, this.openBlockDepth = startingBlockDepth - 1;
  }
};
var RehydrateTree = class extends NewTreeBuilder {
  constructor(env, parentNode, nextSibling) {
    if (super(env, parentNode, nextSibling), this.unmatchedAttributes = null, this.blockDepth = 0, nextSibling) throw new Error("Rehydration with nextSibling not supported");
    let node = this.currentCursor.element.firstChild;
    for (; null !== node && !isOpenBlock(node); ) node = node.nextSibling;
    this.candidate = node;
    const startingBlockOffset = getBlockDepth(node);
    if (0 !== startingBlockOffset) {
      const newBlockDepth = startingBlockOffset - 1, newCandidate = this.dom.createComment(`%+b:${newBlockDepth}%`);
      node.parentNode.insertBefore(newCandidate, this.candidate);
      let closingNode = node.nextSibling;
      for (; null !== closingNode && (!isCloseBlock(closingNode) || getBlockDepth(closingNode) !== startingBlockOffset); ) closingNode = closingNode.nextSibling;
      const newClosingBlock = this.dom.createComment(`%-b:${newBlockDepth}%`);
      node.parentNode.insertBefore(newClosingBlock, closingNode.nextSibling), this.candidate = newCandidate, this.startingBlockOffset = newBlockDepth;
    } else this.startingBlockOffset = 0;
  }
  get currentCursor() {
    return this.cursors.current;
  }
  get candidate() {
    return this.currentCursor ? this.currentCursor.candidate : null;
  }
  set candidate(node) {
    this.currentCursor.candidate = node;
  }
  disableRehydration(nextSibling) {
    const currentCursor = this.currentCursor;
    currentCursor.candidate = null, currentCursor.nextSibling = nextSibling;
  }
  enableRehydration(candidate) {
    const currentCursor = this.currentCursor;
    currentCursor.candidate = candidate, currentCursor.nextSibling = null;
  }
  pushElement(element, nextSibling = null) {
    const cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);
    null !== this.candidate && (cursor.candidate = element.firstChild, this.candidate = element.nextSibling), this.cursors.push(cursor);
  }
  // clears until the end of the current container
  // either the current open block or higher
  clearMismatch(candidate) {
    let current = candidate;
    const currentCursor = this.currentCursor;
    if (null !== currentCursor) {
      const openBlockDepth = currentCursor.openBlockDepth;
      if (openBlockDepth >= currentCursor.startingBlockDepth) for (; current && !(isCloseBlock(current) && openBlockDepth >= getBlockDepthWithOffset(current, this.startingBlockOffset)); ) current = this.remove(current);
      else for (; null !== current; ) current = this.remove(current);
      this.disableRehydration(current);
    }
  }
  __openBlock() {
    const {
      currentCursor
    } = this;
    if (null === currentCursor) return;
    const blockDepth = this.blockDepth;
    this.blockDepth++;
    const {
      candidate
    } = currentCursor;
    if (null === candidate) return;
    const {
      tagName
    } = currentCursor.element;
    isOpenBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth ? (this.candidate = this.remove(candidate), currentCursor.openBlockDepth = blockDepth) : "TITLE" !== tagName && "SCRIPT" !== tagName && "STYLE" !== tagName && this.clearMismatch(candidate);
  }
  __closeBlock() {
    const {
      currentCursor
    } = this;
    if (null === currentCursor) return;
    const openBlockDepth = currentCursor.openBlockDepth;
    this.blockDepth--;
    const {
      candidate
    } = currentCursor;
    let isRehydrating = false;
    if (null !== candidate)
      if (isRehydrating = true, isCloseBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth) {
        const nextSibling = this.remove(candidate);
        this.candidate = nextSibling, currentCursor.openBlockDepth--;
      } else
        this.clearMismatch(candidate), isRehydrating = false;
    if (!isRehydrating) {
      const nextSibling = currentCursor.nextSibling;
      if (null !== nextSibling && isCloseBlock(nextSibling) && getBlockDepthWithOffset(nextSibling, this.startingBlockOffset) === this.blockDepth) {
        const candidate2 = this.remove(nextSibling);
        this.enableRehydration(candidate2), currentCursor.openBlockDepth--;
      }
    }
  }
  __appendNode(node) {
    const {
      candidate
    } = this;
    return candidate || super.__appendNode(node);
  }
  __appendHTML(html) {
    const candidateBounds = this.markerBounds();
    if (candidateBounds) {
      const first = candidateBounds.firstNode(), last = candidateBounds.lastNode(), newBounds = new ConcreteBounds(this.element, first.nextSibling, last.previousSibling), possibleEmptyMarker = this.remove(first);
      return this.remove(last), null !== possibleEmptyMarker && isEmpty(possibleEmptyMarker) && (this.candidate = this.remove(possibleEmptyMarker), null !== this.candidate && this.clearMismatch(this.candidate)), newBounds;
    }
    return super.__appendHTML(html);
  }
  remove(node) {
    const element = node.parentNode, next = node.nextSibling;
    return element.removeChild(node), next;
  }
  markerBounds() {
    const _candidate = this.candidate;
    if (_candidate && isMarker(_candidate)) {
      const first = _candidate;
      let last = first.nextSibling;
      for (; !isMarker(last); ) last = last.nextSibling;
      return new ConcreteBounds(this.element, first, last);
    }
    return null;
  }
  __appendText(string) {
    const {
      candidate
    } = this;
    return candidate ? 3 === candidate.nodeType ? (candidate.nodeValue !== string && (candidate.nodeValue = string), this.candidate = candidate.nextSibling, candidate) : 8 === (node = candidate).nodeType && "%|%" === node.nodeValue || isEmpty(candidate) && "" === string ? (this.candidate = this.remove(candidate), this.__appendText(string)) : (this.clearMismatch(candidate), super.__appendText(string)) : super.__appendText(string);
    var node;
  }
  __appendComment(string) {
    const _candidate = this.candidate;
    return _candidate && 8 === _candidate.nodeType ? (_candidate.nodeValue !== string && (_candidate.nodeValue = string), this.candidate = _candidate.nextSibling, _candidate) : (_candidate && this.clearMismatch(_candidate), super.__appendComment(string));
  }
  __openElement(tag) {
    const _candidate = this.candidate;
    if (_candidate && isElement(_candidate) && (function(candidate, tag2) {
      return candidate.namespaceURI === NS_SVG ? candidate.tagName === tag2 : candidate.tagName === tag2.toUpperCase();
    })(_candidate, tag)) return this.unmatchedAttributes = [].slice.call(_candidate.attributes), _candidate;
    if (_candidate) {
      if (isElement(_candidate) && "TBODY" === _candidate.tagName) return this.pushElement(_candidate, null), // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
      this.currentCursor.injectedOmittedNode = true, this.__openElement(tag);
      this.clearMismatch(_candidate);
    }
    return super.__openElement(tag);
  }
  __setAttribute(name, value, namespace) {
    const unmatched = this.unmatchedAttributes;
    if (unmatched) {
      const attr = findByName(unmatched, name);
      if (attr) return attr.value !== value && (attr.value = value), void unmatched.splice(unmatched.indexOf(attr), 1);
    }
    return super.__setAttribute(name, value, namespace);
  }
  __setProperty(name, value) {
    const unmatched = this.unmatchedAttributes;
    if (unmatched) {
      const attr = findByName(unmatched, name);
      if (attr) return attr.value !== value && (attr.value = value), void unmatched.splice(unmatched.indexOf(attr), 1);
    }
    return super.__setProperty(name, value);
  }
  __flushElement(parent, constructing) {
    const {
      unmatchedAttributes: unmatched
    } = this;
    if (unmatched) {
      for (const attr of unmatched)
        this.constructing.removeAttribute(attr.name);
      this.unmatchedAttributes = null;
    } else super.__flushElement(parent, constructing);
  }
  willCloseElement() {
    const {
      candidate,
      currentCursor
    } = this;
    null !== candidate && this.clearMismatch(candidate), currentCursor && currentCursor.injectedOmittedNode && this.popElement(), super.willCloseElement();
  }
  getMarker(element, guid) {
    const marker = element.querySelector(`script[glmr="${guid}"]`);
    return marker ? castToSimple(marker) : null;
  }
  __pushRemoteElement(element, cursorId, insertBefore) {
    const marker = this.getMarker(element, cursorId);
    if (!marker || marker.parentNode, void 0 === insertBefore) {
      for (; null !== element.firstChild && element.firstChild !== marker; ) this.remove(element.firstChild);
      insertBefore = null;
    }
    const cursor = new RehydratingCursor(element, null, this.blockDepth);
    this.cursors.push(cursor), null === marker ? this.disableRehydration(insertBefore) : this.candidate = this.remove(marker);
    const block = new RemoteBlock(element);
    return this.pushBlock(block, true);
  }
  didAppendBounds(bounds) {
    if (super.didAppendBounds(bounds), this.candidate) {
      const last = bounds.lastNode();
      this.candidate = last.nextSibling;
    }
    return bounds;
  }
};
function isOpenBlock(node) {
  return 8 === node.nodeType && 0 === node.nodeValue.lastIndexOf("%+b:", 0);
}
function isCloseBlock(node) {
  return 8 === node.nodeType && 0 === node.nodeValue.lastIndexOf("%-b:", 0);
}
function getBlockDepth(node) {
  return parseInt(node.nodeValue.slice(4), 10);
}
function getBlockDepthWithOffset(node, offset) {
  return getBlockDepth(node) - offset;
}
function isElement(node) {
  return 1 === node.nodeType;
}
function isMarker(node) {
  return 8 === node.nodeType && "%glmr%" === node.nodeValue;
}
function isEmpty(node) {
  return 8 === node.nodeType && "% %" === node.nodeValue;
}
function findByName(array2, name) {
  for (const attr of array2) if (attr.name === name) return attr;
}
function rehydrationBuilder(env, cursor) {
  return RehydrateTree.forInitialRender(env, cursor);
}

export {
  RuntimeOpImpl,
  artifacts,
  curry,
  ConcreteBounds,
  createCapturedArgs,
  reifyPositional,
  EMPTY_POSITIONAL,
  EMPTY_ARGS,
  TEMPLATE_ONLY_COMPONENT_MANAGER,
  templateOnlyComponent,
  normalizeProperty,
  runtimeOptions,
  inTransaction,
  array,
  concat,
  fn,
  get,
  hash,
  on,
  NewTreeBuilder,
  clientBuilder,
  renderMain,
  renderComponent,
  rehydrationBuilder
};
//# sourceMappingURL=chunk-2RJSWCLB.js.map
