{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/modifier/index.js", "../../../../../node_modules/.pnpm/ember-modifier@4.3.0_@babel+core@7.28.5/node_modules/ember-modifier/dist/index.js"],
  "sourcesContent": ["import { setModifierManager as setModifierManager$1 } from '../../@glimmer/manager/index.js';\nexport { modifierCapabilities as capabilities } from '../../@glimmer/manager/index.js';\nexport { on } from './on.js';\nimport '../../@glimmer/opcode-compiler/index.js';\nimport '../../shared-chunks/index-DaCZcoCY.js';\nimport '../../shared-chunks/registry-BJpQx6hv.js';\nimport '../debug/index.js';\nimport '../../@glimmer/runtime/index.js';\nimport '../runloop/index.js';\nimport '../../@glimmer/reference/index.js';\nimport '../../@glimmer/validator/index.js';\n// NOTE: this uses assignment to *require* that the `glimmerSetModifierManager`\n// is legally assignable to this type, i.e. that variance is properly upheld.\nconst setModifierManager = setModifierManager$1;\nexport { setModifierManager };", "import { setOwner } from '@ember/application';\nimport { capabilities, setModifierManager } from '@ember/modifier';\nimport { destroy } from '@ember/destroyable';\n\n/**\n * The state bucket used throughout the life-cycle of the modifier. Basically a\n * state *machine*, where the framework calls us with the version we hand back\n * to it at each phase. The two states are the two `extends` versions of this\n * below.\n *\n * @internal\n */\n\n/**\n * The `State` after calling `createModifier`, and therefore the state available\n * at the start of `InstallModifier`.\n * @internal\n */\n\n/**\n * The `State` after calling `installModifier`, and therefore the state\n * available in all `updateModifier` calls and in `destroyModifier`.\n * @internal\n */\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement$1(state, element) {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state;\n  installedState.element = element;\n  return installedState;\n}\nclass ClassBasedModifierManager {\n  capabilities = capabilities('3.22');\n  constructor(owner) {\n    this.owner = owner;\n  }\n  createModifier(modifierClass, args) {\n    const instance = new modifierClass(this.owner, args);\n    return {\n      instance,\n      element: null\n    };\n  }\n  installModifier(createdState, element, args) {\n    const state = installElement$1(createdState, element);\n    state.instance.modify(element, args.positional, args.named);\n  }\n  updateModifier(state, args) {\n    state.instance.modify(state.element, args.positional, args.named);\n  }\n  destroyModifier({\n    instance\n  }) {\n    destroy(instance);\n  }\n}\n\n// Preserve the signature on a class-based modifier, so it can be plucked off\n// later (by e.g. Glint), using interface merging with an opaque item to\n// preserve it in the type system. The fact that it's an empty interface is\n// actually the point: it *only* hooks the type parameter into the opaque\n// (nominal) type. Note that this is distinct from the function-based modifier\n// type intentionally, because it is actually the static class side of a\n// class-based modifier which corresponds to the result of calling `modifier()`\n// with a callback defining a function-based modifier.\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\n/**\n * A base class for modifiers which need more capabilities than function-based\n * modifiers. Useful if, for example:\n *\n * 1. You need to inject services and access them\n * 2. You need fine-grained control of updates, either for performance or\n *    convenience reasons, and don't want to teardown the state of your modifier\n *    every time only to set it up again.\n * 3. You need to store some local state within your modifier.\n *\n * The lifecycle hooks of class modifiers are tracked. When they run, they any\n * values they access will be added to the modifier, and the modifier will\n * update if any of those values change.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ClassBasedModifier {\n  // `args` is passed here for the sake of subclasses to have access to args in\n  // their constructors while having constructors which are properly asssignable\n  // for the superclass.\n  /**\n   *\n   * @param owner An instance of an Owner (for service injection etc.).\n   * @param args The positional and named arguments passed to the modifier.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(owner, args) {\n    setOwner(this, owner);\n  }\n\n  /**\n   * Called when the modifier is installed and any time any tracked state used\n   * in the modifier changes.\n   *\n   * If you need to do first-time-only setup, create a class field representing\n   * the initialization state and check it when running the hook. That is also\n   * where and when you should use `registerDestructor` for any teardown you\n   * need to do. For example:\n   *\n   * ```js\n   * function disconnect(instance) {\n   *  instance.observer?.disconnect();\n   * }\n   *\n   * class IntersectionObserver extends Modifier {\n   *   observer;\n   *\n   *   constructor(owner, args) {\n   *     super(owner, args);\n   *     registerDestructor(this, disconnect);\n   *   }\n   *\n   *   modify(element, callback, options) {\n   *     disconnect(this);\n   *\n   *     this.observer = new IntersectionObserver(callback, options);\n   *     this.observer.observe(element);\n   *   }\n   * }\n   * ```\n   *\n   * @param element The element to which the modifier is applied.\n   * @param positional The positional arguments to the modifier.\n   * @param named The named arguments to the modifier.\n   */\n  modify(/* eslint-disable @typescript-eslint/no-unused-vars */\n  element, positional, named\n  /* eslint-enable @typescript-eslint/no-unused-vars */) {\n    /* no op, for subclassing */\n  }\n}\nsetModifierManager(owner => new ClassBasedModifierManager(owner), ClassBasedModifier);\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement(state, element) {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state;\n  installedState.element = element;\n  return installedState;\n}\nclass FunctionBasedModifierManager {\n  capabilities = capabilities('3.22');\n  createModifier(instance) {\n    return {\n      element: null,\n      instance\n    };\n  }\n  installModifier(createdState, element, args) {\n    const state = installElement(createdState, element);\n    const {\n      positional,\n      named\n    } = args;\n    const teardown = createdState.instance(element, positional, named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n  updateModifier(state, args) {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n    const teardown = state.instance(state.element, args.positional, args.named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n  destroyModifier(state) {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n  }\n  getDebugName(state) {\n    return state.instance.toString();\n  }\n  getDebugInstance(state) {\n    return state;\n  }\n}\n\n// Provide a singleton manager.\nconst MANAGER = new FunctionBasedModifierManager();\n\n// This type exists to provide a non-user-constructible, non-subclassable\n// type representing the conceptual \"instance type\" of a function modifier.\n// The abstract field of type `never` prevents subclassing in userspace of\n// the value returned from `modifier()`. By extending `Modifier<S>`, any\n// augmentations of the `Modifier` type performed by tools like Glint will\n// also apply to function-based modifiers as well.\n\n// This provides a type whose only purpose here is to represent the runtime\n// type of a function-based modifier: a virtually opaque item. The fact that it's\n// a bare constructor type allows `modifier()` to preserve type parameters from\n// a generic function it's passed, and by making it abstract and impossible to\n// subclass (see above) we prevent users from attempting to instantiate the return\n// value from a `modifier()` call.\n\n/**\n * The (optional) return type for a modifier which needs to perform some kind of\n * cleanup or teardown -- for example, removing an event listener from an\n * element besides the one passed into the modifier.\n */\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to write types directly on the callback passed to\n// the `modifier` function and infer the resulting type correctly.\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to provide a `Signature` type explicitly at the\n// modifier definition site, e.g. `modifier<Sig>((el, pos, named) => {...})`.\n// **Note:** this overload must appear second, since TS' inference engine will\n// not correctly infer the type of `S` here from the types on the supplied\n// callback.\n\n// This is the runtime signature; it performs no inference whatsover and just\n// uses the simplest version of the invocation possible since, for the case of\n// setting it on the modifier manager, we don't *need* any of that info, and\n// the two previous overloads capture all invocations from a type perspective.\nfunction modifier(fn, options) {\n  fn.toString = () => options?.name || fn.name;\n  // SAFETY: the cast here is a *lie*, but it is a useful one. The actual return\n  // type of `setModifierManager` today is `void`; we pretend it actually\n  // returns an opaque `Modifier` type so that we can provide a result from this\n  // type which is useful to TS-aware tooling (e.g. Glint).\n  return setModifierManager(() => MANAGER, fn);\n}\n\n/**\n * @internal\n */\n\nexport { ClassBasedModifier as default, modifier };"],
  "mappings": ";;;;;;;;;;;;;;;;;AAaA,IAAMA,sBAAqB;;;ACc3B,SAAS,iBAAiB,OAAO,SAAS;AAOxC,QAAM,iBAAiB;AACvB,iBAAe,UAAU;AACzB,SAAO;AACT;AACA,IAAM,4BAAN,MAAgC;AAAA,EAC9B,eAAe,qBAAa,MAAM;AAAA,EAClC,YAAY,OAAO;AACjB,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,eAAe,eAAe,MAAM;AAClC,UAAM,WAAW,IAAI,cAAc,KAAK,OAAO,IAAI;AACnD,WAAO;AAAA,MACL;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF;AAAA,EACA,gBAAgB,cAAc,SAAS,MAAM;AAC3C,UAAM,QAAQ,iBAAiB,cAAc,OAAO;AACpD,UAAM,SAAS,OAAO,SAAS,KAAK,YAAY,KAAK,KAAK;AAAA,EAC5D;AAAA,EACA,eAAe,OAAO,MAAM;AAC1B,UAAM,SAAS,OAAO,MAAM,SAAS,KAAK,YAAY,KAAK,KAAK;AAAA,EAClE;AAAA,EACA,gBAAgB;AAAA,IACd;AAAA,EACF,GAAG;AACD,YAAQ,QAAQ;AAAA,EAClB;AACF;AA2BA,IAAM,qBAAN,MAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUvB,YAAY,OAAO,MAAM;AACvB,aAAS,MAAM,KAAK;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqCA,OACA,SAAS,YAAY,OACkC;AAAA,EAEvD;AACF;AACAC,oBAAmB,WAAS,IAAI,0BAA0B,KAAK,GAAG,kBAAkB;AAIpF,SAAS,eAAe,OAAO,SAAS;AAOtC,QAAM,iBAAiB;AACvB,iBAAe,UAAU;AACzB,SAAO;AACT;AACA,IAAM,+BAAN,MAAmC;AAAA,EACjC,eAAe,qBAAa,MAAM;AAAA,EAClC,eAAe,UAAU;AACvB,WAAO;AAAA,MACL,SAAS;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAAA,EACA,gBAAgB,cAAc,SAAS,MAAM;AAC3C,UAAM,QAAQ,eAAe,cAAc,OAAO;AAClD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,WAAW,aAAa,SAAS,SAAS,YAAY,KAAK;AACjE,QAAI,OAAO,aAAa,YAAY;AAClC,YAAM,WAAW;AAAA,IACnB;AAAA,EACF;AAAA,EACA,eAAe,OAAO,MAAM;AAC1B,QAAI,OAAO,MAAM,aAAa,YAAY;AACxC,YAAM,SAAS;AAAA,IACjB;AACA,UAAM,WAAW,MAAM,SAAS,MAAM,SAAS,KAAK,YAAY,KAAK,KAAK;AAC1E,QAAI,OAAO,aAAa,YAAY;AAClC,YAAM,WAAW;AAAA,IACnB;AAAA,EACF;AAAA,EACA,gBAAgB,OAAO;AACrB,QAAI,OAAO,MAAM,aAAa,YAAY;AACxC,YAAM,SAAS;AAAA,IACjB;AAAA,EACF;AAAA,EACA,aAAa,OAAO;AAClB,WAAO,MAAM,SAAS,SAAS;AAAA,EACjC;AAAA,EACA,iBAAiB,OAAO;AACtB,WAAO;AAAA,EACT;AACF;AAGA,IAAM,UAAU,IAAI,6BAA6B;AAyEjD,SAAS,SAAS,IAAI,SAAS;AAC7B,KAAG,WAAW,MAAM,SAAS,QAAQ,GAAG;AAKxC,SAAOA,oBAAmB,MAAM,SAAS,EAAE;AAC7C;",
  "names": ["setModifierManager", "setModifierManager"]
}
