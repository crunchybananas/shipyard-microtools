import {
  ActionHandler,
  CHAIN_PASS_THROUGH,
  Cache,
  ComputedDescriptor,
  ENV,
  EmberObject,
  EmberRouter,
  EngineInstance,
  Evented,
  FrameworkObject,
  Mixin,
  PROPERTY_DID_CHANGE,
  RSVP,
  TargetActionSupport,
  Version,
  _backburner,
  _getCurrentRunLoop,
  _getProp,
  _setProp,
  action,
  assert,
  computed,
  contentFor,
  debugFreeze,
  decorateFieldV2,
  decorateMethodV2,
  defineProperty,
  deprecate,
  descriptorForDecorator,
  descriptorForProperty,
  enumerableSymbol,
  expandProperties,
  extractRouteArgs,
  finishLazyChains,
  generateControllerFactory,
  get as get2,
  getChainTagsForKey,
  getDebugName$1,
  getEngineParent,
  getFactoryFor,
  getOwner,
  guidFor,
  hasDOM,
  initializeDeferredDecorator,
  inject,
  inspect,
  isArray,
  isElementDescriptor,
  isEmberArray,
  isFactory,
  isObject,
  isProxy,
  join,
  makeComputedDecorator,
  meta,
  nativeDescDecorator,
  objectAt,
  privatize,
  resemblesURL,
  schedule,
  set,
  setOwner,
  shallowEqual,
  tagForObject,
  tagForProperty,
  teardownMandatorySetter,
  tracked,
  warn
} from "./chunk-ED7J5GAS.js";
import {
  EMPTY_ARGS,
  EMPTY_POSITIONAL,
  RuntimeOpImpl,
  TEMPLATE_ONLY_COMPONENT_MANAGER,
  array,
  artifacts,
  clientBuilder,
  concat,
  createCapturedArgs,
  curry,
  fn,
  get,
  hash,
  inTransaction,
  normalizeProperty,
  on,
  reifyPositional,
  renderComponent,
  renderMain,
  runtimeOptions,
  templateOnlyComponent
} from "./chunk-2RJSWCLB.js";
import {
  EvaluationContextImpl,
  templateFactory
} from "./chunk-MHMOQE3O.js";
import {
  CONSTANT_TAG,
  CURRENT_TAG,
  DIRTY_TAG,
  EMPTY_ARRAY,
  UNDEFINED_REFERENCE,
  UPDATE_TAG,
  associateDestroyableChild,
  beginTrackFrame,
  beginUntrackFrame,
  capabilityFlagsFrom,
  childRefFor,
  childRefFromParts,
  consumeTag,
  createCache,
  createComputeRef,
  createConstRef,
  createDebugAliasRef,
  createInvokableRef,
  createPrimitiveRef,
  createReadOnlyRef,
  createTag,
  createUnboundRef,
  debug,
  destroy,
  dict,
  endTrackFrame,
  endUntrackFrame,
  getComponentTemplate,
  getInternalComponentManager,
  getInternalHelperManager,
  getValue,
  hasInternalComponentManager,
  helperCapabilities,
  isConstRef,
  isDestroyed,
  isDestroying,
  isTracking,
  isUpdatableRef,
  registerDestructor,
  setComponentTemplate,
  setGlobalContext,
  setHelperManager,
  setInternalComponentManager,
  setInternalHelperManager,
  tagFor,
  tagMetaFor,
  untrack,
  updateRef,
  validateTag,
  valueForRef,
  valueForTag
} from "./chunk-HJOPXKLZ.js";
import {
  __privateAdd,
  __publicField
} from "./chunk-JXSOYYVP.js";

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/instrumentation/index.js
var subscribers = [];
var cache = {};
function populateListeners(name) {
  let listeners = [];
  for (let subscriber of subscribers) {
    if (subscriber.regex.test(name)) {
      listeners.push(subscriber.object);
    }
  }
  cache[name] = listeners;
  return listeners;
}
var time = (() => {
  let perf = "undefined" !== typeof window ? window.performance || {} : {};
  let fn2 = perf.now || perf.mozNow || perf.webkitNow || perf.msNow || perf.oNow;
  return fn2 ? fn2.bind(perf) : Date.now;
})();
function flaggedInstrument(_name, _payload, callback) {
  return callback();
}
function NOOP() {
}
function _instrumentStart(name, payloadFunc, payloadArg) {
  if (subscribers.length === 0) {
    return NOOP;
  }
  let listeners = cache[name];
  if (!listeners) {
    listeners = populateListeners(name);
  }
  if (listeners.length === 0) {
    return NOOP;
  }
  let payload = payloadFunc(payloadArg);
  let STRUCTURED_PROFILE = ENV.STRUCTURED_PROFILE;
  let timeName;
  if (STRUCTURED_PROFILE) {
    timeName = `${name}: ${payload.object}`;
    console.time(timeName);
  }
  let beforeValues = [];
  let timestamp = time();
  for (let listener of listeners) {
    beforeValues.push(listener.before(name, timestamp, payload));
  }
  const constListeners = listeners;
  return function _instrumentEnd() {
    let timestamp2 = time();
    for (let i = 0; i < constListeners.length; i++) {
      let listener = constListeners[i];
      !listener && assert("has listener", listener);
      if (typeof listener.after === "function") {
        listener.after(name, timestamp2, payload, beforeValues[i]);
      }
    }
    if (STRUCTURED_PROFILE) {
      console.timeEnd(timeName);
    }
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/views/states.js
var DEFAULT = Object.freeze({
  // appendChild is only legal while rendering the buffer.
  appendChild() {
    throw new Error("You can't use appendChild outside of the rendering process");
  },
  // Handle events from `Ember.EventDispatcher`
  handleEvent() {
    return true;
  },
  rerender() {
  },
  destroy() {
  }
});
var PRE_RENDER = Object.freeze({
  ...DEFAULT
});
var HAS_ELEMENT = Object.freeze({
  ...DEFAULT,
  rerender(view) {
    view.renderer.rerender();
  },
  destroy(view) {
    view.renderer.remove(view);
  },
  // Handle events from `Ember.EventDispatcher`
  handleEvent(view, eventName, event) {
    if (view.has(eventName)) {
      return flaggedInstrument(`interaction.${eventName}`, {}, () => {
        return join(view, view.trigger, eventName, event);
      });
    } else {
      return true;
    }
  }
});
var IN_DOM = Object.freeze({
  ...HAS_ELEMENT,
  enter(view) {
    view.renderer.register(view);
    if (true) {
      let elementId = view.elementId;
      !teardownMandatorySetter && assert("[BUG] Expected teardownMandatorySetter to be set in DEBUG mode", teardownMandatorySetter);
      teardownMandatorySetter(view, "elementId");
      Object.defineProperty(view, "elementId", {
        configurable: true,
        enumerable: true,
        get() {
          return elementId;
        },
        set(value) {
          if (value !== elementId) {
            throw new Error("Changing a view's elementId after creation is not allowed");
          }
        }
      });
    }
  }
});
var DESTROYING = Object.freeze({
  ...DEFAULT,
  appendChild() {
    throw new Error("You can't call appendChild on a view being destroyed");
  },
  rerender() {
    throw new Error("You can't call rerender on a view being destroyed");
  }
});
var states = Object.freeze({
  preRender: PRE_RENDER,
  inDOM: IN_DOM,
  hasElement: HAS_ELEMENT,
  destroying: DESTROYING
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/views/core_view.js
var _renderer;
var _CoreView = class _CoreView extends FrameworkObject.extend(Evented, ActionHandler) {
  constructor() {
    super(...arguments);
    __publicField(this, "isView", true);
    __publicField(this, "_superTrigger");
    __publicField(this, "_superHas");
    __privateAdd(this, _renderer, (initializeDeferredDecorator(this, "renderer"), void 0));
  }
  /**
    If the view is currently inserted into the DOM of a parent view, this
    property will point to the parent of the view.
     @property parentView
    @type Ember.View
    @default null
    @private
  */
  init(properties) {
    super.init(properties);
    this._superTrigger = this.trigger;
    this.trigger = this._trigger;
    this._superHas = this.has;
    this.has = this._has;
    this.parentView ??= null;
    this._state = "preRender";
    this._currentState = this._states.preRender;
  }
  instrumentDetails(hash2) {
    hash2["object"] = this.toString();
    hash2["containerKey"] = this._debugContainerKey;
    hash2["view"] = this;
    return hash2;
  }
  /**
    Override the default event firing from `Evented` to
    also call methods with the given name.
     @method trigger
    @param name {String}
    @private
  */
  // Changed to `trigger` on init
  _trigger(name, ...args) {
    this._superTrigger(name, ...args);
    let method = this[name];
    if (typeof method === "function") {
      return method.apply(this, args);
    }
  }
  // Changed to `has` on init
  _has(name) {
    return typeof this[name] === "function" || this._superHas(name);
  }
};
_renderer = new WeakMap();
decorateFieldV2(_CoreView.prototype, "renderer", [inject("renderer", "-dom")]);
__publicField(_CoreView, "isViewFactory", true);
var CoreView = _CoreView;
CoreView.prototype._states = states;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/mixins/action_support.js
var ActionSupport = Mixin.create({
  send(actionName, ...args) {
    !(!this.isDestroying && !this.isDestroyed) && assert(`Attempted to call .send() with the action '${actionName}' on the destroyed object '${this}'.`, !this.isDestroying && !this.isDestroyed);
    let action2 = this.actions && this.actions[actionName];
    if (action2) {
      let shouldBubble = action2.apply(this, args) === true;
      if (!shouldBubble) {
        return;
      }
    }
    let target = get2(this, "target");
    if (target) {
      !(typeof target.send === "function") && assert(`The \`target\` for ${this} (${target}) does not have a \`send\` method`, typeof target.send === "function");
      target.send(...arguments);
    } else {
      !action2 && assert(`${inspect(this)} had no action handler for: ${actionName}`, action2);
    }
  }
});

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/system/utils.js
function isSimpleClick(event) {
  if (!(event instanceof MouseEvent)) {
    return false;
  }
  let modifier = event.shiftKey || event.metaKey || event.altKey || event.ctrlKey;
  let secondaryClick = event.which > 1;
  return !modifier && !secondaryClick;
}
function constructStyleDeprecationMessage(affectedStyle) {
  return 'Binding style attributes may introduce cross-site scripting vulnerabilities; please ensure that values being bound are properly escaped. For more information, including how to disable this warning, see https://deprecations.emberjs.com/v1.x/#toc_binding-style-attributes. Style affected: "' + affectedStyle + '"';
}
function getViewId(view) {
  if (view.tagName !== "" && view.elementId) {
    return view.elementId;
  } else {
    return guidFor(view);
  }
}
var ELEMENT_VIEW = /* @__PURE__ */ new WeakMap();
var VIEW_ELEMENT = /* @__PURE__ */ new WeakMap();
function getElementView(element) {
  return ELEMENT_VIEW.get(element) || null;
}
function getViewElement(view) {
  return VIEW_ELEMENT.get(view) || null;
}
function setElementView(element, view) {
  ELEMENT_VIEW.set(element, view);
}
function setViewElement(view, element) {
  VIEW_ELEMENT.set(view, element);
}
function clearElementView(element) {
  ELEMENT_VIEW.delete(element);
}
function clearViewElement(view) {
  VIEW_ELEMENT.delete(view);
}
var CHILD_VIEW_IDS = /* @__PURE__ */ new WeakMap();
function getChildViews(view) {
  let owner = getOwner(view);
  !owner && assert("View is unexpectedly missing an owner", owner);
  let registry = owner.lookup("-view-registry:main");
  return collectChildViews(view, registry);
}
function initChildViews(view) {
  let childViews = /* @__PURE__ */ new Set();
  CHILD_VIEW_IDS.set(view, childViews);
  return childViews;
}
function addChildView(parent, child) {
  let childViews = CHILD_VIEW_IDS.get(parent);
  if (childViews === void 0) {
    childViews = initChildViews(parent);
  }
  childViews.add(getViewId(child));
}
function collectChildViews(view, registry) {
  let views = [];
  let childViews = CHILD_VIEW_IDS.get(view);
  if (childViews !== void 0) {
    childViews.forEach((id) => {
      let view2 = registry[id];
      if (view2 && !view2.isDestroying && !view2.isDestroyed) {
        views.push(view2);
      }
    });
  }
  return views;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/system/event_dispatcher.js
var ROOT_ELEMENT_CLASS = "ember-application";
var ROOT_ELEMENT_SELECTOR = `.${ROOT_ELEMENT_CLASS}`;
var EventDispatcher = class extends EmberObject {
  /**
    The set of events names (and associated handler function names) to be setup
    and dispatched by the `EventDispatcher`. Modifications to this list can be done
    at setup time, generally via the `Application.customEvents` hash.
     To add new events to be listened to:
     ```javascript
    import Application from '@ember/application';
     let App = Application.create({
      customEvents: {
        paste: 'paste'
      }
    });
    ```
     To prevent default events from being listened to:
     ```javascript
    import Application from '@ember/application';
     let App = Application.create({
      customEvents: {
        mouseenter: null,
        mouseleave: null
      }
    });
    ```
    @property events
    @type Object
    @private
  */
  events = {
    touchstart: "touchStart",
    touchmove: "touchMove",
    touchend: "touchEnd",
    touchcancel: "touchCancel",
    keydown: "keyDown",
    keyup: "keyUp",
    keypress: "keyPress",
    mousedown: "mouseDown",
    mouseup: "mouseUp",
    contextmenu: "contextMenu",
    click: "click",
    dblclick: "doubleClick",
    focusin: "focusIn",
    focusout: "focusOut",
    submit: "submit",
    input: "input",
    change: "change",
    dragstart: "dragStart",
    drag: "drag",
    dragenter: "dragEnter",
    dragleave: "dragLeave",
    dragover: "dragOver",
    drop: "drop",
    dragend: "dragEnd"
  };
  /**
    The root DOM element to which event listeners should be attached. Event
    listeners will be attached to the document unless this is overridden.
     Can be specified as a DOMElement or a selector string.
     The default body is a string since this may be evaluated before document.body
    exists in the DOM.
     @private
    @property rootElement
    @type DOMElement
    @default 'body'
  */
  rootElement = "body";
  _eventHandlers = /* @__PURE__ */ Object.create(null);
  _didSetup = false;
  finalEventNameMapping = null;
  _sanitizedRootElement = null;
  lazyEvents = /* @__PURE__ */ new Map();
  _reverseEventNameMapping = null;
  /**
    Sets up event listeners for standard browser events.
     This will be called after the browser sends a `DOMContentReady` event. By
    default, it will set up all of the listeners on the document body. If you
    would like to register the listeners on a different element, set the event
    dispatcher's `root` property.
     @private
    @method setup
    @param addedEvents {Object}
  */
  setup(addedEvents, _rootElement) {
    !(() => {
      let owner = getOwner(this);
      !owner && assert("[BUG] Missing owner", owner);
      let environment = owner.lookup("-environment:main");
      return environment.isInteractive;
    })() && assert("EventDispatcher should never be setup in fastboot mode. Please report this as an Ember bug.", (() => {
      let owner = getOwner(this);
      !owner && assert("[BUG] Missing owner", owner);
      let environment = owner.lookup("-environment:main");
      return environment.isInteractive;
    })());
    let events = this.finalEventNameMapping = {
      ...get2(this, "events"),
      ...addedEvents
    };
    this._reverseEventNameMapping = Object.keys(events).reduce((result, key) => {
      let eventName = events[key];
      return eventName ? {
        ...result,
        [eventName]: key
      } : result;
    }, {});
    let lazyEvents = this.lazyEvents;
    if (_rootElement !== void 0 && _rootElement !== null) {
      set(this, "rootElement", _rootElement);
    }
    let specifiedRootElement = get2(this, "rootElement");
    let rootElement = typeof specifiedRootElement !== "string" ? specifiedRootElement : document.querySelector(specifiedRootElement);
    !rootElement && assert(`Could not find rootElement (${specifiedRootElement})`, rootElement);
    !!rootElement.classList.contains(ROOT_ELEMENT_CLASS) && assert(`You cannot use the same root element (${specifiedRootElement}) multiple times in an Ember.Application`, !rootElement.classList.contains(ROOT_ELEMENT_CLASS));
    !(() => {
      let target = rootElement.parentNode;
      while (target instanceof Element) {
        if (target.classList.contains(ROOT_ELEMENT_CLASS)) {
          return false;
        }
        target = target.parentNode;
      }
      return true;
    })() && assert("You cannot make a new Ember.Application using a root element that is a descendent of an existing Ember.Application", (() => {
      let target = rootElement.parentNode;
      while (target instanceof Element) {
        if (target.classList.contains(ROOT_ELEMENT_CLASS)) {
          return false;
        }
        target = target.parentNode;
      }
      return true;
    })());
    !!rootElement.querySelector(ROOT_ELEMENT_SELECTOR) && assert("You cannot make a new Ember.Application using a root element that is an ancestor of an existing Ember.Application", !rootElement.querySelector(ROOT_ELEMENT_SELECTOR));
    rootElement.classList.add(ROOT_ELEMENT_CLASS);
    !rootElement.classList.contains(ROOT_ELEMENT_CLASS) && assert(`Unable to add '${ROOT_ELEMENT_CLASS}' class to root element (${get2(this, "rootElement") || rootElement.tagName}). Make sure you set rootElement to the body or an element in the body.`, rootElement.classList.contains(ROOT_ELEMENT_CLASS));
    this._sanitizedRootElement = rootElement;
    for (let event in events) {
      if (Object.prototype.hasOwnProperty.call(events, event)) {
        lazyEvents.set(event, events[event] ?? null);
      }
    }
    this._didSetup = true;
  }
  /**
    Setup event listeners for the given browser event name
     @private
    @method setupHandlerForBrowserEvent
    @param event the name of the event in the browser
  */
  setupHandlerForBrowserEvent(event) {
    !this.finalEventNameMapping && assert("[BUG] Expected finalEventNameMapping to be set", this.finalEventNameMapping);
    !this._sanitizedRootElement && assert("[BUG] Expected _santizedRootElement to be set", this._sanitizedRootElement);
    this.setupHandler(this._sanitizedRootElement, event, this.finalEventNameMapping[event] ?? null);
  }
  /**
    Setup event listeners for the given Ember event name (camel case)
     @private
    @method setupHandlerForEmberEvent
    @param eventName
  */
  setupHandlerForEmberEvent(eventName) {
    !this._sanitizedRootElement && assert("[BUG] Expected _sanitizedRootElement to be set", this._sanitizedRootElement);
    let event = this._reverseEventNameMapping?.[eventName];
    if (event) {
      this.setupHandler(this._sanitizedRootElement, event, eventName);
    }
  }
  /**
    Registers an event listener on the rootElement. If the given event is
    triggered, the provided event handler will be triggered on the target view.
     If the target view does not implement the event handler, or if the handler
    returns `false`, the parent view will be called. The event will continue to
    bubble to each successive parent view until it reaches the top.
     @private
    @method setupHandler
    @param {Element} rootElement
    @param {String} event the name of the event in the browser
    @param {String} eventName the name of the method to call on the view
  */
  setupHandler(rootElement, event, eventName) {
    if (eventName === null || !this.lazyEvents.has(event)) {
      return;
    }
    let viewHandler = (target, event2) => {
      let view = getElementView(target);
      let result = true;
      if (view) {
        result = view.handleEvent(eventName, event2);
      }
      return result;
    };
    let handleEvent = this._eventHandlers[event] = (event2) => {
      let target = event2.target;
      !(target instanceof Element) && assert(`[BUG] Received event without an Element target: ${event2.type}, ${target}`, target instanceof Element);
      do {
        if (getElementView(target)) {
          if (viewHandler(target, event2) === false) {
            event2.preventDefault();
            event2.stopPropagation();
            break;
          } else if (event2.cancelBubble === true) {
            break;
          }
        }
        target = target.parentNode;
      } while (target instanceof Element);
    };
    rootElement.addEventListener(event, handleEvent);
    this.lazyEvents.delete(event);
  }
  destroy() {
    if (this._didSetup === false) {
      return;
    }
    let rootElement = this._sanitizedRootElement;
    if (!rootElement) {
      return;
    }
    for (let event in this._eventHandlers) {
      rootElement.removeEventListener(event, this._eventHandlers[event]);
    }
    rootElement.classList.remove(ROOT_ELEMENT_CLASS);
    return this._super(...arguments);
  }
  toString() {
    return "(EventDispatcher)";
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/alias-CPqbuwcg.js
function alias(altKey) {
  !!isElementDescriptor(Array.prototype.slice.call(arguments)) && assert("You attempted to use @alias as a decorator directly, but it requires a `altKey` parameter", !isElementDescriptor(Array.prototype.slice.call(arguments)));
  return makeComputedDecorator(new AliasedProperty(altKey), AliasDecoratorImpl);
}
var AliasDecoratorImpl = class extends Function {
  readOnly() {
    descriptorForDecorator(this).readOnly();
    return this;
  }
  oneWay() {
    descriptorForDecorator(this).oneWay();
    return this;
  }
  meta(meta2) {
    let prop = descriptorForDecorator(this);
    if (arguments.length === 0) {
      return prop._meta || {};
    } else {
      prop._meta = meta2;
    }
  }
};
var AliasedProperty = class extends ComputedDescriptor {
  altKey;
  constructor(altKey) {
    super();
    this.altKey = altKey;
  }
  setup(obj, keyName, propertyDesc, meta2) {
    !(this.altKey !== keyName) && assert(`Setting alias '${keyName}' on self`, this.altKey !== keyName);
    super.setup(obj, keyName, propertyDesc, meta2);
    CHAIN_PASS_THROUGH.add(this);
  }
  get(obj, keyName) {
    let ret;
    let meta$1 = meta(obj);
    let tagMeta = tagMetaFor(obj);
    let propertyTag = tagFor(obj, keyName, tagMeta);
    untrack(() => {
      ret = get2(obj, this.altKey);
    });
    let lastRevision = meta$1.revisionFor(keyName);
    if (lastRevision === void 0 || !validateTag(propertyTag, lastRevision)) {
      UPDATE_TAG(propertyTag, getChainTagsForKey(obj, this.altKey, tagMeta, meta$1));
      meta$1.setRevisionFor(keyName, valueForTag(propertyTag));
      finishLazyChains(meta$1, keyName, ret);
    }
    consumeTag(propertyTag);
    return ret;
  }
  set(obj, _keyName, value) {
    return set(obj, this.altKey, value);
  }
  readOnly() {
    this.set = AliasedProperty_readOnlySet;
  }
  oneWay() {
    this.set = AliasedProperty_oneWaySet;
  }
};
function AliasedProperty_readOnlySet(obj, keyName) {
  throw new Error(`Cannot set read-only property '${keyName}' on object: ${inspect(obj)}`);
}
function AliasedProperty_oneWaySet(obj, keyName, value) {
  defineProperty(obj, keyName, null);
  return set(obj, keyName, value);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/object/lib/computed/computed_macros.js
function expandPropertiesToArray(predicateName, properties) {
  let expandedProperties = [];
  function extractProperty(entry) {
    expandedProperties.push(entry);
  }
  for (let property of properties) {
    !(property.indexOf(" ") < 0) && assert(`Dependent keys passed to \`${predicateName}\` computed macro can't have spaces.`, property.indexOf(" ") < 0);
    expandProperties(property, extractProperty);
  }
  return expandedProperties;
}
function generateComputedWithPredicate(name, predicate) {
  return (dependentKey, ...additionalDependentKeys) => {
    let properties = [dependentKey, ...additionalDependentKeys];
    !!isElementDescriptor(properties) && assert(`You attempted to use @${name} as a decorator directly, but it requires at least one dependent key parameter`, !isElementDescriptor(properties));
    let dependentKeys = expandPropertiesToArray(name, properties);
    let computedFunc = computed(...dependentKeys, function() {
      let lastIdx = dependentKeys.length - 1;
      for (let i = 0; i < lastIdx; i++) {
        let value = get2(this, dependentKeys[i]);
        if (!predicate(value)) {
          return value;
        }
      }
      return get2(this, dependentKeys[lastIdx]);
    });
    return computedFunc;
  };
}
var and = generateComputedWithPredicate("and", (value) => value);
var or = generateComputedWithPredicate("or", (value) => !value);
function readOnly(dependentKey) {
  !!isElementDescriptor(Array.prototype.slice.call(arguments)) && assert("You attempted to use @readOnly as a decorator directly, but it requires a `dependentKey` parameter", !isElementDescriptor(Array.prototype.slice.call(arguments)));
  return alias(dependentKey).readOnly();
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/string/index.js
var STRING_DASHERIZE_REGEXP = /[ _]/g;
var STRING_DASHERIZE_CACHE = new Cache(1e3, (key) => decamelize(key).replace(STRING_DASHERIZE_REGEXP, "-"));
var STRING_CLASSIFY_REGEXP_1 = /^(-|_)+(.)?/;
var STRING_CLASSIFY_REGEXP_2 = /(.)(-|_|\.|\s)+(.)?/g;
var STRING_CLASSIFY_REGEXP_3 = /(^|\/|\.)([a-z])/g;
var CLASSIFY_CACHE = new Cache(1e3, (str) => {
  let replace1 = (_match, _separator, chr) => chr ? `_${chr.toUpperCase()}` : "";
  let replace2 = (_match, initialChar, _separator, chr) => initialChar + (chr ? chr.toUpperCase() : "");
  let parts = str.split("/");
  for (let i = 0; i < parts.length; i++) {
    parts[i] = parts[i].replace(STRING_CLASSIFY_REGEXP_1, replace1).replace(STRING_CLASSIFY_REGEXP_2, replace2);
  }
  return parts.join("/").replace(STRING_CLASSIFY_REGEXP_3, (match) => match.toUpperCase());
});
var STRING_DECAMELIZE_REGEXP = /([a-z\d])([A-Z])/g;
var DECAMELIZE_CACHE = new Cache(1e3, (str) => str.replace(STRING_DECAMELIZE_REGEXP, "$1_$2").toLowerCase());
function dasherize(str) {
  return STRING_DASHERIZE_CACHE.get(str);
}
function classify(str) {
  return CLASSIFY_CACHE.get(str);
}
function decamelize(str) {
  return DECAMELIZE_CACHE.get(str);
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/deprecations/index.js
function isEnabled(options) {
  return Object.hasOwnProperty.call(options.since, "enabled") || ENV._ALL_DEPRECATIONS_ENABLED;
}
var numEmberVersion = parseFloat(ENV._OVERRIDE_DEPRECATION_VERSION ?? Version);
function emberVersionGte(until, emberVersion = numEmberVersion) {
  let significantUntil = until.replace(/(\.0+)/g, "");
  return emberVersion >= parseFloat(significantUntil);
}
function isRemoved(options) {
  return emberVersionGte(options.until);
}
function deprecation(options) {
  return {
    options,
    test: !isEnabled(options),
    isEnabled: isEnabled(options) || isRemoved(options),
    isRemoved: isRemoved(options)
  };
}
var DEPRECATIONS = {
  DEPRECATE_IMPORT_EMBER(importName) {
    return deprecation({
      id: `deprecate-import-${dasherize(importName).toLowerCase()}-from-ember`,
      for: "ember-source",
      since: {
        available: "5.10.0",
        enabled: "6.5.0"
      },
      until: "7.0.0",
      url: `https://deprecations.emberjs.com/id/import-${dasherize(importName).toLowerCase()}-from-ember`
    });
  },
  DEPRECATE_IMPORT_INJECT: deprecation({
    for: "ember-source",
    id: "importing-inject-from-ember-service",
    since: {
      available: "6.2.0",
      enabled: "6.3.0"
    },
    until: "7.0.0",
    url: "https://deprecations.emberjs.com/id/importing-inject-from-ember-service"
  }),
  DEPRECATE_AMD_BUNDLES: deprecation({
    for: "ember-source",
    id: "using-amd-bundles",
    since: {
      available: "6.10.0",
      enabled: "6.10.0"
    },
    until: "7.0.0",
    url: "https://deprecations.emberjs.com/id/using-amd-bundles"
  })
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/service/index.js
function service(...args) {
  return inject("service", ...args);
}
var Service = class extends FrameworkObject {
  static isServiceFactory = true;
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/router-service.js
var ROUTER = Symbol("ROUTER");
function cleanURL(url, rootURL) {
  if (rootURL === "/") {
    return url;
  }
  return url.substring(rootURL.length);
}
var _a, _b, _currentRouteName, _currentURL, _location, _rootURL, _currentRoute;
var _RouterService = class _RouterService extends (_b = Service.extend(Evented), _a = ROUTER, _b) {
  constructor() {
    super(...arguments);
    __publicField(this, _a);
    __privateAdd(this, _currentRouteName, (initializeDeferredDecorator(this, "currentRouteName"), void 0));
    __privateAdd(this, _currentURL, (initializeDeferredDecorator(this, "currentURL"), void 0));
    __privateAdd(this, _location, (initializeDeferredDecorator(this, "location"), void 0));
    __privateAdd(this, _rootURL, (initializeDeferredDecorator(this, "rootURL"), void 0));
    __privateAdd(this, _currentRoute, (initializeDeferredDecorator(this, "currentRoute"), void 0));
  }
  get _router() {
    let router = this[ROUTER];
    if (router !== void 0) {
      return router;
    }
    let owner = getOwner(this);
    !owner && assert("RouterService is unexpectedly missing an owner", owner);
    let _router = owner.lookup("router:main");
    !(_router instanceof EmberRouter) && assert("ROUTER SERVICE BUG: Expected router to be an instance of EmberRouter", _router instanceof EmberRouter);
    return this[ROUTER] = _router;
  }
  willDestroy() {
    super.willDestroy();
    this[ROUTER] = void 0;
  }
  /**
     Transition the application into another route. The route may
     be either a single route or route path:
      Calling `transitionTo` from the Router service will cause default query parameter values to be included in the URL.
     This behavior is different from calling `transitionTo` on a route or `transitionToRoute` on a controller.
     See the [Router Service RFC](https://github.com/emberjs/rfcs/blob/master/text/0095-router-service.md#query-parameter-semantics) for more info.
      In the following example we use the Router service to navigate to a route with a
     specific model from a Component in the first action, and in the second we trigger
     a query-params only transition.
      ```app/components/example.js
     import Component from '@glimmer/component';
     import { action } from '@ember/object';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        @action
       goToComments(post) {
         this.router.transitionTo('comments', post);
       }
        @action
       fetchMoreComments(latestComment) {
         this.router.transitionTo({
           queryParams: { commentsAfter: latestComment }
         });
       }
     }
     ```
      @method transitionTo
     @param {String} [routeNameOrUrl] the name of the route or a URL
     @param {...Object} [models] the model(s) or identifier(s) to be used while
       transitioning to the route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters. May be supplied as the only
      parameter to trigger a query-parameter-only transition.
     @return {Transition} the transition object associated with this
       attempted transition
     @public
   */
  transitionTo(...args) {
    if (resemblesURL(args[0])) {
      return this._router._doURLTransition("transitionTo", args[0]);
    }
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    let transition = this._router._doTransition(routeName, models, queryParams, true);
    return transition;
  }
  /**
     Similar to `transitionTo`, but instead of adding the destination to the browser's URL history,
     it replaces the entry for the current route.
     When the user clicks the "back" button in the browser, there will be fewer steps.
     This is most commonly used to manage redirects in a way that does not cause confusing additions
     to the user's browsing history.
      Calling `replaceWith` from the Router service will cause default query parameter values to be included in the URL.
     This behavior is different from calling `replaceWith` on a route.
     See the [Router Service RFC](https://github.com/emberjs/rfcs/blob/master/text/0095-router-service.md#query-parameter-semantics) for more info.
      Usage example:
      ```app/routes/application.js
     import Route from '@ember/routing/route';
     import { service } from '@ember/service';
      export default class extends Route {
       @service router;
       beforeModel() {
         if (!authorized()){
           this.router.replaceWith('unauthorized');
         }
       }
     });
     ```
      @method replaceWith
     @param {String} routeNameOrUrl the name of the route or a URL of the desired destination
     @param {...Object} models the model(s) or identifier(s) to be used while
       transitioning to the route i.e. an object of params to pass to the destination route
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {Transition} the transition object associated with this
       attempted transition
     @public
   */
  replaceWith(...args) {
    return this.transitionTo(...args).method("replace");
  }
  /**
    Generate a URL based on the supplied route name and optionally a model. The
    URL is returned as a string that can be used for any purpose.
     In this example, the URL for the `author.books` route for a given author
    is copied to the clipboard.
     ```app/templates/application.hbs
    <CopyLink @author={{hash id="tomster" name="Tomster"}} />
    ```
     ```app/components/copy-link.js
    import Component from '@glimmer/component';
    import { service } from '@ember/service';
    import { action } from '@ember/object';
     export default class CopyLinkComponent extends Component {
      @service router;
      @service clipboard;
       @action
      copyBooksURL() {
        if (this.author) {
          const url = this.router.urlFor('author.books', this.args.author);
          this.clipboard.set(url);
          // Clipboard now has /author/tomster/books
        }
      }
    }
    ```
     Just like with `transitionTo` and `replaceWith`, `urlFor` can also handle
    query parameters.
     ```app/templates/application.hbs
    <CopyLink @author={{hash id="tomster" name="Tomster"}} />
    ```
     ```app/components/copy-link.js
    import Component from '@glimmer/component';
    import { service } from '@ember/service';
    import { action } from '@ember/object';
     export default class CopyLinkComponent extends Component {
      @service router;
      @service clipboard;
       @action
      copyOnlyEmberBooksURL() {
        if (this.author) {
          const url = this.router.urlFor('author.books', this.author, {
            queryParams: { filter: 'emberjs' }
          });
          this.clipboard.set(url);
          // Clipboard now has /author/tomster/books?filter=emberjs
        }
      }
    }
    ```
      @method urlFor
     @param {String} routeName the name of the route
     @param {...Object} models the model(s) for the route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {String} the string representing the generated URL
     @public
   */
  urlFor(routeName, ...args) {
    this._router.setupRouter();
    return this._router.generate(routeName, ...args);
  }
  /**
     Returns `true` if `routeName/models/queryParams` is the active route, where `models` and `queryParams` are optional.
     See [model](api/ember/release/classes/Route/methods/model?anchor=model) and
     [queryParams](/api/ember/3.7/classes/Route/properties/queryParams?anchor=queryParams) for more information about these arguments.
      In the following example, `isActive` will return `true` if the current route is `/posts`.
      ```app/components/posts.js
     import Component from '@glimmer/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        displayComments() {
         return this.router.isActive('posts');
       }
     });
     ```
      The next example includes a dynamic segment, and will return `true` if the current route is `/posts/1`,
     assuming the post has an id of 1:
      ```app/components/posts.js
     import Component from '@glimmer/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
        displayComments(post) {
         return this.router.isActive('posts', post.id);
       }
     });
     ```
      Where `post.id` is the id of a specific post, which is represented in the route as /posts/[post.id].
     If `post.id` is equal to 1, then isActive will return true if the current route is /posts/1, and false if the route is anything else.
      @method isActive
     @param {String} routeName the name of the route
     @param {...Object} models the model(s) or identifier(s) to be used when determining the active route.
     @param {Object} [options] optional hash with a queryParams property
       containing a mapping of query parameters
     @return {boolean} true if the provided routeName/models/queryParams are active
     @public
   */
  isActive(...args) {
    let {
      routeName,
      models,
      queryParams
    } = extractRouteArgs(args);
    this._router.setupRouter();
    let routerMicrolib = this._router._routerMicrolib;
    consumeTag(tagFor(this._router, "currentURL"));
    if (!routerMicrolib.isActiveIntent(routeName, models)) {
      return false;
    }
    let hasQueryParams = Object.keys(queryParams).length > 0;
    if (hasQueryParams) {
      let targetRouteName = routeName;
      queryParams = Object.assign({}, queryParams);
      this._router._prepareQueryParams(
        targetRouteName,
        models,
        queryParams,
        true
        /* fromRouterService */
      );
      let currentQueryParams = Object.assign({}, routerMicrolib.state.queryParams);
      this._router._prepareQueryParams(
        targetRouteName,
        models,
        currentQueryParams,
        true
        /* fromRouterService */
      );
      return shallowEqual(queryParams, currentQueryParams);
    }
    return true;
  }
  /**
     Takes a string URL and returns a `RouteInfo` for the leafmost route represented
     by the URL. Returns `null` if the URL is not recognized. This method expects to
     receive the actual URL as seen by the browser including the app's `rootURL`.
      See [RouteInfo](/ember/release/classes/RouteInfo) for more info.
      In the following example `recognize` is used to verify if a path belongs to our
     application before transitioning to it.
      ```
     import Component from '@ember/component';
     import { service } from '@ember/service';
      export default class extends Component {
       @service router;
       path = '/';
        click() {
         if (this.router.recognize(this.path)) {
           this.router.transitionTo(this.path);
         }
       }
     }
     ```
       @method recognize
      @param {String} url
      @return {RouteInfo | null}
      @public
    */
  recognize(url) {
    !(url.indexOf(this.rootURL) === 0) && assert(`You must pass a url that begins with the application's rootURL "${this.rootURL}"`, url.indexOf(this.rootURL) === 0);
    this._router.setupRouter();
    let internalURL = cleanURL(url, this.rootURL);
    return this._router._routerMicrolib.recognize(internalURL);
  }
  /**
    Takes a string URL and returns a promise that resolves to a
    `RouteInfoWithAttributes` for the leafmost route represented by the URL.
    The promise rejects if the URL is not recognized or an unhandled exception
    is encountered. This method expects to receive the actual URL as seen by
    the browser including the app's `rootURL`.
       @method recognizeAndLoad
      @param {String} url
      @return {RouteInfo}
      @public
   */
  recognizeAndLoad(url) {
    !(url.indexOf(this.rootURL) === 0) && assert(`You must pass a url that begins with the application's rootURL "${this.rootURL}"`, url.indexOf(this.rootURL) === 0);
    this._router.setupRouter();
    let internalURL = cleanURL(url, this.rootURL);
    return this._router._routerMicrolib.recognizeAndLoad(internalURL);
  }
  /**
    You can register a listener for events emitted by this service with `.on()`:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeWillChange', (transition) => {
          if (!transition.to.find(route => route.name === this.routeName)) {
            alert("Please save or cancel your changes.");
            transition.abort();
          }
        })
      }
    }
    ```
     @method on
    @param {String} eventName
    @param {Function} callback
    @public
  */
  /**
    You can unregister a listener for events emitted by this service with `.off()`:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class ContactFormRoute extends Route {
      @service router;
       callback = (transition) => {
        if (!transition.to.find(route => route.name === this.routeName)) {
          alert('Please save or cancel your changes.');
          transition.abort();
        }
      };
       activate() {
        this.router.on('routeWillChange', this.callback);
      }
       deactivate() {
        this.router.off('routeWillChange', this.callback);
      }
    }
    ```
     @method off
    @param {String} eventName
    @param {Function} callback
    @public
  */
  /**
    The `routeWillChange` event is fired at the beginning of any
    attempted transition with a `Transition` object as the sole
    argument. This action can be used for aborting, redirecting,
    or decorating the transition from the currently active routes.
     A good example is preventing navigation when a form is
    half-filled out:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeWillChange', (transition) => {
          if (!transition.to.find(route => route.name === this.routeName)) {
            alert("Please save or cancel your changes.");
            transition.abort();
          }
        })
      }
    }
    ```
     The `routeWillChange` event fires whenever a new route is chosen as the desired target of a transition. This includes `transitionTo`, `replaceWith`, all redirection for any reason including error handling, and abort. Aborting implies changing the desired target back to where you already were. Once a transition has completed, `routeDidChange` fires.
     @event routeWillChange
    @param {Transition} transition
    @public
  */
  /**
    The `routeDidChange` event only fires once a transition has settled.
    This includes aborts and error substates. Like the `routeWillChange` event
    it receives a Transition as the sole argument.
     A good example is sending some analytics when the route has transitioned:
     ```app/routes/contact-form.js
    import Route from '@ember/routing';
    import { service } from '@ember/service';
     export default class extends Route {
      @service router;
       activate() {
        this.router.on('routeDidChange', (transition) => {
          ga.send('pageView', {
            current: transition.to.name,
            from: transition.from.name
          });
        })
      }
    }
    ```
     `routeDidChange` will be called after any `Route`'s
    [didTransition](/ember/release/classes/Route/events/didTransition?anchor=didTransition)
    action has been fired.
    The updates of properties
    [currentURL](/ember/release/classes/RouterService/properties/currentURL?anchor=currentURL),
    [currentRouteName](/ember/release/classes/RouterService/properties/currentURL?anchor=currentRouteName)
    and
    [currentRoute](/ember/release/classes/RouterService/properties/currentURL?anchor=currentRoute)
    are completed at the time `routeDidChange` is called.
     @event routeDidChange
    @param {Transition} transition
    @public
  */
  /**
   * Refreshes all currently active routes, doing a full transition.
   * If a route name is provided and refers to a currently active route,
   * it will refresh only that route and its descendents.
   * Returns a promise that will be resolved once the refresh is complete.
   * All resetController, beforeModel, model, afterModel, redirect, and setupController
   * hooks will be called again. You will get new data from the model hook.
   *
   * @method refresh
   * @param {String} [routeName] the route to refresh (along with all child routes)
   * @return Transition
   * @public
   */
  refresh(pivotRouteName) {
    if (!pivotRouteName) {
      return this._router._routerMicrolib.refresh();
    }
    !this._router.hasRoute(pivotRouteName) && assert(`The route "${pivotRouteName}" was not found`, this._router.hasRoute(pivotRouteName));
    !this.isActive(pivotRouteName) && assert(`The route "${pivotRouteName}" is currently not active`, this.isActive(pivotRouteName));
    let owner = getOwner(this);
    !owner && assert("RouterService is unexpectedly missing an owner", owner);
    let pivotRoute = owner.lookup(`route:${pivotRouteName}`);
    return this._router._routerMicrolib.refresh(pivotRoute);
  }
  /**
    The `currentRoute` property contains metadata about the current leaf route.
    It returns a `RouteInfo` object that has information like the route name,
    params, query params and more.
     See [RouteInfo](/ember/release/classes/RouteInfo) for more info.
     This property is guaranteed to change whenever a route transition
    happens (even when that transition only changes parameters
    and doesn't change the active route).
     Usage example:
    ```app/components/header.js
      import Component from '@glimmer/component';
      import { service } from '@ember/service';
      import { notEmpty } from '@ember/object/computed';
       export default class extends Component {
        @service router;
         @notEmpty('router.currentRoute.child') isChildRoute;
      });
    ```
     @property currentRoute
    @type RouteInfo
    @public
  */
};
_currentRouteName = new WeakMap();
_currentURL = new WeakMap();
_location = new WeakMap();
_rootURL = new WeakMap();
_currentRoute = new WeakMap();
decorateFieldV2(_RouterService.prototype, "currentRouteName", [readOnly("_router.currentRouteName")]);
decorateFieldV2(_RouterService.prototype, "currentURL", [readOnly("_router.currentURL")]);
decorateFieldV2(_RouterService.prototype, "location", [readOnly("_router.location")]);
decorateFieldV2(_RouterService.prototype, "rootURL", [readOnly("_router.rootURL")]);
decorateFieldV2(_RouterService.prototype, "currentRoute", [readOnly("_router.currentRoute")]);
var RouterService = _RouterService;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/routing/lib/routing-service.js
var RoutingService = class extends Service {
  [ROUTER];
  get router() {
    let router = this[ROUTER];
    if (router !== void 0) {
      return router;
    }
    let owner = getOwner(this);
    !owner && assert("RoutingService is unexpectedly missing an owner", owner);
    let _router = owner.lookup("router:main");
    !(_router instanceof EmberRouter) && assert("ROUTING SERVICE BUG: Expected router to be an instance of EmberRouter", _router instanceof EmberRouter);
    _router.setupRouter();
    return this[ROUTER] = _router;
  }
  hasRoute(routeName) {
    return this.router.hasRoute(routeName);
  }
  transitionTo(routeName, models, queryParams, shouldReplace) {
    let transition = this.router._doTransition(routeName, models, queryParams);
    if (shouldReplace) {
      transition.method("replace");
    }
    return transition;
  }
  normalizeQueryParams(routeName, models, queryParams) {
    this.router._prepareQueryParams(routeName, models, queryParams);
  }
  _generateURL(routeName, models, queryParams) {
    let visibleQueryParams = {};
    if (queryParams) {
      Object.assign(visibleQueryParams, queryParams);
      this.normalizeQueryParams(routeName, models, visibleQueryParams);
    }
    return this.router.generate(routeName, ...models, {
      queryParams: visibleQueryParams
    });
  }
  generateURL(routeName, models, queryParams) {
    if (this.router._initialTransitionStarted) {
      return this._generateURL(routeName, models, queryParams);
    } else {
      try {
        return this._generateURL(routeName, models, queryParams);
      } catch (_e) {
        return;
      }
    }
  }
  isActiveForRoute(contexts, queryParams, routeName, routerState) {
    let handlers = this.router._routerMicrolib.recognizer.handlersFor(routeName);
    let leafName = handlers[handlers.length - 1].handler;
    let maximumContexts = numberOfContextsAcceptedByHandler(routeName, handlers);
    if (contexts.length > maximumContexts) {
      routeName = leafName;
    }
    return routerState.isActiveIntent(routeName, contexts, queryParams);
  }
};
RoutingService.reopen({
  targetState: readOnly("router.targetState"),
  currentState: readOnly("router.currentState"),
  currentRouteName: readOnly("router.currentRouteName"),
  currentPath: readOnly("router.currentPath")
});
function numberOfContextsAcceptedByHandler(handlerName, handlerInfos) {
  let req = 0;
  for (let i = 0; i < handlerInfos.length; i++) {
    req += handlerInfos[i].names.length;
    if (handlerInfos[i].handler === handlerName) {
      break;
    }
  }
  return req;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/modifier/on.js
var on2 = on;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@ember/-internals/views/lib/compat/attrs.js
var MUTABLE_CELL = Symbol("MUTABLE_CELL");

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/shared-chunks/index-DaCZcoCY.js
var RootTemplate = templateFactory(
  /*
    {{component this}}
  */
  {
    "id": "yTlmws8O",
    "block": '[[[46,[30,0],null,null,null]],[],["component"]]',
    "moduleName": "packages/@ember/-internals/glimmer/lib/templates/root.hbs",
    "isStrictMode": true
  }
);
var InputTemplate = templateFactory(
  /*
    <input
    {{!-- for compatibility --}}
    id={{this.id}}
    class={{this.class}}
  
    ...attributes
  
    type={{this.type}}
    checked={{this.checked}}
    value={{this.value}}
  
    {{on "change" this.change}}
    {{on "input" this.input}}
    {{on "keyup" this.keyUp}}
    {{on "paste" this.valueDidChange}}
    {{on "cut" this.valueDidChange}}
  />
  */
  {
    "id": "Cc/BCoQJ",
    "block": '[[[11,"input"],[16,1,[30,0,["id"]]],[16,0,[30,0,["class"]]],[17,1],[16,4,[30,0,["type"]]],[16,"checked",[30,0,["checked"]]],[16,2,[30,0,["value"]]],[4,[32,0],["change",[30,0,["change"]]],null],[4,[32,0],["input",[30,0,["input"]]],null],[4,[32,0],["keyup",[30,0,["keyUp"]]],null],[4,[32,0],["paste",[30,0,["valueDidChange"]]],null],[4,[32,0],["cut",[30,0,["valueDidChange"]]],null],[12],[13]],["&attrs"],[]]',
    "moduleName": "packages/@ember/-internals/glimmer/lib/templates/input.hbs",
    "scope": () => [on2],
    "isStrictMode": true
  }
);
function NOOP$1() {
}
var InternalComponent = class {
  // Override this
  static toString() {
    return "internal component";
  }
  constructor(owner, args, caller) {
    this.owner = owner;
    this.args = args;
    this.caller = caller;
    setOwner(this, owner);
  }
  /**
   * The default HTML id attribute. We don't really _need_ one, this is just
   * added for compatibility as it's hard to tell if people rely on it being
   * present, and it doens't really hurt.
   *
   * However, don't rely on this internally, like passing it to `getElementId`.
   * This can be (and often is) overriden by passing an `id` attribute on the
   * invocation, which shadows this default id via `...attributes`.
   */
  get id() {
    return guidFor(this);
  }
  /**
   * The default HTML class attribute. Similar to the above, we don't _need_
   * them, they are just added for compatibility as it's similarly hard to tell
   * if people rely on it in their CSS etc, and it doens't really hurt.
   */
  get class() {
    return "ember-view";
  }
  validateArguments() {
    for (let name of Object.keys(this.args.named)) {
      if (!this.isSupportedArgument(name)) {
        this.onUnsupportedArgument(name);
      }
    }
  }
  named(name) {
    let ref = this.args.named[name];
    return ref ? valueForRef(ref) : void 0;
  }
  positional(index) {
    let ref = this.args.positional[index];
    return ref ? valueForRef(ref) : void 0;
  }
  listenerFor(name) {
    let listener = this.named(name);
    if (listener) {
      !(typeof listener === "function") && assert(`The \`@${name}\` argument to the <${this.constructor}> component must be a function`, typeof listener === "function");
      return listener;
    } else {
      return NOOP$1;
    }
  }
  isSupportedArgument(_name) {
    return false;
  }
  onUnsupportedArgument(_name) {
  }
  toString() {
    return `<${this.constructor}:${guidFor(this)}>`;
  }
};
var OPAQUE_CONSTRUCTOR_MAP = /* @__PURE__ */ new WeakMap();
function opaquify(constructor, template) {
  let _opaque = {
    // Factory interface
    create() {
      throw assert("Use constructor instead of create");
    },
    toString() {
      return constructor.toString();
    }
  };
  let opaque = _opaque;
  OPAQUE_CONSTRUCTOR_MAP.set(opaque, constructor);
  setInternalComponentManager(INTERNAL_COMPONENT_MANAGER, opaque);
  setComponentTemplate(template, opaque);
  return opaque;
}
function deopaquify(opaque) {
  let constructor = OPAQUE_CONSTRUCTOR_MAP.get(opaque);
  !constructor && assert(`[BUG] Invalid internal component constructor: ${opaque}`, constructor);
  return constructor;
}
var CAPABILITIES$3 = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: true,
  dynamicScope: false,
  updateHook: false,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
var InternalManager = class {
  getCapabilities() {
    return CAPABILITIES$3;
  }
  create(owner, definition, args, _env, _dynamicScope, caller) {
    !isConstRef(caller) && assert("caller must be const", isConstRef(caller));
    let ComponentClass = deopaquify(definition);
    let instance = new ComponentClass(owner, args.capture(), valueForRef(caller));
    untrack(instance["validateArguments"].bind(instance));
    return instance;
  }
  didCreate() {
  }
  didUpdate() {
  }
  didRenderLayout() {
  }
  didUpdateLayout() {
  }
  getDebugName(definition) {
    return definition.toString();
  }
  getSelf(instance) {
    return createConstRef(instance, "this");
  }
  getDestroyable(instance) {
    return instance;
  }
};
var INTERNAL_COMPONENT_MANAGER = new InternalManager();
var UNINITIALIZED = Object.freeze({});
function elementForEvent(event) {
  !(event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) && assert("[BUG] event target must be an <input> or <textarea> element", event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);
  return event.target;
}
function valueForEvent(event) {
  return elementForEvent(event).value;
}
function devirtualize(callback) {
  return (event) => callback(valueForEvent(event), event);
}
function valueFrom(reference) {
  if (reference === void 0) {
    return new LocalValue(void 0);
  } else if (isConstRef(reference)) {
    return new LocalValue(valueForRef(reference));
  } else if (isUpdatableRef(reference)) {
    return new UpstreamValue(reference);
  } else {
    return new ForkedValue(reference);
  }
}
var _value;
var _LocalValue = class _LocalValue {
  constructor(value) {
    __privateAdd(this, _value, (initializeDeferredDecorator(this, "value"), void 0));
    this.value = value;
  }
  get() {
    return this.value;
  }
  set(value) {
    this.value = value;
  }
};
_value = new WeakMap();
decorateFieldV2(_LocalValue.prototype, "value", [tracked]);
var LocalValue = _LocalValue;
var UpstreamValue = class {
  constructor(reference) {
    this.reference = reference;
  }
  get() {
    return valueForRef(this.reference);
  }
  set(value) {
    updateRef(this.reference, value);
  }
};
var ForkedValue = class {
  local;
  upstream;
  lastUpstreamValue = UNINITIALIZED;
  constructor(reference) {
    this.upstream = new UpstreamValue(reference);
  }
  get() {
    let upstreamValue = this.upstream.get();
    if (upstreamValue !== this.lastUpstreamValue) {
      this.lastUpstreamValue = upstreamValue;
      this.local = new LocalValue(upstreamValue);
    }
    !this.local && assert("[BUG] this.local must have been initialized at this point", this.local);
    return this.local.get();
  }
  set(value) {
    !this.local && assert("[BUG] this.local must have been initialized at this point", this.local);
    this.local.set(value);
  }
};
var _AbstractInput = class _AbstractInput extends InternalComponent {
  validateArguments() {
    !(this.args.positional.length === 0) && assert(`The ${this.constructor} component does not take any positional arguments`, this.args.positional.length === 0);
    super.validateArguments();
  }
  _value = valueFrom(this.args.named["value"]);
  get value() {
    return this._value.get();
  }
  set value(value) {
    this._value.set(value);
  }
  valueDidChange(event) {
    this.value = valueForEvent(event);
  }
  change(event) {
    this.valueDidChange(event);
  }
  /* @action */
  input(event) {
    this.valueDidChange(event);
  }
  keyUp(event) {
    switch (event.key) {
      case "Enter":
        this.listenerFor("enter")(event);
        this.listenerFor("insert-newline")(event);
        break;
      case "Escape":
        this.listenerFor("escape-press")(event);
        break;
    }
  }
  listenerFor(name) {
    let listener = super.listenerFor(name);
    if (this.isVirtualEventListener(name, listener)) {
      return devirtualize(listener);
    } else {
      return listener;
    }
  }
  isVirtualEventListener(name, _listener) {
    let virtualEvents = ["enter", "insert-newline", "escape-press"];
    return virtualEvents.indexOf(name) !== -1;
  }
};
decorateMethodV2(_AbstractInput.prototype, "valueDidChange", [action]);
decorateMethodV2(_AbstractInput.prototype, "keyUp", [action]);
var AbstractInput = _AbstractInput;
var isValidInputType;
if (hasDOM) {
  const INPUT_TYPES = /* @__PURE__ */ Object.create(null);
  const INPUT_ELEMENT = document.createElement("input");
  INPUT_TYPES[""] = false;
  INPUT_TYPES["text"] = true;
  INPUT_TYPES["checkbox"] = true;
  isValidInputType = (type) => {
    let isValid = INPUT_TYPES[type];
    if (isValid === void 0) {
      try {
        INPUT_ELEMENT.type = type;
        isValid = INPUT_ELEMENT.type === type;
      } catch (_e) {
        isValid = false;
      } finally {
        INPUT_ELEMENT.type = "text";
      }
      INPUT_TYPES[type] = isValid;
    }
    return isValid;
  };
} else {
  isValidInputType = (type) => type !== "";
}
var __Input = class __Input extends AbstractInput {
  static toString() {
    return "Input";
  }
  /**
   * The HTML class attribute.
   */
  get class() {
    if (this.isCheckbox) {
      return "ember-checkbox ember-view";
    } else {
      return "ember-text-field ember-view";
    }
  }
  /**
   * The HTML type attribute.
   */
  get type() {
    let type = this.named("type");
    if (type === null || type === void 0) {
      return "text";
    }
    !(typeof type === "string") && assert("The `@type` argument to the <Input> component must be a string", typeof type === "string");
    return isValidInputType(type) ? type : "text";
  }
  get isCheckbox() {
    return this.named("type") === "checkbox";
  }
  _checked = valueFrom(this.args.named["checked"]);
  get checked() {
    if (this.isCheckbox) {
      warn('`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. Did you mean `<Input @type="checkbox" @checked={{...}} />`?', untrack(() => this.args.named["checked"] !== void 0 || this.args.named["value"] === void 0 || typeof valueForRef(this.args.named["value"]) === "string"), {
        id: "ember.built-in-components.input-checkbox-value"
      });
      return this._checked.get();
    } else {
      return void 0;
    }
  }
  set checked(checked) {
    warn('`<Input @type="checkbox" />` reflects its checked state via the `@checked` argument. You wrote `<Input @type="checkbox" @value={{...}} />` which is likely not what you intended. Did you mean `<Input @type="checkbox" @checked={{...}} />`?', untrack(() => this.args.named["checked"] !== void 0 || this.args.named["value"] === void 0 || typeof valueForRef(this.args.named["value"]) === "string"), {
      id: "ember.built-in-components.input-checkbox-value"
    });
    this._checked.set(checked);
  }
  change(event) {
    if (this.isCheckbox) {
      this.checkedDidChange(event);
    } else {
      super.change(event);
    }
  }
  input(event) {
    if (!this.isCheckbox) {
      super.input(event);
    }
  }
  checkedDidChange(event) {
    let element = event.target;
    !(element instanceof HTMLInputElement) && assert("[BUG] element must be an <input>", element instanceof HTMLInputElement);
    this.checked = element.checked;
  }
  isSupportedArgument(name) {
    let supportedArguments = ["type", "value", "checked", "enter", "insert-newline", "escape-press"];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
};
decorateMethodV2(__Input.prototype, "change", [action]);
decorateMethodV2(__Input.prototype, "input", [action]);
decorateMethodV2(__Input.prototype, "checkedDidChange", [action]);
var _Input = __Input;
var Input = opaquify(_Input, InputTemplate);
var LinkToTemplate = templateFactory(
  /*
    <a
    {{!-- for compatibility --}}
    id={{this.id}}
    class={{this.class}}
  
    {{!-- deprecated attribute bindings --}}
    role={{this.role}}
    title={{this.title}}
    rel={{this.rel}}
    tabindex={{this.tabindex}}
    target={{this.target}}
  
    ...attributes
  
    href={{this.href}}
  
    {{on 'click' this.click}}
  >{{yield}}</a>
  */
  {
    "id": "7Z3LFeO/",
    "block": '[[[11,3],[16,1,[30,0,["id"]]],[16,0,[30,0,["class"]]],[16,"role",[30,0,["role"]]],[16,"title",[30,0,["title"]]],[16,"rel",[30,0,["rel"]]],[16,"tabindex",[30,0,["tabindex"]]],[16,"target",[30,0,["target"]]],[17,1],[16,6,[30,0,["href"]]],[4,[32,0],["click",[30,0,["click"]]],null],[12],[18,2,null],[13]],["&attrs","&default"],["yield"]]',
    "moduleName": "packages/@ember/-internals/glimmer/lib/templates/link-to.hbs",
    "scope": () => [on2],
    "isStrictMode": true
  }
);
var EMPTY_ARRAY$1 = [];
var EMPTY_QUERY_PARAMS = {};
debugFreeze(EMPTY_ARRAY$1);
debugFreeze(EMPTY_QUERY_PARAMS);
function isMissing(value) {
  return value === null || value === void 0;
}
function isPresent(value) {
  return !isMissing(value);
}
function isQueryParams(value) {
  return typeof value === "object" && value !== null && value["isQueryParams"] === true;
}
var _routing;
var __LinkTo = class __LinkTo extends InternalComponent {
  constructor() {
    super(...arguments);
    __privateAdd(this, _routing, (initializeDeferredDecorator(this, "routing"), void 0));
    // GH #17963
    __publicField(this, "currentRouteCache", createCache(() => {
      consumeTag(tagFor(this.routing, "currentState"));
      return untrack(() => this.routing.currentRouteName);
    }));
  }
  static toString() {
    return "LinkTo";
  }
  validateArguments() {
    !(!this.isEngine || this.engineMountPoint !== void 0) && assert("You attempted to use the <LinkTo> component within a routeless engine, this is not supported. If you are using the ember-engines addon, use the <LinkToExternal> component instead. See https://ember-engines.com/docs/links for more info.", !this.isEngine || this.engineMountPoint !== void 0);
    !("route" in this.args.named || "model" in this.args.named || "models" in this.args.named || "query" in this.args.named) && assert("You must provide at least one of the `@route`, `@model`, `@models` or `@query` arguments to `<LinkTo>`.", "route" in this.args.named || "model" in this.args.named || "models" in this.args.named || "query" in this.args.named);
    !!("model" in this.args.named && "models" in this.args.named) && assert("You cannot provide both the `@model` and `@models` arguments to the <LinkTo> component.", !("model" in this.args.named && "models" in this.args.named));
    super.validateArguments();
  }
  get class() {
    let classes = "ember-view";
    if (this.isActive) {
      classes += this.classFor("active");
      if (this.willBeActive === false) {
        classes += " ember-transitioning-out";
      }
    } else if (this.willBeActive) {
      classes += " ember-transitioning-in";
    }
    if (this.isLoading) {
      classes += this.classFor("loading");
    }
    if (this.isDisabled) {
      classes += this.classFor("disabled");
    }
    return classes;
  }
  get href() {
    if (this.isLoading) {
      return "#";
    }
    let {
      routing,
      route,
      models,
      query
    } = this;
    !isPresent(route) && assert("[BUG] route can only be missing if isLoading is true", isPresent(route));
    consumeTag(tagFor(routing, "currentState"));
    if (true) {
      try {
        return routing.generateURL(route, models, query);
      } catch (e) {
        let details = e instanceof Error ? e.message : inspect(e);
        let message = `While generating link to route "${route}": ${details}`;
        if (e instanceof Error) {
          e.message = message;
          throw e;
        } else {
          throw message;
        }
      }
    } else {
      return routing.generateURL(route, models, query);
    }
  }
  click(event) {
    if (!isSimpleClick(event)) {
      return;
    }
    let element = event.currentTarget;
    !(element instanceof HTMLAnchorElement) && assert("[BUG] must be an <a> element", element instanceof HTMLAnchorElement);
    let isSelf = element.target === "" || element.target === "_self";
    if (isSelf) {
      this.preventDefault(event);
    } else {
      return;
    }
    if (this.isDisabled) {
      return;
    }
    if (this.isLoading) {
      warn("This link is in an inactive loading state because at least one of its models currently has a null/undefined value, or the provided route name is invalid.", false, {
        id: "ember-glimmer.link-to.inactive-loading-state"
      });
      return;
    }
    let {
      routing,
      route,
      models,
      query,
      replace
    } = this;
    let payload = {
      transition: void 0
    };
    flaggedInstrument("interaction.link-to", payload, () => {
      !isPresent(route) && assert("[BUG] route can only be missing if isLoading is true", isPresent(route));
      payload.transition = routing.transitionTo(route, models, query, replace);
    });
  }
  get route() {
    if ("route" in this.args.named) {
      let route = this.named("route");
      !(isMissing(route) || typeof route === "string") && assert("The `@route` argument to the <LinkTo> component must be a string", isMissing(route) || typeof route === "string");
      return route && this.namespaceRoute(route);
    } else {
      return this.currentRoute;
    }
  }
  get currentRoute() {
    return getValue(this.currentRouteCache);
  }
  // TODO: not sure why generateURL takes {}[] instead of unknown[]
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type
  get models() {
    if ("models" in this.args.named) {
      let models = this.named("models");
      !Array.isArray(models) && assert("The `@models` argument to the <LinkTo> component must be an array.", Array.isArray(models));
      return models;
    } else if ("model" in this.args.named) {
      return [this.named("model")];
    } else {
      return EMPTY_ARRAY$1;
    }
  }
  get query() {
    if ("query" in this.args.named) {
      let query = this.named("query");
      !(query !== null && typeof query === "object") && assert("The `@query` argument to the <LinkTo> component must be an object.", query !== null && typeof query === "object");
      return {
        ...query
      };
    } else {
      return EMPTY_QUERY_PARAMS;
    }
  }
  get replace() {
    return this.named("replace") === true;
  }
  get isActive() {
    return this.isActiveForState(this.routing.currentState);
  }
  get willBeActive() {
    let current = this.routing.currentState;
    let target = this.routing.targetState;
    if (current === target) {
      return null;
    } else {
      return this.isActiveForState(target);
    }
  }
  get isLoading() {
    return isMissing(this.route) || this.models.some((model) => isMissing(model));
  }
  get isDisabled() {
    return Boolean(this.named("disabled"));
  }
  get isEngine() {
    let owner = this.owner;
    return getEngineParent(owner) !== void 0;
  }
  get engineMountPoint() {
    let owner = this.owner;
    return owner.mountPoint;
  }
  classFor(state) {
    let className = this.named(`${state}Class`);
    !(isMissing(className) || typeof className === "string" || typeof className === "boolean") && assert(`The \`@${state}Class\` argument to the <LinkTo> component must be a string or boolean`, isMissing(className) || typeof className === "string" || typeof className === "boolean");
    if (className === true || isMissing(className)) {
      return ` ${state}`;
    } else if (className) {
      return ` ${className}`;
    } else {
      return "";
    }
  }
  namespaceRoute(route) {
    let {
      engineMountPoint
    } = this;
    if (engineMountPoint === void 0) {
      return route;
    } else if (route === "application") {
      return engineMountPoint;
    } else {
      return `${engineMountPoint}.${route}`;
    }
  }
  isActiveForState(state) {
    if (!isPresent(state)) {
      return false;
    }
    if (this.isLoading) {
      return false;
    }
    let currentWhen = this.named("current-when");
    if (typeof currentWhen === "boolean") {
      return currentWhen;
    } else if (typeof currentWhen === "string") {
      let {
        models,
        routing
      } = this;
      return currentWhen.split(" ").some((route) => routing.isActiveForRoute(models, void 0, this.namespaceRoute(route), state));
    } else {
      let {
        route,
        models,
        query,
        routing
      } = this;
      !isPresent(route) && assert("[BUG] route can only be missing if isLoading is true", isPresent(route));
      return routing.isActiveForRoute(models, query, route, state);
    }
  }
  preventDefault(event) {
    event.preventDefault();
  }
  isSupportedArgument(name) {
    let supportedArguments = ["route", "model", "models", "query", "replace", "disabled", "current-when", "activeClass", "loadingClass", "disabledClass"];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
};
_routing = new WeakMap();
decorateFieldV2(__LinkTo.prototype, "routing", [service("-routing")]);
decorateMethodV2(__LinkTo.prototype, "click", [action]);
var _LinkTo = __LinkTo;
var {
  prototype
} = _LinkTo;
var descriptorFor = (target, property) => {
  if (target) {
    return Object.getOwnPropertyDescriptor(target, property) || descriptorFor(Object.getPrototypeOf(target), property);
  } else {
    return null;
  }
};
{
  let superOnUnsupportedArgument = prototype["onUnsupportedArgument"];
  Object.defineProperty(prototype, "onUnsupportedArgument", {
    configurable: true,
    enumerable: false,
    value: function onUnsupportedArgument(name) {
      if (name === "href") {
        assert(`Passing the \`@href\` argument to <LinkTo> is not supported.`);
      } else {
        superOnUnsupportedArgument.call(this, name);
      }
    }
  });
}
{
  let superModelsDescriptor = descriptorFor(prototype, "models");
  !(superModelsDescriptor && typeof superModelsDescriptor.get === "function") && assert(`[BUG] expecting models to be a getter on <LinkTo>`, superModelsDescriptor && typeof superModelsDescriptor.get === "function");
  let superModelsGetter = superModelsDescriptor.get;
  Object.defineProperty(prototype, "models", {
    configurable: true,
    enumerable: false,
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
    get: function models() {
      let models2 = superModelsGetter.call(this);
      if (models2.length > 0 && !("query" in this.args.named)) {
        if (isQueryParams(models2[models2.length - 1])) {
          models2 = models2.slice(0, -1);
        }
      }
      return models2;
    }
  });
  let superQueryDescriptor = descriptorFor(prototype, "query");
  !(superQueryDescriptor && typeof superQueryDescriptor.get === "function") && assert(`[BUG] expecting query to be a getter on <LinkTo>`, superQueryDescriptor && typeof superQueryDescriptor.get === "function");
  let superQueryGetter = superQueryDescriptor.get;
  Object.defineProperty(prototype, "query", {
    configurable: true,
    enumerable: false,
    // eslint-disable-next-line @typescript-eslint/no-empty-object-type
    get: function query() {
      if ("query" in this.args.named) {
        let qp = superQueryGetter.call(this);
        if (isQueryParams(qp)) {
          return qp.values ?? EMPTY_QUERY_PARAMS;
        } else {
          return qp;
        }
      } else {
        let models = superModelsGetter.call(this);
        if (models.length > 0) {
          let qp = models[models.length - 1];
          if (isQueryParams(qp) && qp.values !== null) {
            return qp.values;
          }
        }
        return EMPTY_QUERY_PARAMS;
      }
    }
  });
}
{
  let superOnUnsupportedArgument = prototype["onUnsupportedArgument"];
  Object.defineProperty(prototype, "onUnsupportedArgument", {
    configurable: true,
    enumerable: false,
    value: function onUnsupportedArgument(name) {
      if (name !== "params") {
        superOnUnsupportedArgument.call(this, name);
      }
    }
  });
}
var LinkTo = opaquify(_LinkTo, LinkToTemplate);
var TextareaTemplate = templateFactory(
  /*
    <textarea
    {{!-- for compatibility --}}
    id={{this.id}}
    class={{this.class}}
  
    ...attributes
  
    value={{this.value}}
  
    {{on "change" this.change}}
    {{on "input" this.input}}
    {{on "keyup" this.keyUp}}
    {{on "paste" this.valueDidChange}}
    {{on "cut" this.valueDidChange}}
  />
  */
  {
    "id": "KVdeMchh",
    "block": '[[[11,"textarea"],[16,1,[30,0,["id"]]],[16,0,[30,0,["class"]]],[17,1],[16,2,[30,0,["value"]]],[4,[32,0],["change",[30,0,["change"]]],null],[4,[32,0],["input",[30,0,["input"]]],null],[4,[32,0],["keyup",[30,0,["keyUp"]]],null],[4,[32,0],["paste",[30,0,["valueDidChange"]]],null],[4,[32,0],["cut",[30,0,["valueDidChange"]]],null],[12],[13]],["&attrs"],[]]',
    "moduleName": "packages/@ember/-internals/glimmer/lib/templates/textarea.hbs",
    "scope": () => [on2],
    "isStrictMode": true
  }
);
var __Textarea = class __Textarea extends AbstractInput {
  static toString() {
    return "Textarea";
  }
  get class() {
    return "ember-text-area ember-view";
  }
  // See abstract-input.ts for why these are needed
  change(event) {
    super.change(event);
  }
  input(event) {
    super.input(event);
  }
  isSupportedArgument(name) {
    let supportedArguments = ["type", "value", "enter", "insert-newline", "escape-press"];
    return supportedArguments.indexOf(name) !== -1 || super.isSupportedArgument(name);
  }
};
decorateMethodV2(__Textarea.prototype, "change", [action]);
decorateMethodV2(__Textarea.prototype, "input", [action]);
var _Textarea = __Textarea;
var Textarea = opaquify(_Textarea, TextareaTemplate);
function unwrapTemplate(template) {
  if (template.result === "error") {
    throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);
  }
  return template;
}
function isTemplateFactory(template) {
  return typeof template === "function";
}
function referenceForParts(rootRef, parts) {
  let isAttrs = parts[0] === "attrs";
  if (isAttrs) {
    parts.shift();
    if (parts.length === 1) {
      return childRefFor(rootRef, parts[0]);
    }
  }
  return childRefFromParts(rootRef, parts);
}
function parseAttributeBinding(microsyntax) {
  let colonIndex = microsyntax.indexOf(":");
  if (colonIndex === -1) {
    !(microsyntax !== "class") && assert("You cannot use class as an attributeBinding, use classNameBindings instead.", microsyntax !== "class");
    return [microsyntax, microsyntax, true];
  } else {
    let prop = microsyntax.substring(0, colonIndex);
    let attribute = microsyntax.substring(colonIndex + 1);
    !(attribute !== "class") && assert("You cannot use class as an attributeBinding, use classNameBindings instead.", attribute !== "class");
    return [prop, attribute, false];
  }
}
function installAttributeBinding(component, rootRef, parsed, operations) {
  let [prop, attribute, isSimple] = parsed;
  if (attribute === "id") {
    let elementId = get2(component, prop);
    if (elementId === void 0 || elementId === null) {
      elementId = component.elementId;
    }
    let elementIdRef = createPrimitiveRef(elementId);
    operations.setAttribute("id", elementIdRef, true, null);
    return;
  }
  let isPath = prop.indexOf(".") > -1;
  let reference = isPath ? referenceForParts(rootRef, prop.split(".")) : childRefFor(rootRef, prop);
  !!(isSimple && isPath) && assert(`Illegal attributeBinding: '${prop}' is not a valid attribute name.`, !(isSimple && isPath));
  operations.setAttribute(attribute, reference, false, null);
}
function createClassNameBindingRef(rootRef, microsyntax, operations) {
  let parts = microsyntax.split(":");
  let [prop, truthy, falsy] = parts;
  !(prop !== void 0) && assert("has prop", prop !== void 0);
  let isStatic = prop === "";
  if (isStatic) {
    operations.setAttribute("class", createPrimitiveRef(truthy), true, null);
  } else {
    let isPath = prop.indexOf(".") > -1;
    let parts2 = isPath ? prop.split(".") : [];
    let value = isPath ? referenceForParts(rootRef, parts2) : childRefFor(rootRef, prop);
    let ref;
    if (truthy === void 0) {
      ref = createSimpleClassNameBindingRef(value, isPath ? parts2[parts2.length - 1] : prop);
    } else {
      ref = createColonClassNameBindingRef(value, truthy, falsy);
    }
    operations.setAttribute("class", ref, false, null);
  }
}
function createSimpleClassNameBindingRef(inner, path) {
  let dasherizedPath;
  return createComputeRef(() => {
    let value = valueForRef(inner);
    if (value === true) {
      !(path !== void 0) && assert("You must pass a path when binding a to a class name using classNameBindings", path !== void 0);
      return dasherizedPath || (dasherizedPath = dasherize(path));
    } else if (value || value === 0) {
      return String(value);
    } else {
      return null;
    }
  });
}
function createColonClassNameBindingRef(inner, truthy, falsy) {
  return createComputeRef(() => {
    return valueForRef(inner) ? truthy : falsy;
  });
}
function NOOP2() {
}
var ComponentStateBucket = class {
  classRef = null;
  rootRef;
  argsRevision;
  constructor(component, args, argsTag, finalizer, hasWrappedElement, isInteractive) {
    this.component = component;
    this.args = args;
    this.argsTag = argsTag;
    this.finalizer = finalizer;
    this.hasWrappedElement = hasWrappedElement;
    this.isInteractive = isInteractive;
    this.classRef = null;
    this.argsRevision = args === null ? 0 : valueForTag(argsTag);
    this.rootRef = createConstRef(component, "this");
    registerDestructor(this, () => this.willDestroy(), true);
    registerDestructor(this, () => this.component.destroy());
  }
  willDestroy() {
    let {
      component,
      isInteractive
    } = this;
    if (isInteractive) {
      beginUntrackFrame();
      component.trigger("willDestroyElement");
      component.trigger("willClearRender");
      endUntrackFrame();
      let element = getViewElement(component);
      if (element) {
        clearElementView(element);
        clearViewElement(component);
      }
    }
    component.renderer.unregister(component);
  }
  finalize() {
    let {
      finalizer
    } = this;
    finalizer();
    this.finalizer = NOOP2;
  }
};
function processComponentArgs(namedArgs) {
  let attrs = /* @__PURE__ */ Object.create(null);
  let props = /* @__PURE__ */ Object.create(null);
  for (let name in namedArgs) {
    let ref = namedArgs[name];
    !ref && assert("expected ref", ref);
    let value = valueForRef(ref);
    if (isUpdatableRef(ref)) {
      attrs[name] = new MutableCell(ref, value);
    } else {
      attrs[name] = value;
    }
    props[name] = value;
  }
  props.attrs = attrs;
  return props;
}
var REF = Symbol("REF");
var MutableCell = class {
  value;
  [MUTABLE_CELL];
  [REF];
  constructor(ref, value) {
    this[MUTABLE_CELL] = true;
    this[REF] = ref;
    this.value = value;
  }
  update(val) {
    updateRef(this[REF], val);
  }
};
var ARGS = enumerableSymbol("ARGS");
var HAS_BLOCK = enumerableSymbol("HAS_BLOCK");
var DIRTY_TAG2 = Symbol("DIRTY_TAG");
var IS_DISPATCHING_ATTRS = Symbol("IS_DISPATCHING_ATTRS");
var BOUNDS = Symbol("BOUNDS");
var EMBER_VIEW_REF = createPrimitiveRef("ember-view");
function aliasIdToElementId(args, props) {
  if (args.named.has("id")) {
    !!args.named.has("elementId") && assert(`You cannot invoke a component with both 'id' and 'elementId' at the same time.`, !args.named.has("elementId"));
    props.elementId = props.id;
  }
}
function applyAttributeBindings(attributeBindings, component, rootRef, operations) {
  let seen = [];
  let i = attributeBindings.length - 1;
  while (i !== -1) {
    let binding = attributeBindings[i];
    !binding && assert("has binding", binding);
    let parsed = parseAttributeBinding(binding);
    let attribute = parsed[1];
    if (seen.indexOf(attribute) === -1) {
      seen.push(attribute);
      installAttributeBinding(component, rootRef, parsed, operations);
    }
    i--;
  }
  if (seen.indexOf("id") === -1) {
    let id = component.elementId ? component.elementId : guidFor(component);
    operations.setAttribute("id", createPrimitiveRef(id), false, null);
  }
}
var EMPTY_POSITIONAL_ARGS = [];
debugFreeze(EMPTY_POSITIONAL_ARGS);
var CurlyComponentManager = class {
  templateFor(component) {
    let {
      layout,
      layoutName
    } = component;
    let owner = getOwner(component);
    !owner && assert("Component is unexpectedly missing an owner", owner);
    let factory;
    if (layout === void 0) {
      if (layoutName !== void 0) {
        let _factory = owner.lookup(`template:${layoutName}`);
        !(_factory !== void 0) && assert(`Layout \`${layoutName}\` not found!`, _factory !== void 0);
        factory = _factory;
      } else {
        return null;
      }
    } else if (isTemplateFactory(layout)) {
      factory = layout;
    } else {
      return null;
    }
    return unwrapTemplate(factory(owner)).asWrappedLayout();
  }
  getDynamicLayout(bucket) {
    return this.templateFor(bucket.component);
  }
  getTagName(state) {
    let {
      component,
      hasWrappedElement
    } = state;
    if (!hasWrappedElement) {
      return null;
    }
    return component && component.tagName || "div";
  }
  getCapabilities() {
    return CURLY_CAPABILITIES;
  }
  prepareArgs(ComponentClass, args) {
    if (args.named.has("__ARGS__")) {
      !(args.positional.length === 0) && assert("[BUG] cannot pass both __ARGS__ and positional arguments", args.positional.length === 0);
      let {
        __ARGS__,
        ...rest
      } = args.named.capture();
      !__ARGS__ && assert("[BUG] unexpectedly missing __ARGS__ after check", __ARGS__);
      let __args__ = valueForRef(__ARGS__);
      let prepared = {
        positional: __args__.positional,
        named: {
          ...rest,
          ...__args__.named
        }
      };
      return prepared;
    }
    const {
      positionalParams
    } = ComponentClass.class ?? ComponentClass;
    if (positionalParams === void 0 || positionalParams === null || args.positional.length === 0) {
      return null;
    }
    let named;
    if (typeof positionalParams === "string") {
      !!args.named.has(positionalParams) && assert(`You cannot specify positional parameters and the hash argument \`${positionalParams}\`.`, !args.named.has(positionalParams));
      let captured = args.positional.capture();
      named = {
        [positionalParams]: createComputeRef(() => reifyPositional(captured))
      };
      Object.assign(named, args.named.capture());
    } else if (Array.isArray(positionalParams) && positionalParams.length > 0) {
      const count = Math.min(positionalParams.length, args.positional.length);
      named = {};
      Object.assign(named, args.named.capture());
      for (let i = 0; i < count; i++) {
        let name = positionalParams[i];
        !name && assert("Expected at least one positional param", name);
        !!args.named.has(name) && assert(`You cannot specify both a positional param (at position ${i}) and the hash argument \`${name}\`.`, !args.named.has(name));
        named[name] = args.positional.at(i);
      }
    } else {
      return null;
    }
    return {
      positional: EMPTY_ARRAY,
      named
    };
  }
  /*
   * This hook is responsible for actually instantiating the component instance.
   * It also is where we perform additional bookkeeping to support legacy
   * features like exposed by view mixins like ChildViewSupport, ActionSupport,
   * etc.
   */
  create(owner, ComponentClass, args, {
    isInteractive
  }, dynamicScope, callerSelfRef, hasBlock) {
    let parentView = dynamicScope.view;
    let capturedArgs = args.named.capture();
    beginTrackFrame();
    let props = processComponentArgs(capturedArgs);
    props[ARGS] = capturedArgs;
    let argsTag = endTrackFrame();
    aliasIdToElementId(args, props);
    props.parentView = parentView;
    props[HAS_BLOCK] = hasBlock;
    props._target = valueForRef(callerSelfRef);
    setOwner(props, owner);
    beginUntrackFrame();
    let component = ComponentClass.create(props);
    let finalizer = _instrumentStart("render.component", initialRenderInstrumentDetails, component);
    dynamicScope.view = component;
    if (parentView !== null && parentView !== void 0) {
      addChildView(parentView, component);
    }
    component.trigger("didReceiveAttrs");
    let hasWrappedElement = component.tagName !== "";
    if (!hasWrappedElement) {
      if (isInteractive) {
        component.trigger("willRender");
      }
      component._transitionTo("hasElement");
      if (isInteractive) {
        component.trigger("willInsertElement");
      }
    }
    let bucket = new ComponentStateBucket(component, capturedArgs, argsTag, finalizer, hasWrappedElement, isInteractive);
    if (args.named.has("class")) {
      bucket.classRef = args.named.get("class");
    }
    if (true) {
      processComponentInitializationAssertions(component, props);
    }
    if (isInteractive && hasWrappedElement) {
      component.trigger("willRender");
    }
    endUntrackFrame();
    consumeTag(bucket.argsTag);
    consumeTag(component[DIRTY_TAG2]);
    return bucket;
  }
  getDebugName(definition) {
    return definition.fullName || definition.normalizedName || definition.class?.name || definition.name;
  }
  getSelf({
    rootRef
  }) {
    return rootRef;
  }
  didCreateElement({
    component,
    classRef,
    isInteractive,
    rootRef
  }, element, operations) {
    setViewElement(component, element);
    setElementView(element, component);
    let {
      attributeBindings,
      classNames,
      classNameBindings
    } = component;
    if (attributeBindings && attributeBindings.length) {
      applyAttributeBindings(attributeBindings, component, rootRef, operations);
    } else {
      let id = component.elementId ? component.elementId : guidFor(component);
      operations.setAttribute("id", createPrimitiveRef(id), false, null);
    }
    if (classRef) {
      const ref = createSimpleClassNameBindingRef(classRef);
      operations.setAttribute("class", ref, false, null);
    }
    if (classNames && classNames.length) {
      classNames.forEach((name) => {
        operations.setAttribute("class", createPrimitiveRef(name), false, null);
      });
    }
    if (classNameBindings && classNameBindings.length) {
      classNameBindings.forEach((binding) => {
        createClassNameBindingRef(rootRef, binding, operations);
      });
    }
    operations.setAttribute("class", EMBER_VIEW_REF, false, null);
    if ("ariaRole" in component) {
      operations.setAttribute("role", childRefFor(rootRef, "ariaRole"), false, null);
    }
    component._transitionTo("hasElement");
    if (isInteractive) {
      beginUntrackFrame();
      component.trigger("willInsertElement");
      endUntrackFrame();
    }
  }
  didRenderLayout(bucket, bounds) {
    bucket.component[BOUNDS] = bounds;
    bucket.finalize();
  }
  didCreate({
    component,
    isInteractive
  }) {
    if (isInteractive) {
      component._transitionTo("inDOM");
      component.trigger("didInsertElement");
      component.trigger("didRender");
    }
  }
  update(bucket) {
    let {
      component,
      args,
      argsTag,
      argsRevision,
      isInteractive
    } = bucket;
    bucket.finalizer = _instrumentStart("render.component", rerenderInstrumentDetails, component);
    beginUntrackFrame();
    if (args !== null && !validateTag(argsTag, argsRevision)) {
      beginTrackFrame();
      let props = processComponentArgs(args);
      argsTag = bucket.argsTag = endTrackFrame();
      bucket.argsRevision = valueForTag(argsTag);
      component[IS_DISPATCHING_ATTRS] = true;
      component.setProperties(props);
      component[IS_DISPATCHING_ATTRS] = false;
      component.trigger("didUpdateAttrs");
      component.trigger("didReceiveAttrs");
    }
    if (isInteractive) {
      component.trigger("willUpdate");
      component.trigger("willRender");
    }
    endUntrackFrame();
    consumeTag(argsTag);
    consumeTag(component[DIRTY_TAG2]);
  }
  didUpdateLayout(bucket) {
    bucket.finalize();
  }
  didUpdate({
    component,
    isInteractive
  }) {
    if (isInteractive) {
      component.trigger("didUpdate");
      component.trigger("didRender");
    }
  }
  getDestroyable(bucket) {
    return bucket;
  }
};
function processComponentInitializationAssertions(component, props) {
  !(() => {
    let {
      classNameBindings
    } = component;
    for (let i = 0; i < classNameBindings.length; i++) {
      let binding = classNameBindings[i];
      if (typeof binding !== "string" || binding.length === 0) {
        return false;
      }
    }
    return true;
  })() && assert(`classNameBindings must be non-empty strings: ${component}`, (() => {
    let {
      classNameBindings
    } = component;
    for (let i = 0; i < classNameBindings.length; i++) {
      let binding = classNameBindings[i];
      if (typeof binding !== "string" || binding.length === 0) {
        return false;
      }
    }
    return true;
  })());
  !(() => {
    let {
      classNameBindings
    } = component;
    for (let binding of classNameBindings) {
      if (binding.split(" ").length > 1) {
        return false;
      }
    }
    return true;
  })() && assert(`classNameBindings must not have spaces in them: ${component}`, (() => {
    let {
      classNameBindings
    } = component;
    for (let binding of classNameBindings) {
      if (binding.split(" ").length > 1) {
        return false;
      }
    }
    return true;
  })());
  !(component.tagName !== "" || !component.classNameBindings || component.classNameBindings.length === 0) && assert(`You cannot use \`classNameBindings\` on a tag-less component: ${component}`, component.tagName !== "" || !component.classNameBindings || component.classNameBindings.length === 0);
  !(component.tagName !== "" || props.id === component.elementId || !component.elementId && component.elementId !== "") && assert(`You cannot use \`elementId\` on a tag-less component: ${component}`, component.tagName !== "" || props.id === component.elementId || !component.elementId && component.elementId !== "");
  !(component.tagName !== "" || !component.attributeBindings || component.attributeBindings.length === 0) && assert(`You cannot use \`attributeBindings\` on a tag-less component: ${component}`, component.tagName !== "" || !component.attributeBindings || component.attributeBindings.length === 0);
}
function initialRenderInstrumentDetails(component) {
  return component.instrumentDetails({
    initialRender: true
  });
}
function rerenderInstrumentDetails(component) {
  return component.instrumentDetails({
    initialRender: false
  });
}
var CURLY_CAPABILITIES = {
  dynamicLayout: true,
  dynamicTag: true,
  prepareArgs: true,
  createArgs: true,
  attributeHook: true,
  elementHook: true,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: true,
  willDestroy: true,
  hasSubOwner: false
};
var CURLY_COMPONENT_MANAGER = new CurlyComponentManager();
function isCurlyManager(manager) {
  return manager === CURLY_COMPONENT_MANAGER;
}
var lazyEventsProcessed = /* @__PURE__ */ new WeakMap();
var EMPTY_ARRAY2 = Object.freeze([]);
var elMatches = typeof Element !== "undefined" ? Element.prototype.matches : void 0;
function matches(el, selector) {
  !(elMatches !== void 0) && assert("cannot call `matches` in fastboot mode", elMatches !== void 0);
  return elMatches.call(el, selector);
}
var _Component = class _Component extends CoreView.extend(TargetActionSupport, ActionSupport, {
  // These need to be overridable via extend/create but should still
  // have a default. Defining them here is the best way to achieve that.
  didReceiveAttrs() {
  },
  didRender() {
  },
  didUpdate() {
  },
  didUpdateAttrs() {
  },
  willRender() {
  },
  willUpdate() {
  }
}, {
  concatenatedProperties: ["attributeBindings", "classNames", "classNameBindings"],
  classNames: EMPTY_ARRAY2,
  classNameBindings: EMPTY_ARRAY2
}) {
  isComponent = true;
  // SAFETY: this has no runtime existence whatsoever; it is a "phantom type"
  // here to preserve the type param.
  // SAFTEY: This is set in `init`.
  /**
    Standard CSS class names to apply to the view's outer element. This
    property automatically inherits any class names defined by the view's
    superclasses as well.
     @property classNames
    @type Array
    @default ['ember-view']
    @public
  */
  /**
    A list of properties of the view to apply as class names. If the property
    is a string value, the value of that string will be applied as a class
    name.
     ```javascript
    // Applies the 'high' class to the view element
    import Component from '@ember/component';
    Component.extend({
      classNameBindings: ['priority'],
      priority: 'high'
    });
    ```
     If the value of the property is a Boolean, the name of that property is
    added as a dasherized class name.
     ```javascript
    // Applies the 'is-urgent' class to the view element
    import Component from '@ember/component';
    Component.extend({
      classNameBindings: ['isUrgent'],
      isUrgent: true
    });
    ```
     If you would prefer to use a custom value instead of the dasherized
    property name, you can pass a binding like this:
     ```javascript
    // Applies the 'urgent' class to the view element
    import Component from '@ember/component';
    Component.extend({
      classNameBindings: ['isUrgent:urgent'],
      isUrgent: true
    });
    ```
     If you would like to specify a class that should only be added when the
    property is false, you can declare a binding like this:
     ```javascript
    // Applies the 'disabled' class to the view element
    import Component from '@ember/component';
    Component.extend({
      classNameBindings: ['isEnabled::disabled'],
      isEnabled: false
    });
    ```
     This list of properties is inherited from the component's superclasses as well.
     @property classNameBindings
    @type Array
    @default []
    @public
  */
  init(properties) {
    super.init(properties);
    this._superRerender = this.rerender;
    this.rerender = this._rerender;
    this[IS_DISPATCHING_ATTRS] = false;
    this[DIRTY_TAG2] = createTag();
    this[BOUNDS] = null;
    const eventDispatcher = this._dispatcher;
    if (eventDispatcher) {
      let lazyEventsProcessedForComponentClass = lazyEventsProcessed.get(eventDispatcher);
      if (!lazyEventsProcessedForComponentClass) {
        lazyEventsProcessedForComponentClass = /* @__PURE__ */ new WeakSet();
        lazyEventsProcessed.set(eventDispatcher, lazyEventsProcessedForComponentClass);
      }
      let proto = Object.getPrototypeOf(this);
      if (!lazyEventsProcessedForComponentClass.has(proto)) {
        let lazyEvents = eventDispatcher.lazyEvents;
        lazyEvents.forEach((mappedEventName, event) => {
          if (mappedEventName !== null && typeof this[mappedEventName] === "function") {
            eventDispatcher.setupHandlerForBrowserEvent(event);
          }
        });
        lazyEventsProcessedForComponentClass.add(proto);
      }
    }
    if (eventDispatcher && this.renderer._isInteractive && this.tagName === "") {
      let eventNames = [];
      let events = eventDispatcher.finalEventNameMapping;
      for (let key in events) {
        let methodName = events[key];
        if (methodName && typeof this[methodName] === "function") {
          eventNames.push(methodName);
        }
      }
      !!eventNames.length && assert(`You can not define \`${eventNames}\` function(s) to handle DOM event in the \`${this}\` tagless component since it doesn't have any DOM element.`, !eventNames.length);
    }
    !(descriptorForProperty(this, "classNameBindings") === void 0 && Array.isArray(this.classNameBindings)) && assert(`Only arrays are allowed for 'classNameBindings'`, descriptorForProperty(this, "classNameBindings") === void 0 && Array.isArray(this.classNameBindings));
    !(descriptorForProperty(this, "classNames") === void 0 && Array.isArray(this.classNames)) && assert(`Only arrays of static class strings are allowed for 'classNames'. For dynamic classes, use 'classNameBindings'.`, descriptorForProperty(this, "classNames") === void 0 && Array.isArray(this.classNames));
    !(descriptorForProperty(this, "elementId") === void 0) && assert(`You cannot use a computed property for the component's \`elementId\` (${this}).`, descriptorForProperty(this, "elementId") === void 0);
    !(descriptorForProperty(this, "tagName") === void 0) && assert(`You cannot use a computed property for the component's \`tagName\` (${this}).`, descriptorForProperty(this, "tagName") === void 0);
    if (!this.elementId && this.tagName !== "") {
      this.elementId = guidFor(this);
    }
  }
  __dispatcher;
  get _dispatcher() {
    if (this.__dispatcher === void 0) {
      let owner = getOwner(this);
      !owner && assert("Component is unexpectedly missing an owner", owner);
      if (owner.lookup("-environment:main").isInteractive) {
        let dispatcher = owner.lookup("event_dispatcher:main");
        !(dispatcher instanceof EventDispatcher) && assert("Expected dispatcher to be an EventDispatcher", dispatcher instanceof EventDispatcher);
        this.__dispatcher = dispatcher;
      } else {
        this.__dispatcher = null;
      }
    }
    return this.__dispatcher;
  }
  on(name, target, method) {
    this._dispatcher?.setupHandlerForEmberEvent(name);
    return super.on(name, target, method);
  }
  // Changed to `rerender` on init
  _rerender() {
    DIRTY_TAG(this[DIRTY_TAG2]);
    this._superRerender();
  }
  [PROPERTY_DID_CHANGE](key, value) {
    if (this[IS_DISPATCHING_ATTRS]) {
      return;
    }
    let args = this[ARGS];
    let reference = args !== void 0 ? args[key] : void 0;
    if (reference !== void 0 && isUpdatableRef(reference)) {
      updateRef(reference, arguments.length === 2 ? value : get2(this, key));
    }
  }
  getAttr(key) {
    return this.get(key);
  }
  /**
    Normally, Ember's component model is "write-only". The component takes a
    bunch of attributes that it got passed in, and uses them to render its
    template.
     One nice thing about this model is that if you try to set a value to the
    same thing as last time, Ember (through HTMLBars) will avoid doing any
    work on the DOM.
     This is not just a performance optimization. If an attribute has not
    changed, it is important not to clobber the element's "hidden state".
    For example, if you set an input's `value` to the same value as before,
    it will clobber selection state and cursor position. In other words,
    setting an attribute is not **always** idempotent.
     This method provides a way to read an element's attribute and also
    update the last value Ember knows about at the same time. This makes
    setting an attribute idempotent.
     In particular, what this means is that if you get an `<input>` element's
    `value` attribute and then re-render the template with the same value,
    it will avoid clobbering the cursor and selection position.
    Since most attribute sets are idempotent in the browser, you typically
    can get away with reading attributes using jQuery, but the most reliable
    way to do so is through this method.
    @method readDOMAttr
     @param {String} name the name of the attribute
    @return String
    @public
    */
  readDOMAttr(name) {
    let _element = getViewElement(this);
    !(_element !== null) && assert(`Cannot call \`readDOMAttr\` on ${this} which does not have an element`, _element !== null);
    let element = _element;
    let isSVG = element.namespaceURI === "http://www.w3.org/2000/svg";
    let {
      type,
      normalized
    } = normalizeProperty(element, name);
    if (isSVG || type === "attr") {
      return element.getAttribute(normalized);
    }
    return element[normalized];
  }
  // --- Declarations which support mixins ---
  // We use `declare` on these properties, even though they are optional, so
  // that they do not get created on the class *at all* when emitting the
  // transpiled code. Otherwise, since declared class properties are equivalent
  // to calling `defineProperty` in the class constructor, they would "stomp"
  // the properties supplied by mixins.
  /**
   A list of properties of the view to apply as attributes. If the property
   is a string value, the value of that string will be applied as the value
   for an attribute of the property's name.
    The following example creates a tag like `<div priority="high" />`.
    ```app/components/my-component.js
   import Component from '@ember/component';
    export default Component.extend({
      attributeBindings: ['priority'],
      priority: 'high'
    });
   ```
    If the value of the property is a Boolean, the attribute is treated as
   an HTML Boolean attribute. It will be present if the property is `true`
   and omitted if the property is `false`.
    The following example creates markup like `<div visible />`.
    ```app/components/my-component.js
   import Component from '@ember/component';
    export default Component.extend({
      attributeBindings: ['visible'],
      visible: true
    });
   ```
    If you would prefer to use a custom value instead of the property name,
   you can create the same markup as the last example with a binding like
   this:
    ```app/components/my-component.js
   import Component from '@ember/component';
    export default Component.extend({
      attributeBindings: ['isVisible:visible'],
      isVisible: true
    });
   ```
    This list of attributes is inherited from the component's superclasses,
   as well.
    @property attributeBindings
   @type Array
   @default []
   @public
   */
  /**
   Enables components to take a list of parameters as arguments.
    For example, a component that takes two parameters with the names
    `name` and `age`:
     ```app/components/my-component.js
    import Component from '@ember/component';
     export default class MyComponent extends Component {
      static positionalParams = ['name', 'age'];
    }
    ```
     It can then be invoked like this:
     ```hbs
    {{my-component "John" 38}}
    ```
     The parameters can be referred to just like named parameters:
     ```hbs
    Name: {{name}}, Age: {{age}}.
    ```
     Using a string instead of an array allows for an arbitrary number of
    parameters:
     ```app/components/my-component.js
    import Component from '@ember/component';
     export default class MyComponent extends Component {
      static positionalParams = 'names';
    }
    ```
     It can then be invoked like this:
     ```hbs
    {{my-component "John" "Michael" "Scott"}}
    ```
    The parameters can then be referred to by enumerating over the list:
     ```hbs
    {{#each names as |name|}}{{name}}{{/each}}
    ```
     @static
    @public
    @property positionalParams
    @since 1.13.0
    */
  /**
  Enables components to take a list of parameters as arguments.
  For example, a component that takes two parameters with the names
  `name` and `age`:
  ```app/components/my-component.js
  import Component from '@ember/component';
  export default class MyComponent extends Component {
  static positionalParams = ['name', 'age'];
  }
  ```
  It can then be invoked like this:
  ```hbs
  {{my-component "John" 38}}
  ```
  The parameters can be referred to just like named parameters:
  ```hbs
  Name: {{name}}, Age: {{age}}.
  ```
  Using a string instead of an array allows for an arbitrary number of
  parameters:
  ```app/components/my-component.js
  import Component from '@ember/component';
  export default class MyComponent extends Component {
  static positionalParams = 'names';
  }
  ```
  It can then be invoked like this:
  ```hbs
  {{my-component "John" "Michael" "Scott"}}
  ```
  The parameters can then be referred to by enumerating over the list:
  ```hbs
  {{#each names as |name|}}{{name}}{{/each}}
  ```
  @static
  @public
  @property positionalParams
  @since 1.13.0
  */
  /**
    Layout can be used to wrap content in a component.
    @property layout
    @type Function
    @public
  */
  /**
    The name of the layout to lookup if no layout is provided.
    By default `Component` will lookup a template with this name in
    `Ember.TEMPLATES` (a shared global object).
    @property layoutName
    @type String
    @default undefined
    @private
  */
  /**
   The WAI-ARIA role of the control represented by this view. For example, a
    button may have a role of type 'button', or a pane may have a role of
    type 'alertdialog'. This property is used by assistive software to help
    visually challenged users navigate rich web applications.
     The full list of valid WAI-ARIA roles is available at:
    [https://www.w3.org/TR/wai-aria/#roles_categorization](https://www.w3.org/TR/wai-aria/#roles_categorization)
     @property ariaRole
    @type String
    @default undefined
    @public
    */
  /**
    Array of child views. You should never edit this array directly.
     @property childViews
    @type Array
    @default []
    @private
  */
  // @ts-expect-error TODO: Fix these types
  get childViews() {
    return getChildViews(this);
  }
  appendChild(view) {
    addChildView(this, view);
  }
  _transitionTo(state) {
    let priorState = this._currentState;
    let currentState = this._currentState = this._states[state];
    this._state = state;
    if (priorState && priorState.exit) {
      priorState.exit(this);
    }
    if (currentState.enter) {
      currentState.enter(this);
    }
  }
  // Begin ViewMixin
  // ..........................................................
  // TEMPLATE SUPPORT
  //
  /**
   Return the nearest ancestor that is an instance of the provided
   class or mixin.
    @method nearestOfType
   @param {Class,Mixin} klass Subclass of Ember.View (or Ember.View itself),
   or an instance of Mixin.
   @return Ember.View
   @deprecated use `yield` and contextual components for composition instead.
   @private
   */
  nearestOfType(klass) {
    let view = this.parentView;
    while (view) {
      if (klass.detect(view.constructor)) {
        return view;
      }
      view = view.parentView;
    }
    return;
  }
  /**
   Return the nearest ancestor that has a given property.
    @method nearestWithProperty
   @param {String} property A property name
   @return Ember.View
   @deprecated use `yield` and contextual components for composition instead.
   @private
   */
  nearestWithProperty(property) {
    let view = this.parentView;
    while (view) {
      if (property in view) {
        return view;
      }
      view = view.parentView;
    }
    return;
  }
  /**
   Renders the view again. This will work regardless of whether the
   view is already in the DOM or not. If the view is in the DOM, the
   rendering process will be deferred to give bindings a chance
   to synchronize.
    If children were added during the rendering process using `appendChild`,
   `rerender` will remove them, because they will be added again
   if needed by the next `render`.
    In general, if the display of your view changes, you should modify
   the DOM element directly instead of manually calling `rerender`, which can
   be slow.
    @method rerender
   @public
   */
  rerender() {
    return this._currentState.rerender(this);
  }
  // ..........................................................
  // ELEMENT SUPPORT
  //
  /**
   Returns the current DOM element for the view.
     @property element
    @type DOMElement
    @public
  */
  // @ts-expect-error The types are not correct here
  get element() {
    return this.renderer.getElement(this);
  }
  appendTo(selector) {
    let target;
    if (hasDOM) {
      !(typeof selector === "string" || selector instanceof Element) && assert(`Expected a selector or instance of Element`, typeof selector === "string" || selector instanceof Element);
      target = typeof selector === "string" ? document.querySelector(selector) : selector;
      !target && assert(`You tried to append to (${selector}) but that isn't in the DOM`, target);
      !!matches(target, ".ember-view") && assert("You cannot append to an existing Ember.View.", !matches(target, ".ember-view"));
      !(() => {
        let node = target.parentNode;
        while (node instanceof Element) {
          if (matches(node, ".ember-view")) {
            return false;
          }
          node = node.parentNode;
        }
        return true;
      })() && assert("You cannot append to an existing Ember.View.", (() => {
        let node = target.parentNode;
        while (node instanceof Element) {
          if (matches(node, ".ember-view")) {
            return false;
          }
          node = node.parentNode;
        }
        return true;
      })());
    } else {
      target = selector;
      !(typeof target !== "string") && assert(`You tried to append to a selector string (${selector}) in an environment without a DOM`, typeof target !== "string");
      !(typeof target.appendChild === "function") && assert(`You tried to append to a non-Element (${selector}) in an environment without a DOM`, typeof target.appendChild === "function");
    }
    this.renderer.appendTo(this, target);
    return this;
  }
  /**
   Appends the view's element to the document body. If the view does
   not have an HTML representation yet
   the element will be generated automatically.
    If your application uses the `rootElement` property, you must append
   the view within that element. Rendering views outside of the `rootElement`
   is not supported.
    Note that this method just schedules the view to be appended; the DOM
   element will not be appended to the document body until all bindings have
   finished synchronizing.
    @method append
   @return {Ember.View} receiver
   @private
   */
  append() {
    return this.appendTo(document.body);
  }
  /**
   The HTML `id` of the view's element in the DOM. You can provide this
   value yourself but it must be unique (just as in HTML):
    ```handlebars
   {{my-component elementId="a-really-cool-id"}}
   ```
    If not manually set a default value will be provided by the framework.
    Once rendered an element's `elementId` is considered immutable and you
   should never change it. If you need to compute a dynamic value for the
   `elementId`, you should do this when the component or element is being
   instantiated:
    ```app/components/my-component.js
   import Component from '@ember/component';
    export default Component.extend({
      init() {
        this._super(...arguments);
        let index = this.get('index');
        this.set('elementId', 'component-id' + index);
      }
    });
   ```
    @property elementId
   @type String
   @public
   */
  /**
   Called when a view is going to insert an element into the DOM.
    @event willInsertElement
   @public
   */
  willInsertElement() {
    return this;
  }
  /**
   Called when the element of the view has been inserted into the DOM.
   Override this function to do any set up that requires an element
   in the document body.
    When a view has children, didInsertElement will be called on the
   child view(s) first and on itself afterwards.
    @event didInsertElement
   @public
   */
  didInsertElement() {
    return this;
  }
  /**
   Called when the view is about to rerender, but before anything has
   been torn down. This is a good opportunity to tear down any manual
   observers you have installed based on the DOM state
    @event willClearRender
   @public
   */
  willClearRender() {
    return this;
  }
  /**
   You must call `destroy` on a view to destroy the view (and all of its
   child views). This will remove the view from any parent node, then make
   sure that the DOM element managed by the view can be released by the
   memory manager.
    @method destroy
   @private
   */
  destroy() {
    super.destroy();
    this._currentState.destroy(this);
    return this;
  }
  /**
   Called when the element of the view is going to be destroyed. Override
   this function to do any teardown that requires an element, like removing
   event listeners.
    Please note: any property changes made during this event will have no
   effect on object observers.
    @event willDestroyElement
   @public
   */
  willDestroyElement() {
    return this;
  }
  /**
   Called after the element of the view is destroyed.
    @event willDestroyElement
   @public
   */
  didDestroyElement() {
    return this;
  }
  /**
   Called when the parentView property has changed.
    @event parentViewDidChange
   @private
   */
  parentViewDidChange() {
    return this;
  }
  // ..........................................................
  // STANDARD RENDER PROPERTIES
  //
  /**
   Tag name for the view's outer element. The tag name is only used when an
   element is first created. If you change the `tagName` for an element, you
   must destroy and recreate the view element.
    By default, the render buffer will use a `<div>` tag for views.
    If the tagName is `''`, the view will be tagless, with no outer element.
   Component properties that depend on the presence of an outer element, such
   as `classNameBindings` and `attributeBindings`, do not work with tagless
   components. Tagless components cannot implement methods to handle events,
   and their `element` property has a `null` value.
    @property tagName
   @type String
   @default null
   @public
   */
  // We leave this null by default so we can tell the difference between
  // the default case and a user-specified tag.
  // .......................................................
  // EVENT HANDLING
  //
  /**
   Handle events from `EventDispatcher`
    @method handleEvent
   @param eventName {String}
   @param evt {Event}
   @private
   */
  handleEvent(eventName, evt) {
    return this._currentState.handleEvent(this, eventName, evt);
  }
  static toString() {
    return "@ember/component";
  }
};
decorateMethodV2(_Component.prototype, "childViews", [nativeDescDecorator({
  configurable: false,
  enumerable: false
})]);
decorateMethodV2(_Component.prototype, "element", [nativeDescDecorator({
  configurable: false,
  enumerable: false
})]);
// End ViewMixin
__publicField(_Component, "isComponentFactory", true);
var Component = _Component;
Component.reopenClass({
  positionalParams: []
});
setInternalComponentManager(CURLY_COMPONENT_MANAGER, Component);
var RECOMPUTE_TAG = Symbol("RECOMPUTE_TAG");
var IS_CLASSIC_HELPER = Symbol("IS_CLASSIC_HELPER");
var Helper = class extends FrameworkObject {
  static isHelperFactory = true;
  static [IS_CLASSIC_HELPER] = true;
  // `packages/ember/index.js` was setting `Helper.helper`. This seems like
  // a bad idea and probably not something we want. We've moved that definition
  // here, but it should definitely be reviewed and probably removed.
  /** @deprecated */
  static helper = helper$1;
  // SAFETY: this is initialized in `init`, rather than `constructor`. It is
  // safe to `declare` like this *if and only if* nothing uses the constructor
  // directly in this class, since nothing else can run before `init`.
  // SAFETY: this has no runtime existence whatsoever; it is a "phantom type"
  // here to preserve the type param.
  init(properties) {
    super.init(properties);
    this[RECOMPUTE_TAG] = createTag();
    !this.compute && assert("expected compute to be defined", this.compute);
  }
  /**
    On a class-based helper, it may be useful to force a recomputation of that
    helpers value. This is akin to `rerender` on a component.
     For example, this component will rerender when the `currentUser` on a
    session service changes:
     ```app/helpers/current-user-email.js
    import Helper from '@ember/component/helper'
    import { service } from '@ember/service'
    import { observer } from '@ember/object'
     export default Helper.extend({
      session: service(),
       onNewUser: observer('session.currentUser', function() {
        this.recompute();
      }),
       compute() {
        return this.get('session.currentUser.email');
      }
    });
    ```
     @method recompute
    @public
    @since 1.13.0
  */
  recompute() {
    join(() => DIRTY_TAG(this[RECOMPUTE_TAG]));
  }
};
function isClassicHelper(obj) {
  return obj[IS_CLASSIC_HELPER] === true;
}
var ClassicHelperManager = class {
  capabilities = helperCapabilities("3.23", {
    hasValue: true,
    hasDestroyable: true
  });
  ownerInjection;
  constructor(owner) {
    let ownerInjection = {};
    setOwner(ownerInjection, owner);
    this.ownerInjection = ownerInjection;
  }
  createHelper(definition, args) {
    let instance = isFactoryManager(definition) ? definition.create() : definition.create(this.ownerInjection);
    !(function(instance2) {
      if (instance2 !== null && typeof instance2 === "object") {
        let cast = instance2;
        return typeof cast.compute === "function" && typeof cast.destroy === "function";
      }
      return false;
    })(instance) && assert("expected HelperInstance", (function(instance2) {
      if (instance2 !== null && typeof instance2 === "object") {
        let cast = instance2;
        return typeof cast.compute === "function" && typeof cast.destroy === "function";
      }
      return false;
    })(instance));
    return {
      instance,
      args
    };
  }
  getDestroyable({
    instance
  }) {
    return instance;
  }
  getValue({
    instance,
    args
  }) {
    let {
      positional,
      named
    } = args;
    let ret = instance.compute(positional, named);
    consumeTag(instance[RECOMPUTE_TAG]);
    return ret;
  }
  getDebugName(definition) {
    return getDebugName$1((definition.class || definition)["prototype"]);
  }
};
function isFactoryManager(obj) {
  return obj != null && "class" in obj;
}
setHelperManager((owner) => {
  return new ClassicHelperManager(owner);
}, Helper);
var CLASSIC_HELPER_MANAGER = getInternalHelperManager(Helper);
var Wrapper = class {
  isHelperFactory = true;
  constructor(compute) {
    this.compute = compute;
  }
  create() {
    return {
      compute: this.compute
    };
  }
};
var SimpleClassicHelperManager = class {
  capabilities = helperCapabilities("3.23", {
    hasValue: true
  });
  createHelper(definition, args) {
    return () => definition.compute.call(null, args.positional, args.named);
  }
  getValue(fn2) {
    return fn2();
  }
  getDebugName(definition) {
    return getDebugName$1(definition.compute);
  }
};
var SIMPLE_CLASSIC_HELPER_MANAGER = new SimpleClassicHelperManager();
setHelperManager(() => SIMPLE_CLASSIC_HELPER_MANAGER, Wrapper.prototype);
function helper$1(helperFn) {
  return new Wrapper(helperFn);
}
var isHTMLSafe = isTrustedHTML;
function isTrustedHTML(str) {
  return (
    // SAFETY: cast `as SafeString` only present to make this check "legal"; we
    // can further improve this by changing the behavior to do an `in` check
    // instead, but that's worth landing as a separate change for bisecting if
    // it happens to have an impact on e.g. perf.
    str !== null && typeof str === "object" && typeof str.toHTML === "function"
  );
}
function instrumentationPayload$1(def) {
  return {
    object: `${def.name}:main`
  };
}
var CAPABILITIES$2 = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: false,
  attributeHook: false,
  elementHook: false,
  createCaller: false,
  dynamicScope: true,
  updateHook: false,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
var CAPABILITIES_MASK$1 = capabilityFlagsFrom(CAPABILITIES$2);
var OutletComponentManager = class {
  create(_owner, definition, _args, env, dynamicScope) {
    let parentStateRef = dynamicScope.get("outletState");
    let currentStateRef = definition.ref;
    dynamicScope.set("outletState", currentStateRef);
    let state = {
      finalize: _instrumentStart("render.outlet", instrumentationPayload$1, definition)
    };
    if (env.debugRenderTree !== void 0) {
      let parentState = valueForRef(parentStateRef);
      let parentOwner = parentState?.render?.owner;
      let currentState = valueForRef(currentStateRef);
      let currentOwner = currentState?.render?.owner;
      if (parentOwner && parentOwner !== currentOwner) {
        !(currentOwner instanceof EngineInstance) && assert("Expected currentOwner to be an EngineInstance", currentOwner instanceof EngineInstance);
        let {
          mountPoint
        } = currentOwner;
        if (mountPoint) {
          state.engine = {
            mountPoint,
            instance: currentOwner
          };
        }
      }
    }
    return state;
  }
  getDebugName({
    name
  }) {
    return `{{outlet}} for ${name}`;
  }
  getDebugCustomRenderTree(_definition, state) {
    let nodes = [];
    nodes.push({
      bucket: state,
      type: "outlet",
      // "main" used to be the outlet name, keeping it around for compatibility
      name: "main",
      args: EMPTY_ARGS,
      instance: void 0,
      template: void 0
    });
    if (state.engine) {
      nodes.push({
        bucket: state.engine,
        type: "engine",
        name: state.engine.mountPoint,
        args: EMPTY_ARGS,
        instance: state.engine.instance,
        template: void 0
      });
    }
    return nodes;
  }
  getCapabilities() {
    return CAPABILITIES$2;
  }
  getSelf() {
    return UNDEFINED_REFERENCE;
  }
  didCreate() {
  }
  didUpdate() {
  }
  didRenderLayout(state) {
    state.finalize();
  }
  didUpdateLayout() {
  }
  getDestroyable() {
    return null;
  }
};
var OUTLET_MANAGER = new OutletComponentManager();
var OUTLET_COMPONENT_TEMPLATE = templateFactory(
  /*
    <@Component @controller={{@controller}} @model={{@model}} />
  */
  {
    "id": "Hacwyo/Q",
    "block": '[[[8,[30,1],null,[["@controller","@model"],[[30,2],[30,3]]],null]],["@Component","@controller","@model"],[]]',
    "moduleName": "/home/runner/work/ember.js/ember.js/packages/@ember/-internals/glimmer/lib/component-managers/outlet.ts",
    "isStrictMode": true
  }
);
var OutletComponent = class {
  // handle is not used by this custom definition
  handle = -1;
  resolvedName = null;
  manager = OUTLET_MANAGER;
  capabilities = CAPABILITIES_MASK$1;
  compilable;
  constructor(owner, state) {
    this.state = state;
    this.compilable = unwrapTemplate(OUTLET_COMPONENT_TEMPLATE(owner)).asLayout();
  }
};
function createRootOutlet(outletView) {
  return new OutletComponent(outletView.owner, outletView.state);
}
var RootComponentManager = class extends CurlyComponentManager {
  component;
  constructor(component) {
    super();
    this.component = component;
  }
  create(_owner, _state, _args, {
    isInteractive
  }, dynamicScope) {
    let component = this.component;
    let finalizer = _instrumentStart("render.component", initialRenderInstrumentDetails, component);
    dynamicScope.view = component;
    let hasWrappedElement = component.tagName !== "";
    if (!hasWrappedElement) {
      if (isInteractive) {
        component.trigger("willRender");
      }
      component._transitionTo("hasElement");
      if (isInteractive) {
        component.trigger("willInsertElement");
      }
    }
    if (true) {
      processComponentInitializationAssertions(component, {});
    }
    let bucket = new ComponentStateBucket(component, null, CONSTANT_TAG, finalizer, hasWrappedElement, isInteractive);
    consumeTag(component[DIRTY_TAG2]);
    return bucket;
  }
};
var ROOT_CAPABILITIES = {
  dynamicLayout: true,
  dynamicTag: true,
  prepareArgs: false,
  createArgs: false,
  attributeHook: true,
  elementHook: true,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: true,
  willDestroy: false,
  hasSubOwner: false
};
var RootComponentDefinition = class {
  // handle is not used by this custom definition
  handle = -1;
  resolvedName = "-top-level";
  state;
  manager;
  capabilities = capabilityFlagsFrom(ROOT_CAPABILITIES);
  compilable = null;
  constructor(component) {
    this.manager = new RootComponentManager(component);
    let factory = getFactoryFor(component);
    !(factory !== void 0) && assert("missing factory for component", factory !== void 0);
    this.state = factory;
  }
};
function internalHelper(helper2) {
  return setInternalHelperManager(helper2, {});
}
var EachInWrapper = class {
  constructor(inner) {
    this.inner = inner;
  }
};
var eachIn = internalHelper(({
  positional
}) => {
  const inner = positional[0];
  !inner && assert("expected at least one positional arg", inner);
  return createComputeRef(() => {
    let iterable = valueForRef(inner);
    consumeTag(tagForObject(iterable));
    if (isProxy(iterable)) {
      iterable = contentFor(iterable);
    }
    return new EachInWrapper(iterable);
  });
});
function toIterator(iterable) {
  if (iterable instanceof EachInWrapper) {
    return toEachInIterator(iterable.inner);
  } else {
    return toEachIterator(iterable);
  }
}
function toEachInIterator(iterable) {
  if (!isIndexable(iterable)) {
    return null;
  }
  if (Array.isArray(iterable) || isEmberArray(iterable)) {
    return ObjectIterator.fromIndexable(iterable);
  } else if (isNativeIterable(iterable)) {
    return MapLikeNativeIterator.from(iterable);
  } else if (hasForEach(iterable)) {
    return ObjectIterator.fromForEachable(iterable);
  } else {
    return ObjectIterator.fromIndexable(iterable);
  }
}
function toEachIterator(iterable) {
  if (!isObject(iterable)) {
    return null;
  }
  if (Array.isArray(iterable)) {
    return ArrayIterator.from(iterable);
  } else if (isEmberArray(iterable)) {
    return EmberArrayIterator.from(iterable);
  } else if (isNativeIterable(iterable)) {
    return ArrayLikeNativeIterator.from(iterable);
  } else if (hasForEach(iterable)) {
    return ArrayIterator.fromForEachable(iterable);
  } else {
    return null;
  }
}
var BoundedIterator = class {
  position = 0;
  constructor(length) {
    this.length = length;
  }
  isEmpty() {
    return false;
  }
  memoFor(position) {
    return position;
  }
  next() {
    let {
      length,
      position
    } = this;
    if (position >= length) {
      return null;
    }
    let value = this.valueFor(position);
    let memo = this.memoFor(position);
    this.position++;
    return {
      value,
      memo
    };
  }
};
var ArrayIterator = class extends BoundedIterator {
  static from(iterable) {
    return iterable.length > 0 ? new this(iterable) : null;
  }
  static fromForEachable(object) {
    let array2 = [];
    object.forEach((item) => array2.push(item));
    return this.from(array2);
  }
  constructor(array2) {
    super(array2.length);
    this.array = array2;
  }
  valueFor(position) {
    return this.array[position];
  }
};
var EmberArrayIterator = class extends BoundedIterator {
  static from(iterable) {
    return iterable.length > 0 ? new this(iterable) : null;
  }
  constructor(array2) {
    super(array2.length);
    this.array = array2;
  }
  valueFor(position) {
    return objectAt(this.array, position);
  }
};
var ObjectIterator = class extends BoundedIterator {
  static fromIndexable(obj) {
    let keys = Object.keys(obj);
    if (keys.length === 0) {
      return null;
    } else {
      let values = [];
      for (let key of keys) {
        let value;
        value = obj[key];
        if (isTracking()) {
          consumeTag(tagFor(obj, key));
          if (Array.isArray(value)) {
            consumeTag(tagFor(value, "[]"));
          }
        }
        values.push(value);
      }
      return new this(keys, values);
    }
  }
  static fromForEachable(obj) {
    let keys = [];
    let values = [];
    let length = 0;
    let isMapLike = false;
    obj.forEach(function(value, key) {
      isMapLike = isMapLike || arguments.length >= 2;
      if (isMapLike) {
        keys.push(key);
      }
      values.push(value);
      length++;
    });
    if (length === 0) {
      return null;
    } else if (isMapLike) {
      return new this(keys, values);
    } else {
      return new ArrayIterator(values);
    }
  }
  constructor(keys, values) {
    super(values.length);
    this.keys = keys;
    this.values = values;
  }
  valueFor(position) {
    return this.values[position];
  }
  memoFor(position) {
    return this.keys[position];
  }
};
var NativeIterator = class {
  static from(iterable) {
    let iterator = iterable[Symbol.iterator]();
    let result = iterator.next();
    let {
      done
    } = result;
    if (done) {
      return null;
    } else {
      return new this(iterator, result);
    }
  }
  position = 0;
  constructor(iterable, result) {
    this.iterable = iterable;
    this.result = result;
  }
  isEmpty() {
    return false;
  }
  next() {
    let {
      iterable,
      result,
      position
    } = this;
    if (result.done) {
      return null;
    }
    let value = this.valueFor(result, position);
    let memo = this.memoFor(result, position);
    this.position++;
    this.result = iterable.next();
    return {
      value,
      memo
    };
  }
};
var ArrayLikeNativeIterator = class extends NativeIterator {
  valueFor(result) {
    return result.value;
  }
  memoFor(_result, position) {
    return position;
  }
};
var MapLikeNativeIterator = class extends NativeIterator {
  valueFor(result) {
    return result.value[1];
  }
  memoFor(result) {
    return result.value[0];
  }
};
function hasForEach(value) {
  return value != null && typeof value["forEach"] === "function";
}
function isNativeIterable(value) {
  return value != null && typeof value[Symbol.iterator] === "function";
}
function isIndexable(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
function toBool(predicate) {
  if (isProxy(predicate)) {
    consumeTag(tagForProperty(predicate, "content"));
    return Boolean(get2(predicate, "isTruthy"));
  } else if (isArray(predicate)) {
    consumeTag(tagForProperty(predicate, "[]"));
    return predicate.length !== 0;
  } else if (isHTMLSafe(predicate)) {
    return Boolean(predicate.toString());
  } else {
    return Boolean(predicate);
  }
}
setGlobalContext({
  scheduleRevalidate() {
    _backburner.ensureInstance();
  },
  toBool,
  toIterator,
  getProp: _getProp,
  setProp: _setProp,
  getPath: get2,
  setPath: set,
  scheduleDestroy(destroyable, destructor) {
    schedule("actions", null, destructor, destroyable);
  },
  scheduleDestroyed(finalizeDestructor) {
    schedule("destroy", null, finalizeDestructor);
  },
  warnIfStyleNotTrusted(value) {
    warn(constructStyleDeprecationMessage(String(value)), (() => {
      if (value === null || value === void 0 || isHTMLSafe(value)) {
        return true;
      }
      return false;
    })(), {
      id: "ember-htmlbars.style-xss-warning"
    });
  },
  assert(test, msg, options) {
    if (true) {
      let id = options?.id;
      let override = VM_ASSERTION_OVERRIDES.filter((o) => o.id === id)[0];
      !test && assert(override?.message ?? msg, test);
    }
  },
  deprecate(msg, test, options) {
    if (true) {
      let {
        id
      } = options;
      if (id === "argument-less-helper-paren-less-invocation") {
        throw new Error(`A resolved helper cannot be passed as a named argument as the syntax is ambiguously a pass-by-reference or invocation. Use the \`{{helper 'foo-helper}}\` helper to pass by reference or explicitly invoke the helper with parens: \`{{(fooHelper)}}\`.`);
      }
      let override = VM_DEPRECATION_OVERRIDES.filter((o) => o.id === id)[0];
      if (!override) throw new Error(`deprecation override for ${id} not found`);
      if (!override.disabled) {
        !Boolean(test) && deprecate(override.message ?? msg, Boolean(test), override);
      }
    }
  }
});
if (true) {
  debug?.setTrackingTransactionEnv?.({
    debugMessage(obj, keyName) {
      let dirtyString = keyName ? `\`${keyName}\` on \`${getDebugName$1?.(obj)}\`` : `\`${getDebugName$1?.(obj)}\``;
      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }
  });
}
var VM_DEPRECATION_OVERRIDES = [{
  id: "setting-on-hash",
  until: "4.4.0",
  for: "ember-source",
  since: {
    available: "3.28.0",
    enabled: "3.28.0"
  }
}];
var VM_ASSERTION_OVERRIDES = [];
var EmberEnvironmentDelegate = class {
  enableDebugTooling = ENV._DEBUG_RENDER_TREE;
  constructor(owner, isInteractive) {
    this.owner = owner;
    this.isInteractive = isInteractive;
  }
  onTransactionCommit() {
  }
};
var disallowDynamicResolution = internalHelper(({
  positional,
  named
}) => {
  const nameOrValueRef = positional[0];
  !(positional.length === 1 && nameOrValueRef) && assert(`[BUG] wrong number of positional arguments, expecting 1, got ${positional.length}`, positional.length === 1 && nameOrValueRef);
  let typeRef = named["type"];
  let locRef = named["loc"];
  let originalRef = named["original"];
  !typeRef && assert(`[BUG] expecting \`type\` named argument`, typeRef);
  !locRef && assert(`[BUG] expecting \`loc\` named argument`, locRef);
  !originalRef && assert(`[BUG] expecting \`original\` named argument`, originalRef);
  const type = valueForRef(typeRef);
  const loc = valueForRef(locRef);
  const original = valueForRef(originalRef);
  !(typeof type === "string") && assert("[BUG] expecting a string literal for the `type` argument", typeof type === "string");
  !(typeof loc === "string") && assert("[BUG] expecting a string literal for the `loc` argument", typeof loc === "string");
  !(typeof original === "string") && assert("[BUG] expecting a string literal for the `original` argument", typeof original === "string");
  return createComputeRef(() => {
    let nameOrValue = valueForRef(nameOrValueRef);
    !(typeof nameOrValue !== "string") && assert(`Passing a dynamic string to the \`(${type})\` keyword is disallowed. (You specified \`(${type} ${original})\` and \`${original}\` evaluated into "${nameOrValue}".) This ensures we can statically analyze the template and determine which ${type}s are used. If the ${type} name is always the same, use a string literal instead, i.e. \`(${type} "${nameOrValue}")\`. Otherwise, import the ${type}s into JavaScript and pass them directly. See https://github.com/emberjs/rfcs/blob/master/text/0496-handlebars-strict-mode.md#4-no-dynamic-resolution for details. ` + loc, typeof nameOrValue !== "string");
    return nameOrValue;
  });
});
var helper;
if (true) {
  helper = (args) => {
    const inner = args.positional[0];
    !inner && assert("expected at least one positional arg", inner);
    return createComputeRef(() => {
      let value = valueForRef(inner);
      !(value !== null && value !== void 0) && assert("You cannot pass a null or undefined destination element to in-element", value !== null && value !== void 0);
      return value;
    });
  };
} else {
  helper = (args) => {
    let arg = args.positional[0];
    !arg && assert("expected at least one positional arg", arg);
    return arg;
  };
}
var inElementNullCheckHelper = internalHelper(helper);
var normalizeClassHelper = internalHelper(({
  positional
}) => {
  return createComputeRef(() => {
    let classNameArg = positional[0];
    let valueArg = positional[1];
    !(classNameArg && valueArg) && assert("expected at least two positional args", classNameArg && valueArg);
    let classNameParts = valueForRef(classNameArg).split(".");
    let className = classNameParts[classNameParts.length - 1];
    !className && assert("has className", className);
    let value = valueForRef(valueArg);
    if (value === true) {
      return dasherize(className);
    } else if (!value && value !== 0) {
      return "";
    } else {
      return String(value);
    }
  });
});
var resolve = internalHelper(({
  positional
}, owner) => {
  !owner && assert("[BUG] missing owner", owner);
  !(positional.length === 1) && assert(`[BUG] wrong number of positional arguments, expecting 1, got ${positional.length}`, positional.length === 1);
  let fullNameRef = positional[0];
  !(fullNameRef && isConstRef(fullNameRef)) && assert("[BUG] expecting a string literal as argument", fullNameRef && isConstRef(fullNameRef));
  let fullName = valueForRef(fullNameRef);
  !(typeof fullName === "string") && assert("[BUG] expecting a string literal as argument", typeof fullName === "string");
  !((s) => s.split(":").length === 2)(fullName) && assert("[BUG] expecting a valid full name", ((s) => s.split(":").length === 2)(fullName));
  if (true) {
    let [type, name] = fullName.split(":");
    !owner.hasRegistration(fullName) && assert(`Attempted to invoke \`(-resolve "${fullName}")\`, but ${name} was not a valid ${type} name.`, owner.hasRegistration(fullName));
  }
  return createConstRef(owner.factoryFor(fullName)?.class, `(-resolve "${fullName}")`);
});
var trackArray = internalHelper(({
  positional
}) => {
  const inner = positional[0];
  !inner && assert("expected at least one positional arg", inner);
  return createComputeRef(() => {
    let iterable = valueForRef(inner);
    if (isObject(iterable)) {
      consumeTag(tagForProperty(iterable, "[]"));
    }
    return iterable;
  });
});
var mut = internalHelper(({
  positional
}) => {
  let ref = positional[0];
  !ref && assert("expected at least one positional arg", ref);
  !isUpdatableRef(ref) && assert("You can only pass a path to mut", isUpdatableRef(ref));
  return createInvokableRef(ref);
});
var readonly = internalHelper(({
  positional
}) => {
  let firstArg = positional[0];
  !firstArg && assert("has first arg", firstArg);
  return createReadOnlyRef(firstArg);
});
var unbound = internalHelper(({
  positional,
  named
}) => {
  !(positional.length === 1 && Object.keys(named).length === 0) && assert("unbound helper cannot be called with multiple params or hash params", positional.length === 1 && Object.keys(named).length === 0);
  return createUnboundRef(valueForRef(positional[0]), "(result of an `unbound` helper)");
});
var uniqueId = internalHelper(() => {
  return createConstRef(uniqueId$1(), "unique-id");
});
function uniqueId$1() {
  return ("30000000-1000-4000-2000" + -1e11).replace(/[0-3]/g, (a) => (a * 4 ^ Math.random() * 16 >> (a & 2)).toString(16));
}
var CAPABILITIES$1 = {
  dynamicLayout: true,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: true,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: true
};
var MountManager = class {
  getDynamicLayout(state) {
    let templateFactory2 = state.engine.lookup("template:application");
    return unwrapTemplate(templateFactory2(state.engine)).asLayout();
  }
  getCapabilities() {
    return CAPABILITIES$1;
  }
  getOwner(state) {
    return state.engine;
  }
  create(owner, {
    name
  }, args, env) {
    !(owner instanceof EngineInstance) && assert("Expected owner to be an EngineInstance", owner instanceof EngineInstance);
    let engine = owner.buildChildEngineInstance(name);
    engine.boot();
    let applicationFactory = engine.factoryFor(`controller:application`);
    let controllerFactory = applicationFactory || generateControllerFactory(engine, "application");
    let controller;
    let self;
    let bucket;
    let modelRef;
    if (args.named.has("model")) {
      modelRef = args.named.get("model");
    }
    if (modelRef === void 0) {
      controller = controllerFactory.create();
      self = createConstRef(controller, "this");
      bucket = {
        engine,
        controller,
        self,
        modelRef
      };
    } else {
      let model = valueForRef(modelRef);
      controller = controllerFactory.create({
        model
      });
      self = createConstRef(controller, "this");
      bucket = {
        engine,
        controller,
        self,
        modelRef
      };
    }
    if (env.debugRenderTree) {
      associateDestroyableChild(engine, controller);
    }
    return bucket;
  }
  getDebugName({
    name
  }) {
    return name;
  }
  getDebugCustomRenderTree(definition, state, args, templateModuleName) {
    return [{
      bucket: state.engine,
      instance: state.engine,
      type: "engine",
      name: definition.name,
      args
    }, {
      bucket: state.controller,
      instance: state.controller,
      type: "route-template",
      name: "application",
      args,
      template: templateModuleName
    }];
  }
  getSelf({
    self
  }) {
    return self;
  }
  getDestroyable(bucket) {
    return bucket.engine;
  }
  didCreate() {
  }
  didUpdate() {
  }
  didRenderLayout() {
  }
  didUpdateLayout() {
  }
  update(bucket) {
    let {
      controller,
      modelRef
    } = bucket;
    if (modelRef !== void 0) {
      controller.set("model", valueForRef(modelRef));
    }
  }
};
var MOUNT_MANAGER = new MountManager();
var MountDefinition = class {
  // handle is not used by this custom definition
  handle = -1;
  state;
  manager = MOUNT_MANAGER;
  compilable = null;
  capabilities = capabilityFlagsFrom(CAPABILITIES$1);
  constructor(resolvedName) {
    this.resolvedName = resolvedName;
    this.state = {
      name: resolvedName
    };
  }
};
var mountHelper = internalHelper((args, owner) => {
  !owner && assert("{{mount}} must be used within a component that has an owner", owner);
  let nameRef = args.positional[0];
  let captured;
  !(args.positional.length === 1) && assert('You can only pass a single positional argument to the {{mount}} helper, e.g. {{mount "chat-engine"}}.', args.positional.length === 1);
  if (args.named) {
    let keys = Object.keys(args.named);
    let extra = keys.filter((k) => k !== "model");
    !(extra.length === 0) && assert(`You can only pass a \`model\` argument to the {{mount}} helper, e.g. {{mount "profile-engine" model=this.profile}}. You passed ${extra.join(",")}.`, extra.length === 0);
  }
  captured = createCapturedArgs(args.named, EMPTY_POSITIONAL);
  let lastName, lastDef;
  return createComputeRef(() => {
    let name = valueForRef(nameRef);
    if (typeof name === "string") {
      if (lastName === name) {
        return lastDef;
      }
      !owner.hasRegistration(`engine:${name}`) && assert(`You used \`{{mount '${name}'}}\`, but the engine '${name}' can not be found.`, owner.hasRegistration(`engine:${name}`));
      lastName = name;
      lastDef = curry(0, new MountDefinition(name), owner, captured, true);
      return lastDef;
    } else {
      !(name === null || name === void 0) && assert(`Invalid engine name '${name}' specified, engine name must be either a string, null or undefined.`, name === null || name === void 0);
      lastDef = null;
      lastName = null;
      return null;
    }
  });
});
var CAPABILITIES = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: false,
  dynamicScope: false,
  updateHook: false,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
var CAPABILITIES_MASK = capabilityFlagsFrom(CAPABILITIES);
var RouteTemplateManager = class {
  create(_owner, _definition, args) {
    let self = args.named.get("controller");
    if (true) {
      self = createDebugAliasRef("this", self);
    }
    let controller = valueForRef(self);
    return {
      self,
      controller
    };
  }
  getSelf({
    self
  }) {
    return self;
  }
  getDebugName({
    name
  }) {
    return `route-template (${name})`;
  }
  getDebugCustomRenderTree({
    name,
    templateName
  }, state, args) {
    return [{
      bucket: state,
      type: "route-template",
      name,
      args,
      instance: state.controller,
      template: templateName
    }];
  }
  getCapabilities() {
    return CAPABILITIES;
  }
  didRenderLayout() {
  }
  didUpdateLayout() {
  }
  didCreate() {
  }
  didUpdate() {
  }
  getDestroyable() {
    return null;
  }
};
var ROUTE_TEMPLATE_MANAGER = new RouteTemplateManager();
var RouteTemplate = class {
  // handle is not used by this custom definition
  handle = -1;
  resolvedName;
  state;
  manager = ROUTE_TEMPLATE_MANAGER;
  capabilities = CAPABILITIES_MASK;
  compilable;
  constructor(name, template) {
    let unwrapped = unwrapTemplate(template);
    this.resolvedName = name;
    this.state = {
      name,
      templateName: unwrapped.moduleName
    };
    this.compilable = unwrapped.asLayout();
  }
};
function makeRouteTemplate(owner, name, template) {
  let routeTemplate = new RouteTemplate(name, template);
  return curry(0, routeTemplate, owner, null, true);
}
var outletHelper = internalHelper((_args, owner, scope) => {
  !owner && assert("Expected owner to be present, {{outlet}} requires an owner", owner);
  !scope && assert("Expected dynamic scope to be present. You may have attempted to use the {{outlet}} keyword dynamically. This keyword cannot be used dynamically.", scope);
  let outletRef = createComputeRef(() => {
    let state = valueForRef(scope.get("outletState"));
    return state?.outlets?.main;
  });
  let lastState = null;
  let outlet = null;
  return createComputeRef(() => {
    let outletState = valueForRef(outletRef);
    let state = stateFor(outletRef, outletState);
    if (!isStable(state, lastState)) {
      lastState = state;
      if (state !== null) {
        let outletOwner = outletState?.render?.owner ?? owner;
        let named = dict();
        let template = state.template;
        let component;
        if (hasInternalComponentManager(template)) {
          component = template;
        } else {
          if (true) {
            let isTemplate = (template2) => {
              if (template2 === null || typeof template2 !== "object") {
                return false;
              } else {
                let t = template2;
                return t.result === "ok" || t.result === "error";
              }
            };
            if (!isTemplate(template)) {
              let label;
              try {
                label = `\`${String(template)}\``;
              } catch {
                label = "an unknown object";
              }
              assert(`Failed to render the \`${state.name}\` route: expected a component or Template object, but got ${label}.`);
            }
          }
          component = makeRouteTemplate(outletOwner, state.name, template);
        }
        named["Component"] = createConstRef(component, "@Component");
        named["controller"] = createConstRef(state.controller, "@controller");
        let modelRef = childRefFromParts(outletRef, ["render", "model"]);
        let model = valueForRef(modelRef);
        named["model"] = createComputeRef(() => {
          if (lastState === state) {
            model = valueForRef(modelRef);
          }
          return model;
        });
        if (true) {
          named["model"] = createDebugAliasRef("@model", named["model"]);
        }
        let args = createCapturedArgs(named, EMPTY_POSITIONAL);
        outlet = curry(0, new OutletComponent(owner, state), outletOwner, args, true);
      } else {
        outlet = null;
      }
    }
    return outlet;
  });
});
function stateFor(ref, outlet) {
  if (outlet === void 0) return null;
  let render = outlet.render;
  if (render === void 0) return null;
  let template = render.template;
  if (template === void 0 || template === null) return null;
  return {
    ref,
    name: render.name,
    template,
    controller: render.controller
  };
}
function isStable(state, lastState) {
  if (state === null || lastState === null) {
    return false;
  }
  return state.template === lastState.template && state.controller === lastState.controller;
}
function instrumentationPayload(name) {
  return {
    object: `component:${name}`
  };
}
function componentFor(name, owner) {
  let fullName = `component:${name}`;
  return owner.factoryFor(fullName) || null;
}
function lookupComponentPair(owner, name) {
  let component = componentFor(name, owner);
  if (isFactory(component) && component.class) {
    let layout = getComponentTemplate(component.class);
    if (layout !== void 0) {
      return {
        component,
        layout
      };
    }
  }
  if (component === null) {
    return null;
  } else {
    return {
      component,
      layout: null
    };
  }
}
var BUILTIN_KEYWORD_HELPERS = {
  mut,
  readonly,
  unbound,
  "-hash": hash,
  "-each-in": eachIn,
  "-normalize-class": normalizeClassHelper,
  "-resolve": resolve,
  "-track-array": trackArray,
  "-mount": mountHelper,
  "-outlet": outletHelper,
  "-in-el-null": inElementNullCheckHelper
};
var BUILTIN_HELPERS = {
  ...BUILTIN_KEYWORD_HELPERS,
  array,
  concat,
  fn,
  get,
  hash,
  "unique-id": uniqueId
};
if (true) {
  BUILTIN_HELPERS["-disallow-dynamic-resolution"] = disallowDynamicResolution;
} else {
  BUILTIN_HELPERS["-disallow-dynamic-resolution"] = disallowDynamicResolution;
}
var BUILTIN_KEYWORD_MODIFIERS = {};
var BUILTIN_MODIFIERS = {
  ...BUILTIN_KEYWORD_MODIFIERS,
  on
};
var CLASSIC_HELPER_MANAGER_ASSOCIATED = /* @__PURE__ */ new WeakSet();
var ResolverImpl = class {
  componentDefinitionCache = /* @__PURE__ */ new Map();
  lookupPartial() {
    return null;
  }
  lookupHelper(name, owner) {
    !!(BUILTIN_HELPERS[name] && owner.hasRegistration(`helper:${name}`)) && assert(`You attempted to overwrite the built-in helper "${name}" which is not allowed. Please rename the helper.`, !(BUILTIN_HELPERS[name] && owner.hasRegistration(`helper:${name}`)));
    let helper2 = BUILTIN_HELPERS[name];
    if (helper2 !== void 0) {
      return helper2;
    }
    let factory = owner.factoryFor(`helper:${name}`);
    if (factory === void 0) {
      return null;
    }
    let definition = factory.class;
    if (definition === void 0) {
      return null;
    }
    if (typeof definition === "function" && isClassicHelper(definition)) {
      if (true) {
        if (!CLASSIC_HELPER_MANAGER_ASSOCIATED.has(factory)) {
          CLASSIC_HELPER_MANAGER_ASSOCIATED.add(factory);
          setInternalHelperManager(CLASSIC_HELPER_MANAGER, factory);
        }
      } else {
        setInternalHelperManager(CLASSIC_HELPER_MANAGER, factory);
      }
      return factory;
    }
    return definition;
  }
  lookupBuiltInHelper(name) {
    return BUILTIN_KEYWORD_HELPERS[name] ?? null;
  }
  lookupModifier(name, owner) {
    let builtin = BUILTIN_MODIFIERS[name];
    if (builtin !== void 0) {
      return builtin;
    }
    let modifier = owner.factoryFor(`modifier:${name}`);
    if (modifier === void 0) {
      return null;
    }
    return modifier.class || null;
  }
  lookupBuiltInModifier(name) {
    return BUILTIN_KEYWORD_MODIFIERS[name] ?? null;
  }
  lookupComponent(name, owner) {
    let pair = lookupComponentPair(owner, name);
    if (pair === null) {
      !(name !== "text-area") && assert("Could not find component `<TextArea />` (did you mean `<Textarea />`?)", name !== "text-area");
      return null;
    }
    let template = null;
    let key;
    if (pair.component === null) {
      key = template = pair.layout(owner);
    } else {
      key = pair.component;
    }
    let cachedComponentDefinition = this.componentDefinitionCache.get(key);
    if (cachedComponentDefinition !== void 0) {
      return cachedComponentDefinition;
    }
    if (template === null && pair.layout !== null) {
      template = pair.layout(owner);
    }
    let finalizer = _instrumentStart("render.getComponentDefinition", instrumentationPayload, name);
    let definition = null;
    if (pair.component === null) {
      definition = {
        state: templateOnlyComponent(void 0, name),
        manager: TEMPLATE_ONLY_COMPONENT_MANAGER,
        template
      };
    } else {
      let factory = pair.component;
      !(factory.class !== void 0) && assert(`missing component class ${name}`, factory.class !== void 0);
      let ComponentClass = factory.class;
      let manager = getInternalComponentManager(ComponentClass);
      definition = {
        state: isCurlyManager(manager) ? factory : ComponentClass,
        manager,
        template
      };
    }
    finalizer();
    this.componentDefinitionCache.set(key, definition);
    !!(definition === null && name === "text-area") && assert("Could not find component `<TextArea />` (did you mean `<Textarea />`?)", !(definition === null && name === "text-area"));
    return definition;
  }
};
var TOP_LEVEL_NAME = "-top-level";
var OutletView = class _OutletView {
  static extend(injections) {
    return class extends _OutletView {
      static create(options) {
        if (options) {
          return super.create(Object.assign({}, injections, options));
        } else {
          return super.create(injections);
        }
      }
    };
  }
  static reopenClass(injections) {
    Object.assign(this, injections);
  }
  static create(options) {
    let {
      environment: _environment,
      application: namespace,
      template: templateFactory2
    } = options;
    let owner = getOwner(options);
    !owner && assert("OutletView is unexpectedly missing an owner", owner);
    let template = templateFactory2(owner);
    return new _OutletView(_environment, owner, template, namespace);
  }
  ref;
  state;
  constructor(_environment, owner, template, namespace) {
    this._environment = _environment;
    this.owner = owner;
    this.template = template;
    this.namespace = namespace;
    let outletStateTag = createTag();
    let outletState = {
      outlets: {
        main: void 0
      },
      render: {
        owner,
        name: TOP_LEVEL_NAME,
        controller: void 0,
        model: void 0,
        template
      }
    };
    let ref = this.ref = createComputeRef(() => {
      consumeTag(outletStateTag);
      return outletState;
    }, (state) => {
      DIRTY_TAG(outletStateTag);
      outletState.outlets["main"] = state;
    });
    this.state = {
      ref,
      name: TOP_LEVEL_NAME,
      template,
      controller: void 0
    };
  }
  appendTo(selector) {
    let target;
    if (this._environment.hasDOM) {
      target = typeof selector === "string" ? document.querySelector(selector) : selector;
    } else {
      target = selector;
    }
    let renderer = this.owner.lookup("renderer:-dom");
    schedule("render", renderer, "appendOutletView", this, target);
  }
  rerender() {
  }
  setOutletState(state) {
    updateRef(this.ref, state);
  }
  destroy() {
  }
};
var DynamicScope = class _DynamicScope {
  constructor(view, outletState) {
    this.view = view;
    this.outletState = outletState;
  }
  child() {
    return new _DynamicScope(this.view, this.outletState);
  }
  get(key) {
    !(key === "outletState") && assert(`Using \`-get-dynamic-scope\` is only supported for \`outletState\` (you used \`${key}\`).`, key === "outletState");
    return this.outletState;
  }
  set(key, value) {
    !(key === "outletState") && assert(`Using \`-with-dynamic-scope\` is only supported for \`outletState\` (you used \`${key}\`).`, key === "outletState");
    this.outletState = value;
    return value;
  }
};
var NO_OP = () => {
};
function errorLoopTransaction(fn2) {
  if (true) {
    return () => {
      let didError = true;
      try {
        fn2();
        didError = false;
      } finally {
        if (didError) {
          fn2 = () => {
            console.warn("Attempted to rerender, but the Ember application has had an unrecoverable error occur during render. You should reload the application after fixing the cause of the error.");
          };
        }
      }
    };
  } else {
    return fn2;
  }
}
var ComponentRootState = class {
  type = "component";
  #result;
  #render;
  constructor(state, definition, options) {
    this.#render = errorLoopTransaction(() => {
      let iterator = renderComponent(state.context, state.builder(state.env, options.into), state.owner, definition, options?.args);
      let result = this.#result = iterator.sync();
      associateDestroyableChild(this, this.#result);
      this.#render = errorLoopTransaction(() => {
        if (isDestroying(result) || isDestroyed(result)) return;
        return result.rerender({
          alwaysRevalidate: false
        });
      });
    });
  }
  isFor(_component) {
    return false;
  }
  render() {
    this.#render();
  }
  destroy() {
    destroy(this);
  }
  get destroyed() {
    return isDestroyed(this);
  }
  get result() {
    return this.#result;
  }
};
var ClassicRootState = class {
  type = "classic";
  id;
  result;
  destroyed;
  render;
  env;
  constructor(root, context, owner, template, self, parentElement, dynamicScope, builder) {
    this.root = root;
    !(template !== void 0) && assert(`You cannot render \`${valueForRef(self)}\` without a template.`, template !== void 0);
    this.id = root instanceof OutletView ? guidFor(root) : getViewId(root);
    this.result = void 0;
    this.destroyed = false;
    this.env = context.env;
    this.render = errorLoopTransaction(() => {
      let layout = unwrapTemplate(template).asLayout();
      let iterator = renderMain(context, owner, self, builder(context.env, {
        element: parentElement,
        nextSibling: null
      }), layout, dynamicScope);
      let result = this.result = iterator.sync();
      associateDestroyableChild(owner, result);
      this.render = errorLoopTransaction(() => {
        if (isDestroying(result) || isDestroyed(result)) return;
        return result.rerender({
          alwaysRevalidate: false
        });
      });
    });
  }
  isFor(possibleRoot) {
    return this.root === possibleRoot;
  }
  destroy() {
    let {
      result,
      env
    } = this;
    this.destroyed = true;
    this.root = null;
    this.result = void 0;
    this.render = void 0;
    if (result !== void 0) {
      inTransaction(env, () => destroy(result));
    }
  }
};
var renderers = [];
function register(renderer) {
  !(renderers.indexOf(renderer) === -1) && assert("Cannot register the same renderer twice", renderers.indexOf(renderer) === -1);
  renderers.push(renderer);
}
function deregister(renderer) {
  let index = renderers.indexOf(renderer);
  !(index !== -1) && assert("Cannot deregister unknown unregistered renderer", index !== -1);
  renderers.splice(index, 1);
}
function loopBegin() {
  for (let renderer of renderers) {
    renderer.rerender();
  }
}
var renderSettledDeferred = null;
function renderSettled() {
  if (renderSettledDeferred === null) {
    renderSettledDeferred = RSVP.defer();
    if (!_getCurrentRunLoop()) {
      _backburner.schedule("actions", null, NO_OP);
    }
  }
  return renderSettledDeferred.promise;
}
function resolveRenderPromise() {
  if (renderSettledDeferred !== null) {
    let resolve2 = renderSettledDeferred.resolve;
    renderSettledDeferred = null;
    _backburner.join(null, resolve2);
  }
}
var loops = 0;
function loopEnd() {
  for (let renderer of renderers) {
    if (!renderer.isValid()) {
      if (loops > ENV._RERENDER_LOOP_LIMIT) {
        loops = 0;
        renderer.destroy();
        throw new Error("infinite rendering invalidation detected");
      }
      loops++;
      return _backburner.join(null, NO_OP);
    }
  }
  loops = 0;
  resolveRenderPromise();
}
_backburner.on("begin", loopBegin);
_backburner.on("end", loopEnd);
var RendererState = class _RendererState {
  static create(data, renderer) {
    const state = new _RendererState(data, renderer);
    associateDestroyableChild(renderer, state);
    return state;
  }
  #data;
  #lastRevision = -1;
  #inRenderTransaction = false;
  #destroyed = false;
  #roots = [];
  #removedRoots = [];
  constructor(data, renderer) {
    this.#data = data;
    registerDestructor(this, () => {
      this.clearAllRoots(renderer);
    });
  }
  get debug() {
    return {
      roots: this.#roots,
      inRenderTransaction: this.#inRenderTransaction,
      isInteractive: this.isInteractive
    };
  }
  get roots() {
    return this.#roots;
  }
  get owner() {
    return this.#data.owner;
  }
  get builder() {
    return this.#data.builder;
  }
  get context() {
    return this.#data.context;
  }
  get env() {
    return this.context.env;
  }
  get isInteractive() {
    return this.#data.context.env.isInteractive;
  }
  renderRoot(root, renderer) {
    let roots = this.#roots;
    roots.push(root);
    associateDestroyableChild(this, root);
    if (roots.length === 1) {
      register(renderer);
    }
    this.#renderRootsTransaction(renderer);
    return root;
  }
  #renderRootsTransaction(renderer) {
    if (this.#inRenderTransaction) {
      return;
    }
    this.#inRenderTransaction = true;
    let completedWithoutError = false;
    try {
      this.renderRoots(renderer);
      completedWithoutError = true;
    } finally {
      if (!completedWithoutError) {
        this.#lastRevision = valueForTag(CURRENT_TAG);
      }
      this.#inRenderTransaction = false;
    }
  }
  renderRoots(renderer) {
    let roots = this.#roots;
    let removedRoots = this.#removedRoots;
    let initialRootsLength;
    do {
      initialRootsLength = roots.length;
      inTransaction(this.context.env, () => {
        for (let i = 0; i < roots.length; i++) {
          let root = roots[i];
          !root && assert("has root", root);
          if (root.destroyed) {
            removedRoots.push(root);
            continue;
          }
          if (i >= initialRootsLength) {
            continue;
          }
          root.render();
        }
        this.#lastRevision = valueForTag(CURRENT_TAG);
      });
    } while (roots.length > initialRootsLength);
    while (removedRoots.length) {
      let root = removedRoots.pop();
      let rootIndex = roots.indexOf(root);
      roots.splice(rootIndex, 1);
    }
    if (this.#roots.length === 0) {
      deregister(renderer);
    }
  }
  scheduleRevalidate(renderer) {
    _backburner.scheduleOnce("render", this, this.revalidate, renderer);
  }
  isValid() {
    return this.#destroyed || this.#roots.length === 0 || validateTag(CURRENT_TAG, this.#lastRevision);
  }
  revalidate(renderer) {
    if (this.isValid()) {
      return;
    }
    this.#renderRootsTransaction(renderer);
  }
  clearAllRoots(renderer) {
    let roots = this.#roots;
    for (let root of roots) {
      destroy(root);
    }
    this.#removedRoots.length = 0;
    this.#roots = [];
    if (roots.length) {
      deregister(renderer);
    }
  }
};
function intoTarget(into) {
  if ("element" in into) {
    return into;
  } else {
    return {
      element: into,
      nextSibling: null
    };
  }
}
var BaseRenderer = class _BaseRenderer {
  static strict(owner, document2, options) {
    return new _BaseRenderer(owner, {
      hasDOM,
      ...options
    }, document2, new ResolverImpl(), clientBuilder);
  }
  state;
  constructor(owner, envOptions, document2, resolver, builder) {
    let sharedArtifacts = artifacts();
    let env = new EmberEnvironmentDelegate(owner, envOptions.isInteractive);
    let options = runtimeOptions({
      document: document2
    }, env, sharedArtifacts, resolver);
    let context = new EvaluationContextImpl(sharedArtifacts, (heap) => new RuntimeOpImpl(heap), options);
    this.state = RendererState.create({
      owner,
      context,
      builder
    }, this);
  }
  get debugRenderTree() {
    let {
      debugRenderTree
    } = this.state.env;
    !debugRenderTree && assert("Attempted to access the DebugRenderTree, but it did not exist. Is the Ember Inspector open?", debugRenderTree);
    return debugRenderTree;
  }
  isValid() {
    return this.state.isValid();
  }
  destroy() {
    destroy(this);
  }
  render(component, options) {
    const root = new ComponentRootState(this.state, component, {
      args: options.args,
      into: intoTarget(options.into)
    });
    return this.state.renderRoot(root, this);
  }
  rerender() {
    this.state.scheduleRevalidate(this);
  }
  // render(component: Component, options: { into: Cursor; args?: Record<string, unknown> }): void {
  //   this.state.renderRoot(component);
  // }
};
var Renderer = class extends BaseRenderer {
  static strict(owner, document2, options) {
    return new BaseRenderer(owner, {
      hasDOM,
      ...options
    }, document2, new ResolverImpl(), clientBuilder);
  }
  _rootTemplate;
  _viewRegistry;
  static create(props) {
    let {
      _viewRegistry
    } = props;
    let owner = getOwner(props);
    !owner && assert("Renderer is unexpectedly missing an owner", owner);
    let document2 = owner.lookup("service:-document");
    let env = owner.lookup("-environment:main");
    let rootTemplate = owner.lookup(privatize`template:-root`);
    let builder = owner.lookup("service:-dom-builder");
    return new this(owner, document2, env, rootTemplate, _viewRegistry, builder);
  }
  constructor(owner, document2, env, rootTemplate, viewRegistry, builder = clientBuilder, resolver = new ResolverImpl()) {
    super(owner, env, document2, resolver, builder);
    this._rootTemplate = rootTemplate(owner);
    this._viewRegistry = viewRegistry || owner.lookup("-view-registry:main");
  }
  // renderer HOOKS
  appendOutletView(view, target) {
    let outlet = createRootOutlet(view);
    let {
      name,
      /* controller, */
      template
    } = view.state;
    let named = dict();
    named["Component"] = createConstRef(makeRouteTemplate(view.owner, name, template), "@Component");
    named["controller"] = UNDEFINED_REFERENCE;
    named["model"] = UNDEFINED_REFERENCE;
    let args = createCapturedArgs(named, EMPTY_POSITIONAL);
    this._appendDefinition(view, curry(0, outlet, view.owner, args, true), target);
  }
  appendTo(view, target) {
    let definition = new RootComponentDefinition(view);
    this._appendDefinition(view, curry(0, definition, this.state.owner, null, true), target);
  }
  _appendDefinition(root, definition, target) {
    let self = createConstRef(definition, "this");
    let dynamicScope = new DynamicScope(null, UNDEFINED_REFERENCE);
    let rootState = new ClassicRootState(root, this.state.context, this.state.owner, this._rootTemplate, self, target, dynamicScope, this.state.builder);
    this.state.renderRoot(rootState, this);
  }
  cleanupRootFor(component) {
    if (isDestroyed(this)) {
      return;
    }
    let roots = this.state.roots;
    let i = roots.length;
    while (i--) {
      let root = roots[i];
      !root && assert("has root", root);
      if (root.type === "classic" && root.isFor(component)) {
        root.destroy();
        roots.splice(i, 1);
      }
    }
  }
  remove(view) {
    view._transitionTo("destroying");
    this.cleanupRootFor(view);
    if (this.state.isInteractive) {
      view.trigger("didDestroyElement");
    }
  }
  get _roots() {
    return this.state.debug.roots;
  }
  get _inRenderTransaction() {
    return this.state.debug.inRenderTransaction;
  }
  get _isInteractive() {
    return this.state.debug.isInteractive;
  }
  get _context() {
    return this.state.context;
  }
  register(view) {
    let id = getViewId(view);
    !!this._viewRegistry[id] && assert("Attempted to register a view with an id already in use: " + id, !this._viewRegistry[id]);
    this._viewRegistry[id] = view;
  }
  unregister(view) {
    delete this._viewRegistry[getViewId(view)];
  }
  getElement(component) {
    if (this._isInteractive) {
      return getViewElement(component);
    } else {
      throw new Error("Accessing `this.element` is not allowed in non-interactive environments (such as FastBoot).");
    }
  }
  getBounds(component) {
    let bounds = component[BOUNDS];
    !bounds && assert("object passed to getBounds must have the BOUNDS symbol as a property", bounds);
    let parentElement = bounds.parentElement();
    let firstNode = bounds.firstNode();
    let lastNode = bounds.lastNode();
    return {
      parentElement,
      firstNode,
      lastNode
    };
  }
};
var OutletTemplate = templateFactory(
  /*
    {{component (outletHelper)}}
  */
  {
    "id": "tiXbzL5t",
    "block": '[[[46,[28,[32,0],null,null],null,null,null]],[],["component"]]',
    "moduleName": "packages/@ember/-internals/glimmer/lib/templates/outlet.hbs",
    "scope": () => [outletHelper],
    "isStrictMode": true
  }
);

export {
  dasherize,
  classify,
  EventDispatcher,
  RouterService,
  RoutingService,
  RootTemplate,
  Input,
  LinkTo,
  Textarea,
  Component,
  OutletView,
  renderSettled,
  Renderer,
  OutletTemplate
};
//# sourceMappingURL=chunk-QF4YHKGU.js.map
