{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/program/index.js", "../../../../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/runtime/index.js"],
  "sourcesContent": ["import { getInternalHelperManager, getInternalModifierManager, getInternalComponentManager, capabilityFlagsFrom, getComponentTemplate, managerHasCapability } from '../manager/index.js';\nimport { templateFactory } from '../opcode-compiler/index.js';\nimport { enumerate } from '../util/index.js';\nimport { OPERAND_LEN_MASK, ARG_SHIFT, MACHINE_MASK, TYPE_MASK, InternalComponentCapabilities } from '../vm/index.js';\nimport { SexpOpcodes as opcodes } from '../wire-format/index.js';\nfunction unwrapTemplate(template) {\n  if (\"error\" === template.result) throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);\n  return template;\n}\n\n/**\n * Default component template, which is a plain yield\n */\nconst DEFAULT_TEMPLATE_BLOCK = [[[opcodes.Yield, 1, null]], [\"&default\"], []],\n  DEFAULT_TEMPLATE = {\n    // random uuid\n    id: \"1b32f5c2-7623-43d6-a0ad-9672898920a1\",\n    moduleName: \"__default__.hbs\",\n    block: JSON.stringify(DEFAULT_TEMPLATE_BLOCK),\n    scope: null,\n    isStrictMode: true\n  },\n  WELL_KNOWN_EMPTY_ARRAY = Object.freeze([]),\n  STARTER_CONSTANTS = [false, true, null, void 0, WELL_KNOWN_EMPTY_ARRAY],\n  WELL_KNOWN_EMPTY_ARRAY_POSITION = STARTER_CONSTANTS.indexOf(WELL_KNOWN_EMPTY_ARRAY);\nclass ConstantsImpl {\n  value(value) {\n    let indexMap = this.indexMap,\n      index = indexMap.get(value);\n    return void 0 === index && (index = this.values.push(value) - 1, indexMap.set(value, index)), index;\n  }\n  array(values) {\n    if (0 === values.length) return WELL_KNOWN_EMPTY_ARRAY_POSITION;\n    let handles = new Array(values.length);\n    for (let i = 0; i < values.length; i++) handles[i] = this.value(values[i]);\n    return this.value(handles);\n  }\n  toPool() {\n    return this.values;\n  }\n  hasHandle(handle) {\n    return this.values.length > handle;\n  }\n  helper(definitionState,\n  // TODO: Add a way to expose resolved name for debugging\n  _resolvedName = null, isOptional) {\n    let handle = this.helperDefinitionCache.get(definitionState);\n    if (void 0 === handle) {\n      let managerOrHelper = getInternalHelperManager(definitionState, isOptional);\n      if (null === managerOrHelper) return this.helperDefinitionCache.set(definitionState, null), null;\n      let helper = \"function\" == typeof managerOrHelper ? managerOrHelper : managerOrHelper.getHelper(definitionState);\n      handle = this.value(helper), this.helperDefinitionCache.set(definitionState, handle), this.helperDefinitionCount++;\n    }\n    return handle;\n  }\n  modifier(definitionState, resolvedName = null, isOptional) {\n    let handle = this.modifierDefinitionCache.get(definitionState);\n    if (void 0 === handle) {\n      let manager = getInternalModifierManager(definitionState, isOptional);\n      if (null === manager) return this.modifierDefinitionCache.set(definitionState, null), null;\n      let definition = {\n        resolvedName: resolvedName,\n        manager: manager,\n        state: definitionState\n      };\n      handle = this.value(definition), this.modifierDefinitionCache.set(definitionState, handle), this.modifierDefinitionCount++;\n    }\n    return handle;\n  }\n  component(definitionState, owner, isOptional, debugName) {\n    let definition = this.componentDefinitionCache.get(definitionState);\n    if (void 0 === definition) {\n      let manager = getInternalComponentManager(definitionState, isOptional);\n      if (null === manager) return this.componentDefinitionCache.set(definitionState, null), null;\n      let template,\n        capabilities = capabilityFlagsFrom(manager.getCapabilities(definitionState)),\n        templateFactory = getComponentTemplate(definitionState),\n        compilable = null;\n      template = managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout) ? templateFactory?.(owner) : templateFactory?.(owner) ?? this.defaultTemplate, void 0 !== template && (template = unwrapTemplate(template), compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? template.asWrappedLayout() : template.asLayout()), definition = {\n        resolvedName: null,\n        handle: -1,\n        manager: manager,\n        capabilities: capabilities,\n        state: definitionState,\n        compilable: compilable\n      }, definition.handle = this.value(definition), debugName && (definition.debugName = debugName), this.componentDefinitionCache.set(definitionState, definition), this.componentDefinitionCount++;\n    }\n    return definition;\n  }\n  resolvedComponent(resolvedDefinition, resolvedName) {\n    let definition = this.componentDefinitionCache.get(resolvedDefinition);\n    if (void 0 === definition) {\n      let {\n          manager: manager,\n          state: state,\n          template: template\n        } = resolvedDefinition,\n        capabilities = capabilityFlagsFrom(manager.getCapabilities(resolvedDefinition)),\n        compilable = null;\n      managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout) || (template = template ?? this.defaultTemplate), null !== template && (template = unwrapTemplate(template), compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? template.asWrappedLayout() : template.asLayout()), definition = {\n        resolvedName: resolvedName,\n        handle: -1,\n        manager: manager,\n        capabilities: capabilities,\n        state: state,\n        compilable: compilable\n      }, definition.handle = this.value(definition), this.componentDefinitionCache.set(resolvedDefinition, definition), this.componentDefinitionCount++;\n    }\n    return definition;\n  }\n  getValue(index) {\n    return this.values[index];\n  }\n  getArray(index) {\n    let reifiedArrs = this.reifiedArrs,\n      reified = reifiedArrs[index];\n    if (void 0 === reified) {\n      let names = this.getValue(index);\n      reified = new Array(names.length);\n      for (const [i, name] of enumerate(names)) reified[i] = this.getValue(name);\n      reifiedArrs[index] = reified;\n    }\n    return reified;\n  }\n  constructor() {\n    this.reifiedArrs = {\n      [WELL_KNOWN_EMPTY_ARRAY_POSITION]: WELL_KNOWN_EMPTY_ARRAY\n    }, this.defaultTemplate = templateFactory(DEFAULT_TEMPLATE)(),\n    // Used for tests and debugging purposes, and to be able to analyze large apps\n    // This is why it's enabled even in production\n    this.helperDefinitionCount = 0, this.modifierDefinitionCount = 0, this.componentDefinitionCount = 0, this.values = STARTER_CONSTANTS.slice(), this.indexMap = new Map(this.values.map((value, index) => [value, index])), this.helperDefinitionCache = new WeakMap(), this.modifierDefinitionCache = new WeakMap(), this.componentDefinitionCache = new WeakMap();\n  }\n}\nclass RuntimeOpImpl {\n  constructor(heap) {\n    this.heap = heap, this.offset = 0;\n  }\n  get size() {\n    return 1 + ((this.heap.getbyaddr(this.offset) & OPERAND_LEN_MASK) >> ARG_SHIFT);\n  }\n  get isMachine() {\n    return this.heap.getbyaddr(this.offset) & MACHINE_MASK ? 1 : 0;\n  }\n  get type() {\n    return this.heap.getbyaddr(this.offset) & TYPE_MASK;\n  }\n  get op1() {\n    return this.heap.getbyaddr(this.offset + 1);\n  }\n  get op2() {\n    return this.heap.getbyaddr(this.offset + 2);\n  }\n  get op3() {\n    return this.heap.getbyaddr(this.offset + 3);\n  }\n}\n\n/**\n * The Program Heap is responsible for dynamically allocating\n * memory in which we read/write the VM's instructions\n * from/to. When we malloc we pass out a VMHandle, which\n * is used as an indirect way of accessing the memory during\n * execution of the VM. Internally we track the different\n * regions of the memory in an int array known as the table.\n *\n * The table 32-bit aligned and has the following layout:\n *\n * | ... | hp (u32) |       info (u32)   | size (u32) |\n * | ... |  Handle  | Scope Size | State | Size       |\n * | ... | 32bits   | 30bits     | 2bits | 32bit      |\n *\n * With this information we effectively have the ability to\n * control when we want to free memory. That being said you\n * can not free during execution as raw address are only\n * valid during the execution. This means you cannot close\n * over them as you will have a bad memory access exception.\n */\nclass ProgramHeapImpl {\n  constructor() {\n    this.offset = 0, this.handle = 0, this.heap = new Int32Array(1048576), this.handleTable = [], this.handleState = [];\n  }\n  entries() {\n    return this.offset;\n  }\n  pushRaw(value) {\n    this.sizeCheck(), this.heap[this.offset++] = value;\n  }\n  pushOp(item) {\n    this.pushRaw(item);\n  }\n  pushMachine(item) {\n    this.pushRaw(item | MACHINE_MASK);\n  }\n  sizeCheck() {\n    let {\n      heap: heap\n    } = this;\n    if (this.offset === this.heap.length) {\n      let newHeap = new Int32Array(heap.length + 1048576);\n      newHeap.set(heap, 0), this.heap = newHeap;\n    }\n  }\n  getbyaddr(address) {\n    return this.heap[address];\n  }\n  setbyaddr(address, value) {\n    this.heap[address] = value;\n  }\n  malloc() {\n    // push offset, info, size\n    return this.handleTable.push(this.offset), this.handleTable.length - 1;\n  }\n  finishMalloc(handle) {}\n  size() {\n    return this.offset;\n  }\n  // It is illegal to close over this address, as compaction\n  // may move it. However, it is legal to use this address\n  // multiple times between compactions.\n  getaddr(handle) {\n    return this.handleTable[handle];\n  }\n  sizeof(handle) {\n    return this.handleTable, -1;\n  }\n  free(handle) {\n    this.handleState[handle] = 1;\n  }\n  /**\n  * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift\n  * reachable memory to the bottom of the heap and freeable\n  * memory to the top of the heap. When we have shifted all\n  * the reachable memory to the top of the heap, we move the\n  * offset to the next free position.\n  */\n  compact() {\n    let compactedSize = 0,\n      {\n        handleTable: handleTable,\n        handleState: handleState,\n        heap: heap\n      } = this;\n    for (let i = 0; i < length; i++) {\n      let offset = handleTable[i],\n        size = handleTable[i + 1] - offset,\n        state = handleState[i];\n      if (2 !== state) if (1 === state)\n        // transition to \"already freed\" aka \"purged\"\n        // a good improvement would be to reuse\n        // these slots\n        handleState[i] = 2, compactedSize += size;else if (0 === state) {\n        for (let j = offset; j <= i + size; j++) heap[j - compactedSize] = heap[j];\n        handleTable[i] = offset - compactedSize;\n      } else 3 === state && (handleTable[i] = offset - compactedSize);\n    }\n    this.offset = this.offset - compactedSize;\n  }\n}\nclass ProgramImpl {\n  constructor(constants, heap) {\n    this.constants = constants, this.heap = heap, this._opcode = new RuntimeOpImpl(this.heap);\n  }\n  opcode(offset) {\n    return this._opcode.offset = offset, this._opcode;\n  }\n}\nfunction artifacts() {\n  return {\n    constants: new ConstantsImpl(),\n    heap: new ProgramHeapImpl()\n  };\n}\nexport { ConstantsImpl, ProgramHeapImpl, ProgramImpl, RuntimeOpImpl, artifacts };", "import { registerDestructor, destroy, associateDestroyableChild, _hasDestroyableChildren, destroyChildren, isDestroying, isDestroyed } from '../destroyable/index.js';\nimport { toBool, warnIfStyleNotTrusted, debugAssert, assertGlobalContextWasSet, setPath, getPath } from '../global-context/index.js';\nimport { getInternalModifierManager, managerHasCapability, setInternalComponentManager, setInternalModifierManager, getInternalHelperManager, hasInternalComponentManager, hasInternalHelperManager, setInternalHelperManager, hasValue, hasDestroyable } from '../manager/index.js';\nimport { createConstRef, UNDEFINED_REFERENCE, NULL_REFERENCE, TRUE_REFERENCE, FALSE_REFERENCE, createPrimitiveRef, valueForRef, isConstRef, createComputeRef, childRefFor, createIteratorRef, createIteratorItemRef, updateRef, createDebugAliasRef, isInvokableRef } from '../reference/index.js';\nimport { isIndexable as isIndexable$1, EMPTY_STRING_ARRAY, dict, enumerate, emptyArray, assign, clearElement, Stack as StackImpl, reverse, isDict } from '../util/index.js';\nimport { $t0, $t1, $s0, $v0, ContentType, $pc, isLowLevelRegister, $sp, $fp, $ra, InternalComponentCapabilities } from '../vm/index.js';\nimport { consumeTag, valueForTag, validateTag, CURRENT_TAG, track, updateTag as UPDATE_TAG, debug, beginTrackFrame, endTrackFrame, resetTracking, CONSTANT_TAG, INITIAL, createCache, getValue, createUpdatableTag } from '../validator/index.js';\nimport { ProgramImpl } from '../program/index.js';\nimport { getOwner } from '../owner/index.js';\nconst NS_MATHML = \"http://www.w3.org/1998/Math/MathML\",\n  NS_SVG = \"http://www.w3.org/2000/svg\";\nlet debugToString;\nif (true) {\n  let getFunctionName = fn => {\n      let functionName = fn.name;\n      if (\"\" === functionName) {\n        let match = /function (\\w+)\\s*\\(/u.exec(String(fn));\n        functionName = match && match[1] || \"\";\n      }\n      return functionName.replace(/^bound /u, \"\");\n    },\n    getObjectName = obj => {\n      let name, className;\n      // If the class has a decent looking name, and the `toString` is one of the\n      // default Ember toStrings, replace the constructor portion of the toString\n      // with the class name. We check the length of the class name to prevent doing\n      // this when the value is minified.\n      return \"function\" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), \"toString\" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && (\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      name = obj.toString()), name && /<.*:ember\\d+>/u.test(name) && className && \"_\" !== className[0] && className.length > 2 && \"Class\" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;\n    },\n    getPrimitiveName = value => String(value);\n  debugToString = value => \"function\" == typeof value ? getFunctionName(value) || \"(unknown function)\" : \"object\" == typeof value && null !== value ? getObjectName(value) || \"(unknown object)\" : getPrimitiveName(value);\n}\nvar debugToString$1 = debugToString;\nfunction castToSimple(node) {\n  return function (node) {\n    node.nodeType;\n  }(node), node;\n}\nfunction unwrapHandle(handle) {\n  if (\"number\" == typeof handle) return handle;\n  {\n    let error = handle.errors[0];\n    throw new Error(`Compile Error: ${error.problem} @ ${error.span.start}..${error.span.end}`);\n  }\n}\nfunction unwrapTemplate(template) {\n  if (\"error\" === template.result) throw new Error(`Compile Error: ${template.problem} @ ${template.span.start}..${template.span.end}`);\n  return template;\n}\n\n/* eslint-disable @typescript-eslint/no-empty-object-type */\nfunction buildUntouchableThis(source) {\n  let context = null;\n  if (true) {\n    let assertOnProperty = property => {\n      let access = \"symbol\" == typeof property || \"number\" == typeof property ? `[${String(property)}]` : `.${property}`;\n      throw new Error(`You accessed \\`this${access}\\` from a function passed to the ${source}, but the function itself was not bound to a valid \\`this\\` context. Consider updating to use a bound function (for instance, use an arrow function, \\`() => {}\\`).`);\n    };\n    context = new Proxy({}, {\n      get(_target, property) {\n        assertOnProperty(property);\n      },\n      set: (_target, property) => (assertOnProperty(property), false),\n      has: (_target, property) => (assertOnProperty(property), false)\n    });\n  }\n  return context;\n}\nfunction decodeImmediate(num) {\n  return (num |= 0) > -536870913 ? function (num) {\n    return ~num;\n  }(num) : function (num) {\n    return 536870912 | num;\n  }(num);\n}\n[1, -1].forEach(x => {\n  return decodeImmediate((num = x, (num |= 0) < 0 ? function (num) {\n    return -536870913 & num;\n  }(num) : function (num) {\n    return ~num;\n  }(num)));\n  var num;\n});\nconst APPEND_OPCODES = new class {\n    constructor() {\n      // This code is intentionally putting unsafe `null`s into the array that it\n      // will intentionally overwrite before anyone can see them.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      this.evaluateOpcode = new Array(113).fill(null);\n    }\n    add(name, evaluate, kind = \"syscall\") {\n      this.evaluateOpcode[name] = {\n        syscall: \"machine\" !== kind,\n        evaluate: evaluate\n      };\n    }\n    evaluate(vm, opcode, type) {\n      let operation = this.evaluateOpcode[type];\n      operation.syscall ? (opcode.isMachine, operation.syscall, opcode.isMachine, opcode.type, operation.evaluate(vm, opcode)) : (opcode.isMachine, operation.syscall, opcode.isMachine, opcode.type, operation.evaluate(vm.lowlevel, opcode));\n    }\n  }(),\n  TYPE = Symbol(\"TYPE\"),\n  INNER = Symbol(\"INNER\"),\n  OWNER = Symbol(\"OWNER\"),\n  ARGS = Symbol(\"ARGS\"),\n  RESOLVED = Symbol(\"RESOLVED\"),\n  CURRIED_VALUES = new WeakSet();\nfunction isCurriedValue(value) {\n  return CURRIED_VALUES.has(value);\n}\nfunction isCurriedType(value, type) {\n  return isCurriedValue(value) && value[TYPE] === type;\n}\nclass CurriedValue {\n  /** @internal */constructor(type, inner, owner, args, resolved = false) {\n    CURRIED_VALUES.add(this), this[TYPE] = type, this[INNER] = inner, this[OWNER] = owner, this[ARGS] = args, this[RESOLVED] = resolved;\n  }\n}\nfunction resolveCurriedValue(curriedValue) {\n  let positional,\n    named,\n    definition,\n    owner,\n    resolved,\n    currentWrapper = curriedValue;\n  for (;;) {\n    let {\n      [ARGS]: curriedArgs,\n      [INNER]: inner\n    } = currentWrapper;\n    if (null !== curriedArgs) {\n      let {\n        named: curriedNamed,\n        positional: curriedPositional\n      } = curriedArgs;\n      curriedPositional.length > 0 && (positional = void 0 === positional ? curriedPositional : curriedPositional.concat(positional)), void 0 === named && (named = []), named.unshift(curriedNamed);\n    }\n    if (!isCurriedValue(inner)) {\n      // Save off the owner that this helper was curried with. Later on,\n      // we'll fetch the value of this register and set it as the owner on the\n      // new root scope.\n      definition = inner, owner = currentWrapper[OWNER], resolved = currentWrapper[RESOLVED];\n      break;\n    }\n    currentWrapper = inner;\n  }\n  return {\n    definition: definition,\n    owner: owner,\n    resolved: resolved,\n    positional: positional,\n    named: named\n  };\n}\nfunction curry(type, spec, owner, args, resolved = false) {\n  return new CurriedValue(type, spec, owner, args, resolved);\n}\nclass DynamicScopeImpl {\n  constructor(bucket) {\n    this.bucket = bucket ? assign({}, bucket) : {};\n  }\n  get(key) {\n    return this.bucket[key];\n  }\n  set(key, reference) {\n    return this.bucket[key] = reference;\n  }\n  child() {\n    return new DynamicScopeImpl(this.bucket);\n  }\n}\nclass ScopeImpl {\n  static root(owner, {\n    self: self,\n    size = 0\n  }) {\n    let refs = new Array(size + 1).fill(UNDEFINED_REFERENCE);\n    return new ScopeImpl(owner, refs, null).init({\n      self: self\n    });\n  }\n  static sized(owner, size = 0) {\n    let refs = new Array(size + 1).fill(UNDEFINED_REFERENCE);\n    return new ScopeImpl(owner, refs, null);\n  }\n  constructor(owner,\n  // the 0th slot is `self`\n  slots,\n  // a single program can mix owners via curried components, and the state lives on root scopes\n  callerScope) {\n    this.owner = owner, this.slots = slots, this.callerScope = callerScope;\n  }\n  init({\n    self: self\n  }) {\n    return this.slots[0] = self, this;\n  }\n  /**\n  * @debug\n  */\n  snapshot() {\n    return this.slots.slice();\n  }\n  getSelf() {\n    return this.get(0);\n  }\n  getSymbol(symbol) {\n    return this.get(symbol);\n  }\n  getBlock(symbol) {\n    let block = this.get(symbol);\n    return block === UNDEFINED_REFERENCE ? null : block;\n  }\n  bind(symbol, value) {\n    this.set(symbol, value);\n  }\n  bindSelf(self) {\n    this.set(0, self);\n  }\n  bindSymbol(symbol, value) {\n    this.set(symbol, value);\n  }\n  bindBlock(symbol, value) {\n    this.set(symbol, value);\n  }\n  bindCallerScope(scope) {\n    this.callerScope = scope;\n  }\n  getCallerScope() {\n    return this.callerScope;\n  }\n  child() {\n    return new ScopeImpl(this.owner, this.slots.slice(), this.callerScope);\n  }\n  get(index) {\n    if (index >= this.slots.length) throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    return this.slots[index];\n  }\n  set(index, value) {\n    if (index >= this.slots.length) throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);\n    this.slots[index] = value;\n  }\n}\nclass CursorImpl {\n  constructor(element, nextSibling) {\n    this.element = element, this.nextSibling = nextSibling;\n  }\n}\nclass ConcreteBounds {\n  constructor(parentNode, first, last) {\n    this.parentNode = parentNode, this.first = first, this.last = last;\n  }\n  parentElement() {\n    return this.parentNode;\n  }\n  firstNode() {\n    return this.first;\n  }\n  lastNode() {\n    return this.last;\n  }\n}\nfunction move(bounds, reference) {\n  let parent = bounds.parentElement(),\n    first = bounds.firstNode(),\n    last = bounds.lastNode(),\n    current = first;\n  for (;;) {\n    let next = current.nextSibling;\n    if (parent.insertBefore(current, reference), current === last) return next;\n    current = next;\n  }\n}\nfunction clear(bounds) {\n  let parent = bounds.parentElement(),\n    first = bounds.firstNode(),\n    last = bounds.lastNode(),\n    current = first;\n  for (;;) {\n    let next = current.nextSibling;\n    if (parent.removeChild(current), current === last) return next;\n    current = next;\n  }\n}\n\n/** @internal */\nfunction hasCustomDebugRenderTreeLifecycle(manager) {\n  return \"getDebugCustomRenderTree\" in manager;\n}\nlet GUID = 0;\nclass Ref {\n  constructor(value) {\n    this.id = GUID++, this.value = value;\n  }\n  get() {\n    return this.value;\n  }\n  release() {\n    if (true && null === this.value) throw new Error(\"BUG: double release?\");\n    this.value = null;\n  }\n  toString() {\n    let label = `Ref ${this.id}`;\n    if (null === this.value) return `${label} (released)`;\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      return `${label}: ${this.value}`;\n    } catch {\n      return label;\n    }\n  }\n}\nclass DebugRenderTreeImpl {\n  begin() {\n    this.reset();\n  }\n  create(state, node) {\n    let internalNode = assign({}, node, {\n      bounds: null,\n      refs: new Set()\n    });\n    this.nodes.set(state, internalNode), this.appendChild(internalNode, state), this.enter(state);\n  }\n  update(state) {\n    this.enter(state);\n  }\n  didRender(state, bounds) {\n    if (true && this.stack.current !== state)\n      // eslint-disable-next-line @typescript-eslint/no-base-to-string\n      throw new Error(`BUG: expecting ${this.stack.current}, got ${state}`);\n    this.nodeFor(state).bounds = bounds, this.exit();\n  }\n  willDestroy(state) {\n    this.refs.get(state).release();\n  }\n  commit() {\n    this.reset();\n  }\n  capture() {\n    return this.captureRefs(this.roots);\n  }\n  reset() {\n    if (0 !== this.stack.size) {\n      // We probably encountered an error during the rendering loop. This will\n      // likely trigger undefined behavior and memory leaks as the error left\n      // things in an inconsistent state. It is recommended that the user\n      // refresh the page.\n      // TODO: We could warn here? But this happens all the time in our tests?\n      // Clean up the root reference to prevent errors from happening if we\n      // attempt to capture the render tree (Ember Inspector may do this)\n      let root = this.stack.toArray()[0],\n        ref = this.refs.get(root);\n      for (void 0 !== ref && this.roots.delete(ref); !this.stack.isEmpty();) this.stack.pop();\n    }\n  }\n  enter(state) {\n    this.stack.push(state);\n  }\n  exit() {\n    if (true && 0 === this.stack.size) throw new Error(\"BUG: unbalanced pop\");\n    this.stack.pop();\n  }\n  nodeFor(state) {\n    return this.nodes.get(state);\n  }\n  appendChild(node, state) {\n    if (true && this.refs.has(state)) throw new Error(\"BUG: child already appended\");\n    let parent = this.stack.current,\n      ref = new Ref(state);\n    if (this.refs.set(state, ref), parent) {\n      let parentNode = this.nodeFor(parent);\n      parentNode.refs.add(ref), node.parent = parentNode;\n    } else this.roots.add(ref);\n  }\n  captureRefs(refs) {\n    let captured = [];\n    return refs.forEach(ref => {\n      let state = ref.get();\n      state ? captured.push(this.captureNode(`render-node:${ref.id}`, state)) : refs.delete(ref);\n    }), captured;\n  }\n  captureNode(id, state) {\n    let node = this.nodeFor(state),\n      {\n        type: type,\n        name: name,\n        args: args,\n        instance: instance,\n        refs: refs\n      } = node,\n      template = this.captureTemplate(node),\n      bounds = this.captureBounds(node),\n      children = this.captureRefs(refs);\n    return {\n      id: id,\n      type: type,\n      name: name,\n      args: reifyArgsDebug(args),\n      instance: instance,\n      template: template,\n      bounds: bounds,\n      children: children\n    };\n  }\n  captureTemplate({\n    template: template\n  }) {\n    return template || null;\n  }\n  captureBounds(node) {\n    let bounds = node.bounds;\n    return {\n      parentElement: bounds.parentElement(),\n      firstNode: bounds.firstNode(),\n      lastNode: bounds.lastNode()\n    };\n  }\n  constructor() {\n    this.stack = new StackImpl(), this.refs = new WeakMap(), this.roots = new Set(), this.nodes = new WeakMap();\n  }\n}\nfunction getDebugName(definition, manager = definition.manager) {\n  return definition.resolvedName ?? definition.debugName ?? manager.getDebugName(definition.state);\n}\nfunction normalizeStringValue(value) {\n  return isEmpty$2(value) ? \"\" : String(value);\n}\nfunction isEmpty$2(value) {\n  return null == value || \"function\" != typeof value.toString;\n}\nfunction isIndexable(value) {\n  return null !== value && \"object\" == typeof value;\n}\nfunction isSafeString(value) {\n  return isIndexable(value) && \"function\" == typeof value.toHTML;\n}\nfunction isString(value) {\n  return \"string\" == typeof value;\n}\nAPPEND_OPCODES.add(39, vm => vm.pushChildScope()), APPEND_OPCODES.add(40, vm => vm.popScope()), APPEND_OPCODES.add(59, vm => vm.pushDynamicScope()), APPEND_OPCODES.add(60, vm => vm.popDynamicScope()), APPEND_OPCODES.add(28, (vm, {\n  op1: other\n}) => {\n  vm.stack.push(vm.constants.getValue(other));\n}), APPEND_OPCODES.add(29, (vm, {\n  op1: other\n}) => {\n  vm.stack.push(createConstRef(vm.constants.getValue(other), false));\n}), APPEND_OPCODES.add(30, (vm, {\n  op1: primitive\n}) => {\n  let stack = vm.stack;\n  if (primitive >= 0) {\n    // it is a handle which does not already exist on the stack\n    let value = vm.constants.getValue(primitive);\n    stack.push(value);\n  } else\n    // is already an encoded immediate or primitive handle\n    stack.push(decodeImmediate(primitive));\n}), APPEND_OPCODES.add(31, vm => {\n  let ref,\n    stack = vm.stack,\n    value = stack.pop();\n  ref = void 0 === value ? UNDEFINED_REFERENCE : null === value ? NULL_REFERENCE : true === value ? TRUE_REFERENCE : false === value ? FALSE_REFERENCE : createPrimitiveRef(value), stack.push(ref);\n}), APPEND_OPCODES.add(33, (vm, {\n  op1: register,\n  op2: offset\n}) => {\n  let position = vm.fetchValue(register) - offset;\n  vm.stack.dup(position);\n}), APPEND_OPCODES.add(34, (vm, {\n  op1: count\n}) => {\n  vm.stack.pop(count);\n}), APPEND_OPCODES.add(35, (vm, {\n  op1: register\n}) => {\n  vm.load(register);\n}), APPEND_OPCODES.add(36, (vm, {\n  op1: register\n}) => {\n  vm.fetch(register);\n}), APPEND_OPCODES.add(58, (vm, {\n  op1: _names\n}) => {\n  let names = vm.constants.getArray(_names);\n  vm.bindDynamicScope(names);\n}), APPEND_OPCODES.add(69, (vm, {\n  op1: args\n}) => {\n  vm.enter(args);\n}), APPEND_OPCODES.add(70, vm => {\n  vm.exit();\n}), APPEND_OPCODES.add(63, (vm, {\n  op1: _table\n}) => {\n  vm.stack.push(vm.constants.getValue(_table));\n}), APPEND_OPCODES.add(62, vm => {\n  vm.stack.push(vm.scope());\n}), APPEND_OPCODES.add(61, vm => {\n  let stack = vm.stack,\n    block = stack.pop();\n  block ? stack.push(vm.compile(block)) : stack.push(null);\n}), APPEND_OPCODES.add(64, vm => {\n  let {\n      stack: stack\n    } = vm,\n    handle = stack.pop(),\n    scope = stack.pop(),\n    table = stack.pop(),\n    args = stack.pop();\n  if (null === table || null === handle)\n    // To balance the pop{Frame,Scope}\n    return vm.lowlevel.pushFrame(), void vm.pushScope(scope ?? vm.scope());\n  let invokingScope = scope;\n  // If necessary, create a child scope\n  {\n    let locals = table.parameters,\n      localsCount = locals.length;\n    if (localsCount > 0) {\n      invokingScope = invokingScope.child();\n      for (let i = 0; i < localsCount; i++) invokingScope.bindSymbol(locals[i], args.at(i));\n    }\n  }\n  vm.lowlevel.pushFrame(), vm.pushScope(invokingScope), vm.call(handle);\n}), APPEND_OPCODES.add(65, (vm, {\n  op1: target\n}) => {\n  let reference = vm.stack.pop(),\n    value = Boolean(valueForRef(reference));\n  isConstRef(reference) ? value && vm.lowlevel.goto(target) : (value && vm.lowlevel.goto(target), vm.updateWith(new Assert(reference)));\n}), APPEND_OPCODES.add(66, (vm, {\n  op1: target\n}) => {\n  let reference = vm.stack.pop(),\n    value = Boolean(valueForRef(reference));\n  isConstRef(reference) ? value || vm.lowlevel.goto(target) : (value || vm.lowlevel.goto(target), vm.updateWith(new Assert(reference)));\n}), APPEND_OPCODES.add(67, (vm, {\n  op1: target,\n  op2: comparison\n}) => {\n  vm.stack.peek() === comparison && vm.lowlevel.goto(target);\n}), APPEND_OPCODES.add(68, vm => {\n  let reference = vm.stack.peek();\n  isConstRef(reference) || vm.updateWith(new Assert(reference));\n}), APPEND_OPCODES.add(71, vm => {\n  let {\n      stack: stack\n    } = vm,\n    valueRef = stack.pop();\n  stack.push(createComputeRef(() => toBool(valueForRef(valueRef))));\n});\nclass Assert {\n  constructor(ref) {\n    this.ref = ref, this.last = valueForRef(ref);\n  }\n  evaluate(vm) {\n    let {\n      last: last,\n      ref: ref\n    } = this;\n    last !== valueForRef(ref) && vm.throw();\n  }\n}\nclass AssertFilter {\n  constructor(ref, filter) {\n    this.ref = ref, this.filter = filter, this.last = filter(valueForRef(ref));\n  }\n  evaluate(vm) {\n    let {\n      last: last,\n      ref: ref,\n      filter: filter\n    } = this;\n    last !== filter(valueForRef(ref)) && vm.throw();\n  }\n}\nclass JumpIfNotModifiedOpcode {\n  finalize(tag, target) {\n    this.target = target, this.didModify(tag);\n  }\n  evaluate(vm) {\n    let {\n      tag: tag,\n      target: target,\n      lastRevision: lastRevision\n    } = this;\n    !vm.alwaysRevalidate && validateTag(tag, lastRevision) && (consumeTag(tag), vm.goto(target));\n  }\n  didModify(tag) {\n    this.tag = tag, this.lastRevision = valueForTag(this.tag), consumeTag(tag);\n  }\n  constructor() {\n    this.tag = CONSTANT_TAG, this.lastRevision = INITIAL;\n  }\n}\nclass BeginTrackFrameOpcode {\n  constructor(debugLabel) {\n    this.debugLabel = debugLabel;\n  }\n  evaluate() {\n    beginTrackFrame(this.debugLabel);\n  }\n}\nclass EndTrackFrameOpcode {\n  constructor(target) {\n    this.target = target;\n  }\n  evaluate() {\n    let tag = endTrackFrame();\n    this.target.didModify(tag);\n  }\n}\nAPPEND_OPCODES.add(41, (vm, {\n  op1: text\n}) => {\n  vm.tree().appendText(vm.constants.getValue(text));\n}), APPEND_OPCODES.add(42, (vm, {\n  op1: text\n}) => {\n  vm.tree().appendComment(vm.constants.getValue(text));\n}), APPEND_OPCODES.add(48, (vm, {\n  op1: tag\n}) => {\n  vm.tree().openElement(vm.constants.getValue(tag));\n}), APPEND_OPCODES.add(49, vm => {\n  let tagName = valueForRef(vm.stack.pop());\n  vm.tree().openElement(tagName);\n}), APPEND_OPCODES.add(50, vm => {\n  let elementRef = vm.stack.pop(),\n    insertBeforeRef = vm.stack.pop(),\n    guidRef = vm.stack.pop(),\n    element = valueForRef(elementRef),\n    insertBefore = valueForRef(insertBeforeRef),\n    guid = valueForRef(guidRef);\n  isConstRef(elementRef) || vm.updateWith(new Assert(elementRef)), void 0 === insertBefore || isConstRef(insertBeforeRef) || vm.updateWith(new Assert(insertBeforeRef));\n  let block = vm.tree().pushRemoteElement(element, guid, insertBefore);\n  if (vm.associateDestroyable(block), void 0 !== vm.env.debugRenderTree) {\n    // Note that there is nothing to update â€“ when the args for an\n    // {{#in-element}} changes it gets torn down and a new one is\n    // re-created/rendered in its place (see the `Assert`s above)\n    let args = createCapturedArgs(void 0 === insertBefore ? {} : {\n      insertBefore: insertBeforeRef\n    }, [elementRef]);\n    vm.env.debugRenderTree.create(block, {\n      type: \"keyword\",\n      name: \"in-element\",\n      args: args,\n      instance: null\n    }), registerDestructor(block, () => {\n      vm.env.debugRenderTree?.willDestroy(block);\n    });\n  }\n}), APPEND_OPCODES.add(56, vm => {\n  let bounds = vm.tree().popRemoteElement();\n  void 0 !== vm.env.debugRenderTree &&\n  // The RemoteBlock is also its bounds\n  vm.env.debugRenderTree.didRender(bounds, bounds);\n}), APPEND_OPCODES.add(54, vm => {\n  let operations = vm.fetchValue($t0),\n    modifiers = null;\n  operations && (modifiers = operations.flush(vm), vm.loadValue($t0, null)), vm.tree().flushElement(modifiers);\n}), APPEND_OPCODES.add(55, vm => {\n  let modifiers = vm.tree().closeElement();\n  null !== modifiers && modifiers.forEach(modifier => {\n    vm.env.scheduleInstallModifier(modifier);\n    const d = modifier.manager.getDestroyable(modifier.state);\n    null !== d && vm.associateDestroyable(d);\n  });\n}), APPEND_OPCODES.add(57, (vm, {\n  op1: handle\n}) => {\n  if (!vm.env.isInteractive) return;\n  let owner = vm.getOwner(),\n    args = vm.stack.pop(),\n    definition = vm.constants.getValue(handle),\n    {\n      manager: manager\n    } = definition,\n    {\n      constructing: constructing\n    } = vm.tree(),\n    capturedArgs = args.capture(),\n    state = manager.create(owner, constructing, definition.state, capturedArgs),\n    instance = {\n      manager: manager,\n      state: state,\n      definition: definition\n    };\n  vm.fetchValue($t0).addModifier(vm, instance, capturedArgs);\n  let tag = manager.getTag(state);\n  return null !== tag ? (consumeTag(tag), vm.updateWith(new UpdateModifierOpcode(tag, instance))) : void 0;\n}), APPEND_OPCODES.add(108, vm => {\n  if (!vm.env.isInteractive) return;\n  let {\n      stack: stack\n    } = vm,\n    ref = stack.pop(),\n    args = stack.pop().capture(),\n    {\n      positional: outerPositional,\n      named: outerNamed\n    } = args,\n    {\n      constructing: constructing\n    } = vm.tree(),\n    initialOwner = vm.getOwner(),\n    instanceRef = createComputeRef(() => {\n      let owner,\n        hostDefinition,\n        value = valueForRef(ref);\n      if (!isIndexable$1(value)) return;\n      if (isCurriedType(value, 2)) {\n        let {\n          definition: resolvedDefinition,\n          owner: curriedOwner,\n          positional: positional,\n          named: named\n        } = resolveCurriedValue(value);\n        hostDefinition = resolvedDefinition, owner = curriedOwner, void 0 !== positional && (args.positional = positional.concat(outerPositional)), void 0 !== named && (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        args.named = Object.assign({}, ...named, outerNamed));\n      } else hostDefinition = value, owner = initialOwner;\n      let manager = getInternalModifierManager(hostDefinition, true);\n      if (null === manager) throw true ? new Error(`Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was \\`{{${ref.debugLabel}}}\\`, and the incorrect definition is the value at the path \\`${ref.debugLabel}\\`, which was: ${debugToString$1?.(hostDefinition)}`) : new Error(\"BUG: modifier manager expected\");\n      let definition = {\n          resolvedName: null,\n          manager: manager,\n          state: hostDefinition\n        },\n        state = manager.create(owner, constructing, definition.state, args);\n      return {\n        manager: manager,\n        state: state,\n        definition: definition\n      };\n    }),\n    instance = valueForRef(instanceRef),\n    tag = null;\n  return void 0 !== instance && (vm.fetchValue($t0).addModifier(vm, instance, args), tag = instance.manager.getTag(instance.state), null !== tag && consumeTag(tag)), !isConstRef(ref) || tag ? vm.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef)) : void 0;\n});\nclass UpdateModifierOpcode {\n  constructor(tag, modifier) {\n    this.tag = tag, this.modifier = modifier, this.lastUpdated = valueForTag(tag);\n  }\n  evaluate(vm) {\n    let {\n      modifier: modifier,\n      tag: tag,\n      lastUpdated: lastUpdated\n    } = this;\n    consumeTag(tag), validateTag(tag, lastUpdated) || (vm.env.scheduleUpdateModifier(modifier), this.lastUpdated = valueForTag(tag));\n  }\n}\nclass UpdateDynamicModifierOpcode {\n  constructor(tag, instance, instanceRef) {\n    this.tag = tag, this.instance = instance, this.instanceRef = instanceRef, this.lastUpdated = valueForTag(tag ?? CURRENT_TAG);\n  }\n  evaluate(vm) {\n    let {\n        tag: tag,\n        lastUpdated: lastUpdated,\n        instance: instance,\n        instanceRef: instanceRef\n      } = this,\n      newInstance = valueForRef(instanceRef);\n    if (newInstance !== instance) {\n      if (void 0 !== instance) {\n        let destroyable = instance.manager.getDestroyable(instance.state);\n        null !== destroyable && destroy(destroyable);\n      }\n      if (void 0 !== newInstance) {\n        let {\n            manager: manager,\n            state: state\n          } = newInstance,\n          destroyable = manager.getDestroyable(state);\n        null !== destroyable && associateDestroyableChild(this, destroyable), tag = manager.getTag(state), null !== tag && (this.lastUpdated = valueForTag(tag)), this.tag = tag, vm.env.scheduleInstallModifier(newInstance);\n      }\n      this.instance = newInstance;\n    } else null === tag || validateTag(tag, lastUpdated) || (\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    vm.env.scheduleUpdateModifier(instance), this.lastUpdated = valueForTag(tag));\n    null !== tag && consumeTag(tag);\n  }\n}\nAPPEND_OPCODES.add(51, (vm, {\n  op1: _name,\n  op2: _value,\n  op3: _namespace\n}) => {\n  let name = vm.constants.getValue(_name),\n    value = vm.constants.getValue(_value),\n    namespace = _namespace ? vm.constants.getValue(_namespace) : null;\n  vm.tree().setStaticAttribute(name, value, namespace);\n}), APPEND_OPCODES.add(52, (vm, {\n  op1: _name,\n  op2: _trusting,\n  op3: _namespace\n}) => {\n  let name = vm.constants.getValue(_name),\n    trusting = vm.constants.getValue(_trusting),\n    reference = vm.stack.pop(),\n    value = valueForRef(reference),\n    namespace = _namespace ? vm.constants.getValue(_namespace) : null,\n    attribute = vm.tree().setDynamicAttribute(name, value, trusting, namespace);\n  isConstRef(reference) || vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute, vm.env));\n});\nclass UpdateDynamicAttributeOpcode {\n  constructor(reference, attribute, env) {\n    let initialized = false;\n    this.updateRef = createComputeRef(() => {\n      let value = valueForRef(reference);\n      initialized ? attribute.update(value, env) : initialized = true;\n    }), valueForRef(this.updateRef);\n  }\n  evaluate() {\n    valueForRef(this.updateRef);\n  }\n}\nAPPEND_OPCODES.add(78, (vm, {\n  op1: handle\n}) => {\n  let definition = vm.constants.getValue(handle),\n    {\n      manager: manager,\n      capabilities: capabilities\n    } = definition,\n    instance = {\n      definition: definition,\n      manager: manager,\n      capabilities: capabilities,\n      state: null,\n      handle: null,\n      table: null,\n      lookup: null\n    };\n  vm.stack.push(instance);\n}), APPEND_OPCODES.add(80, (vm, {\n  op1: _isStrict\n}) => {\n  let definition,\n    stack = vm.stack,\n    component = valueForRef(stack.pop()),\n    constants = vm.constants,\n    owner = vm.getOwner(),\n    isStrict = constants.getValue(_isStrict);\n  if (vm.loadValue($t1, null), \"string\" == typeof component) {\n    if (true && isStrict) throw new Error(`Attempted to resolve a dynamic component with a string definition, \\`${component}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`);\n    let resolvedDefinition = function (resolver, constants, name, owner) {\n      let definition = resolver?.lookupComponent?.(name, owner) ?? null;\n      if (true && !definition) throw new Error(`Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      return constants.resolvedComponent(definition, name);\n    }(vm.context.resolver, constants, component, owner);\n    definition = resolvedDefinition;\n  } else definition = isCurriedValue(component) ? component : constants.component(component, owner);\n  stack.push(definition);\n}), APPEND_OPCODES.add(81, vm => {\n  let definition,\n    stack = vm.stack,\n    ref = stack.pop(),\n    value = valueForRef(ref),\n    constants = vm.constants;\n  if (true && \"function\" != typeof value && (\"object\" != typeof value || null === value)) throw new Error(`Expected a component definition, but received ${value}. You may have accidentally done <${ref.debugLabel}>, where \"${ref.debugLabel}\" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.`);\n  if (isCurriedValue(value)) definition = value;else if (definition = constants.component(value, vm.getOwner(), true), true && null === definition) throw new Error(`Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was \\`<${ref.debugLabel}>\\` or \\`{{${ref.debugLabel}}}\\`, and the incorrect definition is the value at the path \\`${ref.debugLabel}\\`, which was: ${debugToString$1?.(value) ?? value}`);\n  stack.push(definition);\n}), APPEND_OPCODES.add(79, vm => {\n  let capabilities,\n    manager,\n    {\n      stack: stack\n    } = vm,\n    definition = stack.pop();\n  isCurriedValue(definition) ? manager = capabilities = null : (manager = definition.manager, capabilities = definition.capabilities), stack.push({\n    definition: definition,\n    capabilities: capabilities,\n    manager: manager,\n    state: null,\n    handle: null,\n    table: null\n  });\n}), APPEND_OPCODES.add(82, (vm, {\n  op1: _names,\n  op2: _blockNames,\n  op3: flags\n}) => {\n  let stack = vm.stack,\n    names = vm.constants.getArray(_names),\n    positionalCount = flags >> 4,\n    atNames = 8 & flags,\n    blockNames = 7 & flags ? vm.constants.getArray(_blockNames) : EMPTY_STRING_ARRAY;\n  vm.args.setup(stack, names, blockNames, positionalCount, !!atNames), stack.push(vm.args);\n}), APPEND_OPCODES.add(83, vm => {\n  let {\n    stack: stack\n  } = vm;\n  stack.push(vm.args.empty(stack));\n}), APPEND_OPCODES.add(86, vm => {\n  let stack = vm.stack,\n    capturedArgs = stack.pop().capture();\n  stack.push(capturedArgs);\n}), APPEND_OPCODES.add(85, (vm, {\n  op1: register\n}) => {\n  let stack = vm.stack,\n    instance = vm.fetchValue(register),\n    args = stack.pop(),\n    {\n      definition: definition\n    } = instance;\n  if (isCurriedType(definition, 0)) {\n    definition.manager;\n    let constants = vm.constants,\n      {\n        definition: resolvedDefinition,\n        owner: owner,\n        resolved: resolved,\n        positional: positional,\n        named: named\n      } = resolveCurriedValue(definition);\n    if (resolved) definition = resolvedDefinition;else if (\"string\" == typeof resolvedDefinition) {\n      let resolvedValue = vm.context.resolver?.lookupComponent?.(resolvedDefinition, owner) ?? null;\n      definition = constants.resolvedComponent(resolvedValue, resolvedDefinition);\n    } else definition = constants.component(resolvedDefinition, owner);\n    void 0 !== named &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    args.named.merge(assign({}, ...named)), void 0 !== positional && (args.realloc(positional.length), args.positional.prepend(positional));\n    let {\n      manager: manager\n    } = definition;\n    instance.definition = definition, instance.manager = manager, instance.capabilities = definition.capabilities,\n    // Save off the owner that this component was curried with. Later on,\n    // we'll fetch the value of this register and set it as the owner on the\n    // new root scope.\n    vm.loadValue($t1, owner);\n  }\n  let {\n      manager: manager,\n      state: state\n    } = definition,\n    capabilities = instance.capabilities;\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.prepareArgs)) return void stack.push(args);\n  let blocks = args.blocks.values,\n    blockNames = args.blocks.names,\n    preparedArgs = manager.prepareArgs(state, args);\n  if (preparedArgs) {\n    args.clear();\n    for (let i = 0; i < blocks.length; i++) stack.push(blocks[i]);\n    let {\n        positional: positional,\n        named: named\n      } = preparedArgs,\n      positionalCount = positional.length;\n    for (let i = 0; i < positionalCount; i++) stack.push(positional[i]);\n    let names = Object.keys(named);\n    for (let i = 0; i < names.length; i++) stack.push(named[names[i]]);\n    args.setup(stack, names, blockNames, positionalCount, false);\n  }\n  stack.push(args);\n}), APPEND_OPCODES.add(87, (vm, {\n  op1: flags\n}) => {\n  let instance = vm.fetchValue($s0),\n    {\n      definition: definition,\n      manager: manager,\n      capabilities: capabilities\n    } = instance;\n  if (!managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance))\n    // TODO: Closure and Main components are always invoked dynamically, so this\n    // opcode may run even if this capability is not enabled. In the future we\n    // should handle this in a better way.\n    return;\n  let dynamicScope = null;\n  managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicScope) && (dynamicScope = vm.dynamicScope());\n  let hasDefaultBlock = 1 & flags,\n    args = null;\n  managerHasCapability(manager, capabilities, InternalComponentCapabilities.createArgs) && (args = vm.stack.peek());\n  let self = null;\n  managerHasCapability(manager, capabilities, InternalComponentCapabilities.createCaller) && (self = vm.getSelf());\n  let state = manager.create(vm.getOwner(), definition.state, args, vm.env, dynamicScope, self, !!hasDefaultBlock);\n  // We want to reuse the `state` POJO here, because we know that the opcodes\n  // only transition at exactly one place.\n  instance.state = state, managerHasCapability(manager, capabilities, InternalComponentCapabilities.updateHook) && vm.updateWith(new UpdateComponentOpcode(state, manager, dynamicScope));\n}), APPEND_OPCODES.add(88, (vm, {\n  op1: register\n}) => {\n  let {\n      manager: manager,\n      state: state,\n      capabilities: capabilities\n    } = vm.fetchValue(register),\n    d = manager.getDestroyable(state);\n  if (true && !managerHasCapability(manager, capabilities, InternalComponentCapabilities.willDestroy) && null !== d && \"string\" in d) throw new Error(\"BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into\");\n  d && vm.associateDestroyable(d);\n}), APPEND_OPCODES.add(97, (vm, {\n  op1: register\n}) => {\n  let name;\n  if (true) {\n    let {\n      definition: definition,\n      manager: manager\n    } = vm.fetchValue(register);\n    name = getDebugName(definition, manager);\n  }\n  vm.beginCacheGroup(name), vm.tree().pushAppendingBlock();\n}), APPEND_OPCODES.add(89, vm => {\n  vm.loadValue($t0, new ComponentElementOperations());\n}), APPEND_OPCODES.add(53, (vm, {\n  op1: _name,\n  op2: _trusting,\n  op3: _namespace\n}) => {\n  let name = vm.constants.getValue(_name),\n    trusting = vm.constants.getValue(_trusting),\n    reference = vm.stack.pop(),\n    namespace = _namespace ? vm.constants.getValue(_namespace) : null;\n  vm.fetchValue($t0).setAttribute(name, reference, trusting, namespace);\n}), APPEND_OPCODES.add(105, (vm, {\n  op1: _name,\n  op2: _value,\n  op3: _namespace\n}) => {\n  let name = vm.constants.getValue(_name),\n    value = vm.constants.getValue(_value),\n    namespace = _namespace ? vm.constants.getValue(_namespace) : null;\n  vm.fetchValue($t0).setStaticAttribute(name, value, namespace);\n});\nclass ComponentElementOperations {\n  setAttribute(name, value, trusting, namespace) {\n    let deferred = {\n      value: value,\n      namespace: namespace,\n      trusting: trusting\n    };\n    \"class\" === name && this.classes.push(value), this.attributes[name] = deferred;\n  }\n  setStaticAttribute(name, value, namespace) {\n    let deferred = {\n      value: value,\n      namespace: namespace\n    };\n    \"class\" === name && this.classes.push(value), this.attributes[name] = deferred;\n  }\n  addModifier(vm, modifier, capturedArgs) {\n    if (this.modifiers.push(modifier), void 0 !== vm.env.debugRenderTree) {\n      const {\n        manager: manager,\n        definition: definition,\n        state: state\n      } = modifier;\n      // TODO: we need a stable object for the debugRenderTree as the key, add support for\n      // the case where the state is a primitive, or if in practice we always have/require\n      // an object, then change the internal types to reflect that\n      if (null === state || \"object\" != typeof state && \"function\" != typeof state) return;\n      let {\n          element: element,\n          constructing: constructing\n        } = vm.tree(),\n        name = definition.resolvedName ?? manager.getDebugName(definition.state),\n        instance = manager.getDebugInstance(state),\n        bounds = new ConcreteBounds(element, constructing, constructing);\n      vm.env.debugRenderTree.create(state, {\n        type: \"modifier\",\n        name: name,\n        args: capturedArgs,\n        instance: instance\n      }), vm.env.debugRenderTree.didRender(state, bounds),\n      // For tearing down the debugRenderTree\n      vm.associateDestroyable(state), vm.updateWith(new DebugRenderTreeUpdateOpcode(state)), vm.updateWith(new DebugRenderTreeDidRenderOpcode(state, bounds)), registerDestructor(state, () => {\n        vm.env.debugRenderTree?.willDestroy(state);\n      });\n    }\n  }\n  flush(vm) {\n    let type,\n      attributes = this.attributes;\n    for (let name in this.attributes) {\n      if (\"type\" === name) {\n        type = attributes[name];\n        continue;\n      }\n      let attr = this.attributes[name];\n      \"class\" === name ? setDeferredAttr(vm, \"class\", mergeClasses(this.classes), attr.namespace, attr.trusting) : setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);\n    }\n    return void 0 !== type && setDeferredAttr(vm, \"type\", type.value, type.namespace, type.trusting), this.modifiers;\n  }\n  constructor() {\n    this.attributes = dict(), this.classes = [], this.modifiers = [];\n  }\n}\nfunction mergeClasses(classes) {\n  return 0 === classes.length ? \"\" : 1 === classes.length ? classes[0] : function (classes) {\n    return classes.every(c => \"string\" == typeof c);\n  }(classes) ? classes.join(\" \") : (list = classes, createComputeRef(() => {\n    let ret = [];\n    for (const ref of list) {\n      let value = normalizeStringValue(\"string\" == typeof ref ? ref : valueForRef(ref));\n      value && ret.push(value);\n    }\n    return 0 === ret.length ? null : ret.join(\" \");\n  }));\n  var list;\n}\nfunction setDeferredAttr(vm, name, value, namespace, trusting = false) {\n  if (\"string\" == typeof value) vm.tree().setStaticAttribute(name, value, namespace);else {\n    let attribute = vm.tree().setDynamicAttribute(name, valueForRef(value), trusting, namespace);\n    isConstRef(value) || vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));\n  }\n}\nfunction bindBlock(symbolName, blockName, state, blocks, vm) {\n  let symbol = state.table.symbols.indexOf(symbolName),\n    block = blocks.get(blockName);\n  -1 !== symbol && vm.scope().bindBlock(symbol + 1, block), state.lookup && (state.lookup[symbolName] = block);\n}\nAPPEND_OPCODES.add(99, (vm, {\n  op1: register\n}) => {\n  let {\n      definition: definition,\n      state: state\n    } = vm.fetchValue(register),\n    {\n      manager: manager\n    } = definition,\n    operations = vm.fetchValue($t0);\n  manager.didCreateElement(state, vm.tree().constructing, operations);\n}), APPEND_OPCODES.add(90, (vm, {\n  op1: register,\n  op2: _names\n}) => {\n  let instance = vm.fetchValue(register),\n    {\n      definition: definition,\n      state: state\n    } = instance,\n    {\n      manager: manager\n    } = definition,\n    selfRef = manager.getSelf(state);\n  if (void 0 !== vm.env.debugRenderTree) {\n    let args,\n      moduleName,\n      instance = vm.fetchValue(register),\n      {\n        definition: definition,\n        manager: manager\n      } = instance;\n    if (vm.stack.peek() === vm.args) args = vm.args.capture();else {\n      let names = vm.constants.getArray(_names);\n      vm.args.setup(vm.stack, names, [], 0, true), args = vm.args.capture();\n    }\n    let compilable = definition.compilable;\n    if (null === compilable) {\n      managerHasCapability(manager, instance.capabilities, InternalComponentCapabilities.dynamicLayout);\n      let resolver = vm.context.resolver;\n      compilable = null === resolver ? null : manager.getDynamicLayout(state, resolver), moduleName = null !== compilable ? compilable.moduleName : \"__default__.hbs\";\n    } else moduleName = compilable.moduleName;\n    // For tearing down the debugRenderTree\n    if (vm.associateDestroyable(instance), hasCustomDebugRenderTreeLifecycle(manager)) manager.getDebugCustomRenderTree(instance.definition.state, instance.state, args, moduleName).forEach(node => {\n      let {\n        bucket: bucket\n      } = node;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      vm.env.debugRenderTree.create(bucket, node), registerDestructor(instance, () => {\n        vm.env.debugRenderTree?.willDestroy(bucket);\n      }), vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));\n    });else {\n      let name = getDebugName(definition, manager);\n      vm.env.debugRenderTree.create(instance, {\n        type: \"component\",\n        name: name,\n        args: args,\n        template: moduleName,\n        instance: valueForRef(selfRef)\n      }), registerDestructor(instance, () => {\n        vm.env.debugRenderTree?.willDestroy(instance);\n      }), vm.updateWith(new DebugRenderTreeUpdateOpcode(instance));\n    }\n  }\n  vm.stack.push(selfRef);\n}), APPEND_OPCODES.add(91, (vm, {\n  op1: register\n}) => {\n  let {\n      definition: definition,\n      state: state\n    } = vm.fetchValue(register),\n    {\n      manager: manager\n    } = definition,\n    tagName = manager.getTagName(state);\n  // User provided value from JS, so we don't bother to encode\n  vm.stack.push(tagName);\n}),\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(92, (vm, {\n  op1: register\n}) => {\n  let instance = vm.fetchValue(register),\n    {\n      manager: manager,\n      definition: definition\n    } = instance,\n    {\n      stack: stack\n    } = vm,\n    {\n      compilable: compilable\n    } = definition;\n  if (null === compilable) {\n    let {\n      capabilities: capabilities\n    } = instance;\n    managerHasCapability(manager, capabilities, InternalComponentCapabilities.dynamicLayout);\n    let resolver = vm.context.resolver;\n    compilable = null === resolver ? null : manager.getDynamicLayout(instance.state, resolver), null === compilable && (compilable = managerHasCapability(manager, capabilities, InternalComponentCapabilities.wrapped) ? unwrapTemplate(vm.constants.defaultTemplate).asWrappedLayout() : unwrapTemplate(vm.constants.defaultTemplate).asLayout());\n  }\n  let handle = compilable.compile(vm.context);\n  stack.push(compilable.symbolTable), stack.push(handle);\n}), APPEND_OPCODES.add(75, (vm, {\n  op1: register\n}) => {\n  let definition = vm.stack.pop(),\n    invocation = vm.stack.pop(),\n    {\n      manager: manager,\n      capabilities: capabilities\n    } = definition,\n    state = {\n      definition: definition,\n      manager: manager,\n      capabilities: capabilities,\n      state: null,\n      handle: invocation.handle,\n      table: invocation.symbolTable,\n      lookup: null\n    };\n  vm.loadValue(register, state);\n}), APPEND_OPCODES.add(95, (vm, {\n  op1: register\n}) => {\n  let {\n      stack: stack\n    } = vm,\n    handle = stack.pop(),\n    table = stack.pop(),\n    state = vm.fetchValue(register);\n  // In DEBUG handles could be ErrHandle objects\n  state.handle = handle, state.table = table;\n}), APPEND_OPCODES.add(38, (vm, {\n  op1: register\n}) => {\n  let owner,\n    {\n      table: table,\n      manager: manager,\n      capabilities: capabilities,\n      state: state\n    } = vm.fetchValue(register);\n  managerHasCapability(manager, capabilities, InternalComponentCapabilities.hasSubOwner) ? (owner = manager.getOwner(state), vm.loadValue($t1, null)) : (\n  // Check the temp register to see if an owner was resolved from currying\n  owner = vm.fetchValue($t1), null === owner ?\n  // If an owner wasn't found, default to using the current owner. This\n  // will happen for normal dynamic component invocation,\n  // e.g. <SomeClassicEmberComponent/>\n  owner = vm.getOwner() :\n  // Else the owner was found, so clear the temp register. This will happen\n  // if we are loading a curried component, e.g. <@someCurriedComponent/>\n  vm.loadValue($t1, null)), vm.pushRootScope(table.symbols.length + 1, owner);\n}), APPEND_OPCODES.add(17, (vm, {\n  op1: register\n}) => {\n  let state = vm.fetchValue(register),\n    scope = vm.scope(),\n    args = vm.stack.peek(),\n    callerNames = args.named.atNames;\n  for (let i = callerNames.length - 1; i >= 0; i--) {\n    let atName = callerNames[i],\n      symbol = state.table.symbols.indexOf(atName),\n      value = args.named.get(atName, true);\n    -1 !== symbol && scope.bindSymbol(symbol + 1, value), state.lookup && (state.lookup[atName] = value);\n  }\n}), APPEND_OPCODES.add(18, (vm, {\n  op1: register\n}) => {\n  let state = vm.fetchValue(register),\n    {\n      blocks: blocks\n    } = vm.stack.peek();\n  for (const [i] of enumerate(blocks.names)) bindBlock(blocks.symbolNames[i], blocks.names[i], state, blocks, vm);\n}),\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(96, (vm, {\n  op1: register\n}) => {\n  let state = vm.fetchValue(register);\n  vm.call(state.handle);\n}), APPEND_OPCODES.add(100, (vm, {\n  op1: register\n}) => {\n  let instance = vm.fetchValue(register),\n    {\n      manager: manager,\n      state: state,\n      capabilities: capabilities\n    } = instance,\n    bounds = vm.tree().popBlock();\n  void 0 !== vm.env.debugRenderTree && (hasCustomDebugRenderTreeLifecycle(manager) ? manager.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS).reverse().forEach(node => {\n    let {\n      bucket: bucket\n    } = node;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    vm.env.debugRenderTree.didRender(bucket, bounds), vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));\n  }) : (vm.env.debugRenderTree.didRender(instance, bounds), vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds)))), managerHasCapability(manager, capabilities, InternalComponentCapabilities.createInstance) && (\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call -- @fixme\n  manager.didRenderLayout(state, bounds), vm.env.didCreate(instance), vm.updateWith(new DidUpdateLayoutOpcode(instance, bounds)));\n}), APPEND_OPCODES.add(98, vm => {\n  vm.commitCacheGroup();\n});\nclass UpdateComponentOpcode {\n  constructor(component, manager, dynamicScope) {\n    this.component = component, this.manager = manager, this.dynamicScope = dynamicScope;\n  }\n  evaluate(_vm) {\n    let {\n      component: component,\n      manager: manager,\n      dynamicScope: dynamicScope\n    } = this;\n    manager.update(component, dynamicScope);\n  }\n}\nclass DidUpdateLayoutOpcode {\n  constructor(component, bounds) {\n    this.component = component, this.bounds = bounds;\n  }\n  evaluate(vm) {\n    let {\n        component: component,\n        bounds: bounds\n      } = this,\n      {\n        manager: manager,\n        state: state\n      } = component;\n    manager.didUpdateLayout(state, bounds), vm.env.didUpdate(component);\n  }\n}\nclass DebugRenderTreeUpdateOpcode {\n  constructor(bucket) {\n    this.bucket = bucket;\n  }\n  evaluate(vm) {\n    vm.env.debugRenderTree?.update(this.bucket);\n  }\n}\nclass DebugRenderTreeDidRenderOpcode {\n  constructor(bucket, bounds) {\n    this.bucket = bucket, this.bounds = bounds;\n  }\n  evaluate(vm) {\n    vm.env.debugRenderTree?.didRender(this.bucket, this.bounds);\n  }\n}\n\n/*\n  The calling convention is:\n\n  * 0-N block arguments at the bottom\n  * 0-N positional arguments next (left-to-right)\n  * 0-N named arguments next\n*/\nclass VMArgumentsImpl {\n  constructor() {\n    this.stack = null, this.positional = new PositionalArgumentsImpl(), this.named = new NamedArgumentsImpl(), this.blocks = new BlockArgumentsImpl();\n  }\n  empty(stack) {\n    let base = stack.registers[$sp] + 1;\n    return this.named.empty(stack, base), this.positional.empty(stack, base), this.blocks.empty(stack, base), this;\n  }\n  setup(stack, names, blockNames, positionalCount, atNames) {\n    this.stack = stack;\n    /*\n       | ... | blocks      | positional  | named |\n       | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |\n    index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |\n               ^             ^             ^  ^\n             bbase         pbase       nbase  sp\n    */\n    let named = this.named,\n      namedCount = names.length,\n      namedBase = stack.registers[$sp] - namedCount + 1;\n    named.setup(stack, namedBase, namedCount, names, atNames);\n    let positionalBase = namedBase - positionalCount;\n    this.positional.setup(stack, positionalBase, positionalCount);\n    let blocks = this.blocks,\n      blocksCount = blockNames.length,\n      blocksBase = positionalBase - 3 * blocksCount;\n    blocks.setup(stack, blocksBase, blocksCount, blockNames);\n  }\n  get base() {\n    return this.blocks.base;\n  }\n  get length() {\n    return this.positional.length + this.named.length + 3 * this.blocks.length;\n  }\n  at(pos) {\n    return this.positional.at(pos);\n  }\n  realloc(offset) {\n    let {\n      stack: stack\n    } = this;\n    if (offset > 0 && null !== stack) {\n      let {\n          positional: positional,\n          named: named\n        } = this,\n        newBase = positional.base + offset;\n      for (let i = positional.length + named.length - 1; i >= 0; i--) stack.copy(i + positional.base, i + newBase);\n      positional.base += offset, named.base += offset, stack.registers[$sp] += offset;\n    }\n  }\n  capture() {\n    let positional = 0 === this.positional.length ? EMPTY_POSITIONAL : this.positional.capture();\n    return {\n      named: 0 === this.named.length ? EMPTY_NAMED : this.named.capture(),\n      positional: positional\n    };\n  }\n  clear() {\n    let {\n      stack: stack,\n      length: length\n    } = this;\n    length > 0 && null !== stack && stack.pop(length);\n  }\n}\nconst EMPTY_REFERENCES = emptyArray();\nclass PositionalArgumentsImpl {\n  constructor() {\n    this.base = 0, this.length = 0, this.stack = null, this._references = null;\n  }\n  empty(stack, base) {\n    this.stack = stack, this.base = base, this.length = 0, this._references = EMPTY_REFERENCES;\n  }\n  setup(stack, base, length) {\n    this.stack = stack, this.base = base, this.length = length, this._references = 0 === length ? EMPTY_REFERENCES : null;\n  }\n  at(position) {\n    let {\n      base: base,\n      length: length,\n      stack: stack\n    } = this;\n    return position < 0 || position >= length ? UNDEFINED_REFERENCE : stack.get(position, base);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  }\n  capture() {\n    return this.references;\n  }\n  prepend(other) {\n    let additions = other.length;\n    if (additions > 0) {\n      let {\n        base: base,\n        length: length,\n        stack: stack\n      } = this;\n      this.base = base -= additions, this.length = length + additions;\n      for (let i = 0; i < additions; i++)\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      stack.set(other[i], i, base);\n      this._references = null;\n    }\n  }\n  get references() {\n    let references = this._references;\n    if (!references) {\n      let {\n        stack: stack,\n        base: base,\n        length: length\n      } = this;\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      references = this._references = stack.slice(base, base + length);\n    }\n    return references;\n  }\n}\nclass NamedArgumentsImpl {\n  constructor() {\n    this.base = 0, this.length = 0, this._references = null, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY;\n  }\n  empty(stack, base) {\n    this.stack = stack, this.base = base, this.length = 0, this._references = EMPTY_REFERENCES, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY;\n  }\n  setup(stack, base, length, names, atNames) {\n    this.stack = stack, this.base = base, this.length = length, 0 === length ? (this._references = EMPTY_REFERENCES, this._names = EMPTY_STRING_ARRAY, this._atNames = EMPTY_STRING_ARRAY) : (this._references = null, atNames ? (this._names = null, this._atNames = names) : (this._names = names, this._atNames = null));\n  }\n  get names() {\n    let names = this._names;\n    return names || (\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    names = this._names = this._atNames.map(this.toSyntheticName)), names;\n  }\n  get atNames() {\n    let atNames = this._atNames;\n    return atNames || (\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    atNames = this._atNames = this._names.map(this.toAtName)), atNames;\n  }\n  has(name) {\n    return -1 !== this.names.indexOf(name);\n  }\n  get(name, atNames = false) {\n    let {\n        base: base,\n        stack: stack\n      } = this,\n      idx = (atNames ? this.atNames : this.names).indexOf(name);\n    if (-1 === idx) return UNDEFINED_REFERENCE;\n    let ref = stack.get(idx, base);\n    return true ? createDebugAliasRef(atNames ? name : `@${name}`, ref) : ref;\n  }\n  capture() {\n    let {\n        names: names,\n        references: references\n      } = this,\n      map = dict();\n    for (const [i, name] of enumerate(names))\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    map[name] = true ? createDebugAliasRef(`@${name}`, references[i]) : references[i];\n    return map;\n  }\n  merge(other) {\n    let keys = Object.keys(other);\n    if (keys.length > 0) {\n      let {\n          names: names,\n          length: length,\n          stack: stack\n        } = this,\n        newNames = names.slice();\n      for (const name of keys) -1 === newNames.indexOf(name) && (length = newNames.push(name), stack.push(other[name]));\n      this.length = length, this._references = null, this._names = newNames, this._atNames = null;\n    }\n  }\n  get references() {\n    let references = this._references;\n    if (!references) {\n      let {\n        base: base,\n        length: length,\n        stack: stack\n      } = this;\n      references = this._references = stack.slice(base, base + length);\n    }\n    return references;\n  }\n  toSyntheticName(name) {\n    return name.slice(1);\n  }\n  toAtName(name) {\n    return `@${name}`;\n  }\n}\nfunction toSymbolName(name) {\n  return `&${name}`;\n}\nconst EMPTY_BLOCK_VALUES = emptyArray();\nclass BlockArgumentsImpl {\n  constructor() {\n    this.internalValues = null, this._symbolNames = null, this.internalTag = null, this.names = EMPTY_STRING_ARRAY, this.length = 0, this.base = 0;\n  }\n  empty(stack, base) {\n    this.stack = stack, this.names = EMPTY_STRING_ARRAY, this.base = base, this.length = 0, this._symbolNames = null, this.internalTag = CONSTANT_TAG, this.internalValues = EMPTY_BLOCK_VALUES;\n  }\n  setup(stack, base, length, names) {\n    this.stack = stack, this.names = names, this.base = base, this.length = length, this._symbolNames = null, 0 === length ? (this.internalTag = CONSTANT_TAG, this.internalValues = EMPTY_BLOCK_VALUES) : (this.internalTag = null, this.internalValues = null);\n  }\n  get values() {\n    let values = this.internalValues;\n    if (!values) {\n      let {\n        base: base,\n        length: length,\n        stack: stack\n      } = this;\n      values = this.internalValues = stack.slice(base, base + 3 * length);\n    }\n    return values;\n  }\n  has(name) {\n    return -1 !== this.names.indexOf(name);\n  }\n  get(name) {\n    let idx = this.names.indexOf(name);\n    if (-1 === idx) return null;\n    let {\n        base: base,\n        stack: stack\n      } = this,\n      table = stack.get(3 * idx, base),\n      scope = stack.get(3 * idx + 1, base),\n      handle = stack.get(3 * idx + 2, base);\n    return null === handle ? null : [handle, scope, table];\n  }\n  capture() {\n    return new CapturedBlockArgumentsImpl(this.names, this.values);\n  }\n  get symbolNames() {\n    let symbolNames = this._symbolNames;\n    return null === symbolNames && (symbolNames = this._symbolNames = this.names.map(toSymbolName)), symbolNames;\n  }\n}\nclass CapturedBlockArgumentsImpl {\n  constructor(names, values) {\n    this.names = names, this.values = values, this.length = names.length;\n  }\n  has(name) {\n    return -1 !== this.names.indexOf(name);\n  }\n  get(name) {\n    let idx = this.names.indexOf(name);\n    return -1 === idx ? null : [this.values[3 * idx + 2], this.values[3 * idx + 1], this.values[3 * idx]];\n  }\n}\nfunction createCapturedArgs(named, positional) {\n  return {\n    named: named,\n    positional: positional\n  };\n}\nfunction reifyNamed(named) {\n  let reified = dict();\n  for (const [key, value] of Object.entries(named)) reified[key] = valueForRef(value);\n  return reified;\n}\nfunction reifyPositional(positional) {\n  return positional.map(valueForRef);\n}\nfunction reifyArgs(args) {\n  return {\n    named: reifyNamed(args.named),\n    positional: reifyPositional(args.positional)\n  };\n}\nconst ARGUMENT_ERROR = Symbol(\"ARGUMENT_ERROR\");\nfunction isArgumentError(arg) {\n  return null !== arg && \"object\" == typeof arg && arg[ARGUMENT_ERROR];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ArgumentErrorImpl(error) {\n  return {\n    [ARGUMENT_ERROR]: true,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    error: error\n  };\n}\nfunction reifyArgsDebug(args) {\n  return {\n    named: function (named) {\n      let reified = dict();\n      for (const [key, value] of Object.entries(named)) try {\n        reified[key] = valueForRef(value);\n      } catch (e) {\n        reified[key] = ArgumentErrorImpl(e);\n      }\n      return reified;\n    }(args.named),\n    positional: (positional = args.positional, positional.map(p => {\n      try {\n        return valueForRef(p);\n      } catch (e) {\n        return ArgumentErrorImpl(e);\n      }\n    }))\n  };\n  var positional;\n}\nconst EMPTY_NAMED = Object.freeze(Object.create(null)),\n  EMPTY_POSITIONAL = EMPTY_REFERENCES,\n  EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);\nfunction castToString(value) {\n  return \"string\" == typeof value ? value : \"function\" != typeof value.toString ? \"\" : String(value);\n  // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n}\nfunction resolveHelper(definition, ref) {\n  let helper,\n    managerOrHelper = getInternalHelperManager(definition, true);\n  return helper = null === managerOrHelper ? null : \"function\" == typeof managerOrHelper ? managerOrHelper : managerOrHelper.getHelper(definition), debugAssert(null !== helper, () => `Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was \\`{{${ref.debugLabel}}}\\` or \\`(${ref.debugLabel})\\`, and the incorrect definition is the value at the path \\`${ref.debugLabel}\\`, which was: ${debugToString$1?.(definition)}`), helper;\n}\nfunction isUndefinedReference(input) {\n  return input === UNDEFINED_REFERENCE;\n}\nAPPEND_OPCODES.add(77, (vm, {\n  op1: type,\n  op2: _isStrict\n}) => {\n  let stack = vm.stack,\n    definition = stack.pop(),\n    capturedArgs = stack.pop(),\n    owner = vm.getOwner(),\n    resolver = vm.context.resolver,\n    isStrict = false;\n  true && (\n  // strict check only happens in DEBUG builds, no reason to load it otherwise\n  isStrict = vm.constants.getValue(_isStrict)), vm.loadValue($v0, function (type, inner, owner, args, resolver, isStrict) {\n    let lastValue, curriedDefinition;\n    return createComputeRef(() => {\n      let value = valueForRef(inner);\n      if (value === lastValue) return curriedDefinition;\n      if (isCurriedType(value, type)) curriedDefinition = args ? curry(type, value, owner, args) : args;else if (0 === type && \"string\" == typeof value && value) {\n        // Only components should enter this path, as helpers and modifiers do not\n        // support string based resolution\n        if (true) {\n          if (isStrict) throw new Error(`Attempted to resolve a dynamic component with a string definition, \\`${value}\\` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.`);\n          if (!resolver.lookupComponent?.(value, owner)) throw new Error(`Attempted to resolve \\`${value}\\`, which was expected to be a component, but nothing was found.`);\n        }\n        curriedDefinition = curry(type, value, owner, args);\n      } else curriedDefinition = isIndexable$1(value) ? curry(type, value, owner, args) : null;\n      return lastValue = value, curriedDefinition;\n    });\n  }(type, definition, owner, capturedArgs, resolver, isStrict));\n}), APPEND_OPCODES.add(107, vm => {\n  let helperRef,\n    stack = vm.stack,\n    ref = stack.pop(),\n    args = stack.pop().capture(),\n    initialOwner = vm.getOwner(),\n    helperInstanceRef = createComputeRef(() => {\n      void 0 !== helperRef && destroy(helperRef);\n      let definition = valueForRef(ref);\n      if (isCurriedType(definition, 1)) {\n        let {\n            definition: resolvedDef,\n            owner: owner,\n            positional: positional,\n            named: named\n          } = resolveCurriedValue(definition),\n          helper = resolveHelper(resolvedDef, ref);\n        void 0 !== named && (\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        args.named = assign({}, ...named, args.named)), void 0 !== positional && (args.positional = positional.concat(args.positional)), helperRef = helper(args, owner), associateDestroyableChild(helperInstanceRef, helperRef);\n      } else if (isIndexable$1(definition)) {\n        let helper = resolveHelper(definition, ref);\n        helperRef = helper(args, initialOwner), _hasDestroyableChildren(helperRef) && associateDestroyableChild(helperInstanceRef, helperRef);\n      } else helperRef = UNDEFINED_REFERENCE;\n    }),\n    helperValueRef = createComputeRef(() => (valueForRef(helperInstanceRef), valueForRef(helperRef)));\n  vm.associateDestroyable(helperInstanceRef), vm.loadValue($v0, helperValueRef);\n}), APPEND_OPCODES.add(16, (vm, {\n  op1: handle\n}) => {\n  let stack = vm.stack,\n    value = vm.constants.getValue(handle)(stack.pop().capture(), vm.getOwner(), vm.dynamicScope());\n  _hasDestroyableChildren(value) && vm.associateDestroyable(value), vm.loadValue($v0, value);\n}), APPEND_OPCODES.add(21, (vm, {\n  op1: symbol\n}) => {\n  let expr = vm.referenceForSymbol(symbol);\n  vm.stack.push(expr);\n}), APPEND_OPCODES.add(19, (vm, {\n  op1: symbol\n}) => {\n  let expr = vm.stack.pop();\n  vm.scope().bindSymbol(symbol, expr);\n}), APPEND_OPCODES.add(20, (vm, {\n  op1: symbol\n}) => {\n  let handle = vm.stack.pop(),\n    scope = vm.stack.pop(),\n    table = vm.stack.pop();\n  vm.scope().bindBlock(symbol, [handle, scope, table]);\n}), APPEND_OPCODES.add(37, (vm, {\n  op1: size\n}) => {\n  vm.pushRootScope(size, vm.getOwner());\n}), APPEND_OPCODES.add(22, (vm, {\n  op1: _key\n}) => {\n  let key = vm.constants.getValue(_key),\n    expr = vm.stack.pop();\n  vm.stack.push(childRefFor(expr, key));\n}), APPEND_OPCODES.add(23, (vm, {\n  op1: _block\n}) => {\n  let {\n      stack: stack\n    } = vm,\n    block = vm.scope().getBlock(_block);\n  stack.push(block);\n}), APPEND_OPCODES.add(24, vm => {\n  let {\n      stack: stack\n    } = vm,\n    block = stack.pop();\n  if (block && !isUndefinedReference(block)) {\n    let [handleOrCompilable, scope, table] = block;\n    stack.push(table), stack.push(scope), stack.push(handleOrCompilable);\n  } else stack.push(null), stack.push(null), stack.push(null);\n}), APPEND_OPCODES.add(25, vm => {\n  let {\n      stack: stack\n    } = vm,\n    block = stack.pop();\n  block && !isUndefinedReference(block) ? stack.push(TRUE_REFERENCE) : stack.push(FALSE_REFERENCE);\n}), APPEND_OPCODES.add(26, vm => {\n  // FIXME(mmun): should only need to push the symbol table\n  vm.stack.pop(), vm.stack.pop();\n  let table = vm.stack.pop(),\n    hasBlockParams = table && table.parameters.length;\n  vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);\n}), APPEND_OPCODES.add(27, (vm, {\n  op1: count\n}) => {\n  let out = new Array(count);\n  for (let i = count; i > 0; i--) out[i - 1] = vm.stack.pop();\n  var partsRefs;\n  vm.stack.push((partsRefs = out, createComputeRef(() => {\n    const parts = [];\n    for (const ref of partsRefs) {\n      const value = valueForRef(ref);\n      null != value && parts.push(castToString(value));\n    }\n    return parts.length > 0 ? parts.join(\"\") : null;\n  })));\n}), APPEND_OPCODES.add(109, vm => {\n  let condition = vm.stack.pop(),\n    truthy = vm.stack.pop(),\n    falsy = vm.stack.pop();\n  vm.stack.push(createComputeRef(() => toBool(valueForRef(condition)) ? valueForRef(truthy) : valueForRef(falsy)));\n}), APPEND_OPCODES.add(110, vm => {\n  let ref = vm.stack.pop();\n  vm.stack.push(createComputeRef(() => !toBool(valueForRef(ref))));\n}), APPEND_OPCODES.add(111, vm => {\n  let scope = vm.dynamicScope(),\n    stack = vm.stack,\n    nameRef = stack.pop();\n  stack.push(createComputeRef(() => {\n    let name = String(valueForRef(nameRef));\n    return valueForRef(scope.get(name));\n  }));\n}), APPEND_OPCODES.add(112, vm => {\n  let {\n    positional: positional\n  } = vm.stack.pop().capture();\n  vm.loadValue($v0, createComputeRef(() => {\n    // eslint-disable-next-line no-console\n    console.log(...reifyPositional(positional));\n  }));\n});\nclass DynamicTextContent {\n  constructor(node, reference, lastValue) {\n    this.node = node, this.reference = reference, this.lastValue = lastValue;\n  }\n  evaluate() {\n    let normalized,\n      value = valueForRef(this.reference),\n      {\n        lastValue: lastValue\n      } = this;\n    value !== lastValue && (normalized = isEmpty$2(value) ? \"\" : isString(value) ? value : String(value), normalized !== lastValue) && (this.node.nodeValue = this.lastValue = normalized);\n  }\n}\nfunction toContentType(value) {\n  return function (value) {\n    return isString(value) || isEmpty$2(value) || \"boolean\" == typeof value || \"number\" == typeof value;\n  }(value) ? ContentType.String : isCurriedType(value, 0) || hasInternalComponentManager(value) ? ContentType.Component : isCurriedType(value, 1) || hasInternalHelperManager(value) ? ContentType.Helper : isSafeString(value) ? ContentType.SafeString : function (value) {\n    return isIndexable(value) && 11 === value.nodeType;\n  }(value) ? ContentType.Fragment : function (value) {\n    return isIndexable(value) && \"number\" == typeof value.nodeType;\n  }(value) ? ContentType.Node : ContentType.String;\n}\nfunction toDynamicContentType(value) {\n  if (!isIndexable$1(value)) return ContentType.String;\n  if (isCurriedType(value, 0) || hasInternalComponentManager(value)) return ContentType.Component;\n  if (true && !isCurriedType(value, 1) && !hasInternalHelperManager(value)) throw new Error(\n  // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme\n  `Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: ${value}`);\n  return ContentType.Helper;\n}\nfunction debugCallback(context, get) {\n  // eslint-disable-next-line no-console\n  console.info(\"Use `context`, and `get(<path>)` to debug this template.\"), get(\"this\");\n  // eslint-disable-next-line no-debugger\n  debugger;\n}\nAPPEND_OPCODES.add(76, vm => {\n  let reference = vm.stack.peek();\n  vm.stack.push(toContentType(valueForRef(reference))), isConstRef(reference) || vm.updateWith(new AssertFilter(reference, toContentType));\n}), APPEND_OPCODES.add(106, vm => {\n  let reference = vm.stack.peek();\n  vm.stack.push(toDynamicContentType(valueForRef(reference))), isConstRef(reference) || vm.updateWith(new AssertFilter(reference, toDynamicContentType));\n}), APPEND_OPCODES.add(43, vm => {\n  let reference = vm.stack.pop(),\n    rawValue = valueForRef(reference),\n    value = isEmpty$2(rawValue) ? \"\" : String(rawValue);\n  vm.tree().appendDynamicHTML(value);\n}), APPEND_OPCODES.add(44, vm => {\n  let reference = vm.stack.pop(),\n    rawValue = valueForRef(reference).toHTML(),\n    value = isEmpty$2(rawValue) ? \"\" : rawValue;\n  vm.tree().appendDynamicHTML(value);\n}), APPEND_OPCODES.add(47, vm => {\n  let reference = vm.stack.pop(),\n    rawValue = valueForRef(reference),\n    value = isEmpty$2(rawValue) ? \"\" : String(rawValue),\n    node = vm.tree().appendDynamicText(value);\n  isConstRef(reference) || vm.updateWith(new DynamicTextContent(node, reference, value));\n}), APPEND_OPCODES.add(45, vm => {\n  let reference = vm.stack.pop(),\n    value = valueForRef(reference);\n  vm.tree().appendDynamicFragment(value);\n}), APPEND_OPCODES.add(46, vm => {\n  let reference = vm.stack.pop(),\n    value = valueForRef(reference);\n  vm.tree().appendDynamicNode(value);\n});\nlet callback = debugCallback;\n\n// For testing purposes\nfunction setDebuggerCallback(cb) {\n  callback = cb;\n}\nfunction resetDebuggerCallback() {\n  callback = debugCallback;\n}\nclass ScopeInspector {\n  #symbols;\n  constructor(scope, symbols) {\n    this.scope = scope, this.#symbols = symbols;\n  }\n  get(path) {\n    let ref,\n      {\n        scope: scope\n      } = this,\n      symbols = this.#symbols,\n      parts = path.split(\".\"),\n      [head, ...tail] = path.split(\".\");\n    return \"this\" === head ? ref = scope.getSelf() : symbols.locals[head] ? ref = scope.getSymbol(symbols.locals[head]) : (ref = this.scope.getSelf(), tail = parts), tail.reduce((r, part) => childRefFor(r, part), ref);\n  }\n}\nAPPEND_OPCODES.add(103, (vm, {\n  op1: _debugInfo\n}) => {\n  let debuggerInfo = vm.constants.getValue(_debugInfo),\n    inspector = new ScopeInspector(vm.scope(), debuggerInfo);\n  callback(valueForRef(vm.getSelf()), path => valueForRef(inspector.get(path)));\n}), APPEND_OPCODES.add(72, (vm, {\n  op1: relativeStart,\n  op2: elseTarget\n}) => {\n  let stack = vm.stack,\n    listRef = stack.pop(),\n    keyRef = stack.pop(),\n    keyValue = valueForRef(keyRef),\n    key = null === keyValue ? \"@identity\" : String(keyValue),\n    iteratorRef = createIteratorRef(listRef, key),\n    iterator = valueForRef(iteratorRef);\n  vm.updateWith(new AssertFilter(iteratorRef, iterator => iterator.isEmpty())), iterator.isEmpty() ?\n  // TODO: Fix this offset, should be accurate\n  vm.lowlevel.goto(elseTarget + 1) : (vm.enterList(iteratorRef, relativeStart), vm.stack.push(iterator));\n}), APPEND_OPCODES.add(73, vm => {\n  vm.exitList();\n}), APPEND_OPCODES.add(74, (vm, {\n  op1: breaks\n}) => {\n  let item = vm.stack.peek().next();\n  null !== item ? vm.registerItem(vm.enterItem(item)) : vm.lowlevel.goto(breaks);\n});\nconst CAPABILITIES = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false\n};\nclass TemplateOnlyComponentManager {\n  getCapabilities() {\n    return CAPABILITIES;\n  }\n  getDebugName({\n    name: name\n  }) {\n    return name;\n  }\n  getSelf() {\n    return NULL_REFERENCE;\n  }\n  getDestroyable() {\n    return null;\n  }\n}\nconst TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager();\n\n// This is only exported for types, don't use this class directly\nclass TemplateOnlyComponentDefinition {\n  constructor(moduleName = \"@glimmer/component/template-only\", name = \"(unknown template-only component)\") {\n    this.moduleName = moduleName, this.name = name;\n  }\n  toString() {\n    return this.moduleName;\n  }\n}\n\n/**\n  This utility function is used to declare a given component has no backing class. When the rendering engine detects this it\n  is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_\n  without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).\n  Specifically, this means that the template will be rendered as \"outer HTML\".\n\n  In general, this method will be used by build time tooling and would not be directly written in an application. However,\n  at times it may be useful to use directly to leverage the \"outer HTML\" semantics mentioned above. For example, if an addon would like\n  to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the\n  `template-only-glimmer-components` optional feature.\n\n  @example\n\n  ```js\n  import { templateOnlyComponent } from '@glimmer/runtime';\n\n  export default templateOnlyComponent();\n  ```\n\n  @public\n  @method templateOnly\n  @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes\n  @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE\n*/\nfunction templateOnlyComponent(moduleName, name) {\n  return new TemplateOnlyComponentDefinition(moduleName, name);\n}\n\n// http://www.w3.org/TR/html/syntax.html#html-integration-point\nsetInternalComponentManager(TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition.prototype);\nconst SVG_INTEGRATION_POINTS = {\n    foreignObject: 1,\n    desc: 1,\n    title: 1\n  },\n  BLACKLIST_TABLE = Object.create(null);\n\n// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes\n// TODO: Adjust SVG attributes\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\n// TODO: Adjust SVG elements\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\nclass DOMOperations {\n  constructor(document) {\n    this.document = document, this.setupUselessElement();\n  }\n  // split into separate method so that NodeDOMTreeConstruction\n  // can override it.\n  setupUselessElement() {\n    this.uselessElement = this.document.createElement(\"div\");\n  }\n  createElement(tag, context) {\n    let isElementInSVGNamespace, isHTMLIntegrationPoint, isElementInMathMlNamespace, ns;\n    if (context ? (isElementInSVGNamespace = context.namespaceURI === NS_SVG || \"svg\" === tag, isElementInMathMlNamespace = context.namespaceURI === NS_MATHML || \"math\" === tag, isHTMLIntegrationPoint = !!SVG_INTEGRATION_POINTS[context.tagName]) : (isElementInSVGNamespace = \"svg\" === tag, isElementInMathMlNamespace = \"math\" === tag, isHTMLIntegrationPoint = false), !isElementInMathMlNamespace && !isElementInSVGNamespace || isHTMLIntegrationPoint) return this.document.createElement(tag);\n    // FIXME: This does not properly handle <font> with color, face, or\n    // size attributes, which is also disallowed by the spec. We should fix\n    // this.\n    if (BLACKLIST_TABLE[tag]) throw new Error(`Cannot create a ${tag} inside an SVG context`);\n    return ns = isElementInMathMlNamespace ? NS_MATHML : NS_SVG, this.document.createElementNS(ns, tag);\n  }\n  insertBefore(parent, node, reference) {\n    parent.insertBefore(node, reference);\n  }\n  insertHTMLBefore(parent, nextSibling, html) {\n    if (\"\" === html) {\n      const comment = this.createComment(\"\");\n      return parent.insertBefore(comment, nextSibling), new ConcreteBounds(parent, comment, comment);\n    }\n    const prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n    let last;\n    if (null === nextSibling) parent.insertAdjacentHTML(\"beforeend\", html), last = parent.lastChild;else if (nextSibling instanceof HTMLElement) nextSibling.insertAdjacentHTML(\"beforebegin\", html), last = nextSibling.previousSibling;else {\n      // Non-element nodes do not support insertAdjacentHTML, so add an\n      // element and call it on that element. Then remove the element.\n      // This also protects Edge, IE and Firefox w/o the inspector open\n      // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts\n      const {\n        uselessElement: uselessElement\n      } = this;\n      parent.insertBefore(uselessElement, nextSibling), uselessElement.insertAdjacentHTML(\"beforebegin\", html), last = uselessElement.previousSibling, parent.removeChild(uselessElement);\n    }\n    const first = prev ? prev.nextSibling : parent.firstChild;\n    return new ConcreteBounds(parent, first, last);\n  }\n  createTextNode(text) {\n    return this.document.createTextNode(text);\n  }\n  createComment(data) {\n    return this.document.createComment(data);\n  }\n}\n\n// Patch:    insertAdjacentHTML on SVG Fix\n// Browsers: Safari, IE, Edge, Firefox ~33-34\n// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is\n//           present but throws an exception on IE and Edge. Old versions of\n//           Firefox create nodes in the incorrect namespace.\n// Fix:      Since IE and Edge silently fail to create SVG nodes using\n//           innerHTML, and because Firefox may create nodes in the incorrect\n//           namespace using innerHTML on SVG elements, an HTML-string wrapping\n//           approach is used. A pre/post SVG tag is added to the string, then\n//           that whole string is added to a div. The created nodes are plucked\n//           out and applied to the target location on DOM.\nfunction applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {\n  if (!document) return DOMClass;\n  if (!function (document, svgNamespace) {\n    const svg = document.createElementNS(svgNamespace, \"svg\");\n    try {\n      svg.insertAdjacentHTML(\"beforeend\", \"<circle></circle>\");\n    } catch {\n      // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG\n      // Safari: Will throw, insertAdjacentHTML is not present on SVG\n    } finally {\n      // FF: Old versions will create a node in the wrong namespace\n      return 1 !== svg.childNodes.length || svg.firstChild.namespaceURI !== NS_SVG;\n      // eslint-disable-next-line no-unsafe-finally\n    }\n  }\n  // Patch:    Adjacent text node merging fix\n  // Browsers: IE, Edge, Firefox w/o inspector open\n  // Reason:   These browsers will merge adjacent text nodes. For example given\n  //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers\n  //           with proper behavior will populate div.childNodes with two items.\n  //           These browsers will populate it with one merged node instead.\n  // Fix:      Add these nodes to a wrapper element, then iterate the childNodes\n  //           of that wrapper and move the nodes to their target location. Note\n  //           that potential SVG bugs will have been handled before this fix.\n  //           Note that this fix must only apply to the previous text node, as\n  //           the base implementation of `insertHTMLBefore` already handles\n  //           following text nodes correctly.\n  (document, svgNamespace)) return DOMClass;\n  const div = document.createElement(\"div\");\n  return class extends DOMClass {\n    insertHTMLBefore(parent, nextSibling, html) {\n      return \"\" === html || parent.namespaceURI !== svgNamespace ? super.insertHTMLBefore(parent, nextSibling, html) : function (parent, div, html, reference) {\n        let source;\n        // This is important, because descendants of the <foreignObject> integration\n        // point are parsed in the HTML namespace\n        if (\"FOREIGNOBJECT\" === parent.tagName.toUpperCase()) {\n          // IE, Edge: also do not correctly support using `innerHTML` on SVG\n          // namespaced elements. So here a wrapper is used.\n          const wrappedHtml = \"<svg><foreignObject>\" + html + \"</foreignObject></svg>\";\n          clearElement(div), div.insertAdjacentHTML(\"afterbegin\", wrappedHtml),\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          source = div.firstChild.firstChild;\n        } else {\n          // IE, Edge: also do not correctly support using `innerHTML` on SVG\n          // namespaced elements. So here a wrapper is used.\n          const wrappedHtml = \"<svg>\" + html + \"</svg>\";\n          clearElement(div), div.insertAdjacentHTML(\"afterbegin\", wrappedHtml),\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n          source = div.firstChild;\n        }\n        return function (source, target, nextSibling) {\n          const first = source.firstChild;\n          let last = first,\n            current = first;\n          for (; current;) {\n            const next = current.nextSibling;\n            target.insertBefore(current, nextSibling), last = current, current = next;\n          }\n          return new ConcreteBounds(target, first, last);\n        }(source, parent, reference);\n      }(parent, div, html, nextSibling);\n    }\n  };\n}\nfunction applyTextNodeMergingFix(document, DOMClass) {\n  return document && function (document) {\n    const mergingTextDiv = document.createElement(\"div\");\n    return mergingTextDiv.appendChild(document.createTextNode(\"first\")), mergingTextDiv.insertAdjacentHTML(\"beforeend\", \"second\"), 2 !== mergingTextDiv.childNodes.length;\n  }(document) ? class extends DOMClass {\n    constructor(document) {\n      super(document), this.uselessComment = document.createComment(\"\");\n    }\n    insertHTMLBefore(parent, nextSibling, html) {\n      if (\"\" === html) return super.insertHTMLBefore(parent, nextSibling, html);\n      let didSetUselessComment = false;\n      const nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n      nextPrevious && nextPrevious instanceof Text && (didSetUselessComment = true, parent.insertBefore(this.uselessComment, nextSibling));\n      const bounds = super.insertHTMLBefore(parent, nextSibling, html);\n      return didSetUselessComment && parent.removeChild(this.uselessComment), bounds;\n    }\n  } : DOMClass;\n}\nconst doc$1 = \"undefined\" == typeof document ? null : castToSimple(document);\nlet appliedTreeConstruction = class extends DOMOperations {\n  createElementNS(namespace, tag) {\n    return this.document.createElementNS(namespace, tag);\n  }\n  setAttribute(element, name, value, namespace = null) {\n    namespace ? element.setAttributeNS(namespace, name, value) : element.setAttribute(name, value);\n  }\n};\nappliedTreeConstruction = applyTextNodeMergingFix(doc$1, appliedTreeConstruction), appliedTreeConstruction = applySVGInnerHTMLFix(doc$1, appliedTreeConstruction, NS_SVG);\nconst DOMTreeConstruction = appliedTreeConstruction;\n[\"b\", \"big\", \"blockquote\", \"body\", \"br\", \"center\", \"code\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"hr\", \"i\", \"img\", \"li\", \"listing\", \"main\", \"meta\", \"nobr\", \"ol\", \"p\", \"pre\", \"ruby\", \"s\", \"small\", \"span\", \"strong\", \"strike\", \"sub\", \"sup\", \"table\", \"tt\", \"u\", \"ul\", \"var\"].forEach(tag => BLACKLIST_TABLE[tag] = 1);\nconst WHITESPACE = /[\\t\\n\\v\\f\\r \\xa0\\u{1680}\\u{180e}\\u{2000}-\\u{200a}\\u{2028}\\u{2029}\\u{202f}\\u{205f}\\u{3000}\\u{feff}]/u,\n  doc = \"undefined\" == typeof document ? null : castToSimple(document);\nfunction isWhitespace(string) {\n  return WHITESPACE.test(string);\n}\nclass DOMChangesImpl extends DOMOperations {\n  constructor(document1) {\n    super(document1), this.document = document1, this.namespace = null;\n  }\n  setAttribute(element, name, value) {\n    element.setAttribute(name, value);\n  }\n  removeAttribute(element, name) {\n    element.removeAttribute(name);\n  }\n  insertAfter(element, node, reference) {\n    this.insertBefore(element, node, reference.nextSibling);\n  }\n}\nlet helper = DOMChangesImpl;\nhelper = applyTextNodeMergingFix(doc, helper), helper = applySVGInnerHTMLFix(doc, helper, NS_SVG);\nconst DOMChanges = helper;\n\n/*\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nfunction normalizeProperty(element, slotName) {\n  let type, normalized;\n  if (slotName in element) normalized = slotName, type = \"prop\";else {\n    let lower = slotName.toLowerCase();\n    lower in element ? (type = \"prop\", normalized = lower) : (type = \"attr\", normalized = slotName);\n  }\n  return \"prop\" !== type || \"style\" !== normalized.toLowerCase() && !function (tagName, propName) {\n    let tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n    return !(!tag || !tag[propName.toLowerCase()]);\n  }(element.tagName, normalized) || (type = \"attr\"), {\n    normalized: normalized,\n    type: type\n  };\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nconst ATTR_OVERRIDES = {\n    INPUT: {\n      form: true,\n      // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n      // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n      // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n      autocorrect: true,\n      // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true\n      // Safari 9.1.3: 'list' in document.createElement('input') === false\n      list: true\n    },\n    // element.form is actually a legitimate readOnly property, that is to be\n    // mutated, but must be mutated by setAttribute...\n    SELECT: {\n      form: true\n    },\n    OPTION: {\n      form: true\n    },\n    TEXTAREA: {\n      form: true\n    },\n    LABEL: {\n      form: true\n    },\n    FIELDSET: {\n      form: true\n    },\n    LEGEND: {\n      form: true\n    },\n    OBJECT: {\n      form: true\n    },\n    OUTPUT: {\n      form: true\n    },\n    BUTTON: {\n      form: true\n    }\n  },\n  TRANSACTION = Symbol(\"TRANSACTION\");\nclass TransactionImpl {\n  didCreate(component) {\n    this.createdComponents.push(component);\n  }\n  didUpdate(component) {\n    this.updatedComponents.push(component);\n  }\n  scheduleInstallModifier(modifier) {\n    this.scheduledInstallModifiers.push(modifier);\n  }\n  scheduleUpdateModifier(modifier) {\n    this.scheduledUpdateModifiers.push(modifier);\n  }\n  commit() {\n    let {\n      createdComponents: createdComponents,\n      updatedComponents: updatedComponents\n    } = this;\n    for (const {\n      manager: manager,\n      state: state\n    } of createdComponents) manager.didCreate(state);\n    for (const {\n      manager: manager,\n      state: state\n    } of updatedComponents) manager.didUpdate(state);\n    let {\n      scheduledInstallModifiers: scheduledInstallModifiers,\n      scheduledUpdateModifiers: scheduledUpdateModifiers\n    } = this;\n    for (const {\n      manager: manager,\n      state: state,\n      definition: definition\n    } of scheduledInstallModifiers) {\n      let modifierTag = manager.getTag(state);\n      if (null !== modifierTag) {\n        let tag = track(() => manager.install(state), true && `- While rendering:\\n  (instance of a \\`${definition.resolvedName || manager.getDebugName(definition.state)}\\` modifier)`);\n        UPDATE_TAG(modifierTag, tag);\n      } else manager.install(state);\n    }\n    for (const {\n      manager: manager,\n      state: state,\n      definition: definition\n    } of scheduledUpdateModifiers) {\n      let modifierTag = manager.getTag(state);\n      if (null !== modifierTag) {\n        let tag = track(() => manager.update(state), true && `- While rendering:\\n  (instance of a \\`${definition.resolvedName || manager.getDebugName(definition.state)}\\` modifier)`);\n        UPDATE_TAG(modifierTag, tag);\n      } else manager.update(state);\n    }\n  }\n  constructor() {\n    this.scheduledInstallModifiers = [], this.scheduledUpdateModifiers = [], this.createdComponents = [], this.updatedComponents = [];\n  }\n}\nclass EnvironmentImpl {\n  static {\n    _TRANSACTION = TRANSACTION;\n  }\n  constructor(options, delegate) {\n    if (this.delegate = delegate, this[_TRANSACTION] = null, this.isInteractive = delegate.isInteractive, this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTreeImpl() : void 0, this.isArgumentCaptureError = this.delegate.enableDebugTooling ? isArgumentError : void 0, options.appendOperations) this.appendOperations = options.appendOperations, this.updateOperations = options.updateOperations;else if (options.document) this.appendOperations = new DOMTreeConstruction(options.document), this.updateOperations = new DOMChangesImpl(options.document);else if (true) throw new Error(\"you must pass document or appendOperations to a new runtime\");\n  }\n  getAppendOperations() {\n    return this.appendOperations;\n  }\n  getDOM() {\n    return this.updateOperations;\n  }\n  begin() {\n    this[TRANSACTION], this.debugRenderTree?.begin(), this[TRANSACTION] = new TransactionImpl();\n  }\n  get transaction() {\n    return this[TRANSACTION];\n  }\n  didCreate(component) {\n    this.transaction.didCreate(component);\n  }\n  didUpdate(component) {\n    this.transaction.didUpdate(component);\n  }\n  scheduleInstallModifier(modifier) {\n    this.isInteractive && this.transaction.scheduleInstallModifier(modifier);\n  }\n  scheduleUpdateModifier(modifier) {\n    this.isInteractive && this.transaction.scheduleUpdateModifier(modifier);\n  }\n  commit() {\n    let transaction = this.transaction;\n    this[TRANSACTION] = null, transaction.commit(), this.debugRenderTree?.commit(), this.delegate.onTransactionCommit();\n  }\n}\nfunction runtimeOptions(options, delegate, artifacts, resolver) {\n  return {\n    env: new EnvironmentImpl(options, delegate),\n    program: new ProgramImpl(artifacts.constants, artifacts.heap),\n    resolver: resolver\n  };\n}\nfunction inTransaction(env, block) {\n  if (env[TRANSACTION]) block();else {\n    env.begin();\n    try {\n      block();\n    } finally {\n      env.commit();\n    }\n  }\n}\nvar _TRANSACTION;\nfunction internalHelper(helper) {\n  return setInternalHelperManager(helper, {});\n}\n\n/**\n   Use the `{{array}}` helper to create an array to pass as an option to your\n   components.\n\n   ```handlebars\n   <MyComponent @people={{array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson}}\n   />\n   ```\n    or\n   ```handlebars\n   {{my-component people=(array\n     'Tom Dale'\n     'Yehuda Katz'\n     this.myOtherPerson)\n   }}\n   ```\n\n   Would result in an object such as:\n\n   ```js\n   ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]\n   ```\n\n   Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.\n\n   @method array\n   @param {Array} options\n   @return {Array} Array\n   @public\n */\nconst array = internalHelper(({\n    positional: positional\n  }) => createComputeRef(() => reifyPositional(positional), null, \"array\")),\n  normalizeTextValue = value => (value => null == value || \"function\" != typeof value.toString)(value) ? \"\" : String(value),\n  concat = internalHelper(({\n    positional: positional\n  }) => createComputeRef(() => reifyPositional(positional).map(normalizeTextValue).join(\"\"), null, \"concat\")),\n  context = buildUntouchableThis(\"`fn` helper\"),\n  fn = internalHelper(({\n    positional: positional\n  }) => {\n    let callbackRef = positional[0];\n    return createComputeRef(() => (...invocationArgs) => {\n      let [fn, ...args] = reifyPositional(positional);\n      if (true && function (callbackRef) {\n        if (!callbackRef || !isInvokableRef(callbackRef) && \"function\" != typeof valueForRef(callbackRef)) throw new Error(`You must pass a function as the \\`fn\\` helper's first argument, you passed ${callbackRef ? valueForRef(callbackRef) : callbackRef}. While rendering:\\n\\n${callbackRef?.debugLabel}`);\n      }\n      /**\n      Dynamically look up a property on an object. The second argument to `{{get}}`\n      should have a string value, although it can be bound.\n      For example, these two usages are equivalent:\n      ```app/components/developer-detail.js\n      import Component from '@glimmer/component';\n      import { tracked } from '@glimmer/tracking';\n      export default class extends Component {\n      @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n      }\n      }\n      ```\n      ```handlebars\n      {{this.developer.name}}\n      {{get this.developer \"name\"}}\n      ```\n      If there were several facts about a person, the `{{get}}` helper can dynamically\n      pick one:\n      ```app/templates/application.hbs\n      <DeveloperDetail @factName=\"language\" />\n      ```\n      ```handlebars\n      {{get this.developer @factName}}\n      ```\n      For a more complex example, this template would allow the user to switch\n      between showing the user's height and weight with a click:\n      ```app/components/developer-detail.js\n      import Component from '@glimmer/component';\n      import { tracked } from '@glimmer/tracking';\n      export default class extends Component {\n      @tracked developer = {\n      name: \"Sandi Metz\",\n      language: \"Ruby\"\n      }\n      @tracked currentFact = 'name'\n      showFact = (fact) => {\n      this.currentFact = fact;\n      }\n      }\n      ```\n      ```app/components/developer-detail.js\n      {{get this.developer this.currentFact}}\n      <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n      <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n      ```\n      The `{{get}}` helper can also respect mutable values itself. For example:\n      ```app/components/developer-detail.js\n      <Input @value={{mut (get this.person this.currentFact)}} />\n      <button {{on 'click' (fn this.showFact \"name\")}}>Show name</button>\n      <button {{on 'click' (fn this.showFact \"language\")}}>Show language</button>\n      ```\n      Would allow the user to swap what fact is being displayed, and also edit\n      that fact via a two-way mutable binding.\n      @public\n      @method get\n      */(callbackRef), !isInvokableRef(callbackRef))\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return -- @fixme\n        return fn.call(context, ...args, ...invocationArgs);\n      {\n        let value = args.length > 0 ? args[0] : invocationArgs[0];\n        updateRef(callbackRef, value);\n      }\n    }, null, \"fn\");\n  }),\n  get = internalHelper(({\n    positional: positional\n  }) => {\n    let sourceRef = positional[0] ?? UNDEFINED_REFERENCE,\n      pathRef = positional[1] ?? UNDEFINED_REFERENCE;\n    return createComputeRef(() => {\n      let source = valueForRef(sourceRef);\n      if (isDict(source)) return getPath(source, String(valueForRef(pathRef)));\n    }, value => {\n      let source = valueForRef(sourceRef);\n      if (isDict(source)) return setPath(source, String(valueForRef(pathRef)), value);\n    }, \"get\");\n  }),\n  hash = internalHelper(({\n    named: named\n  }) => {\n    let ref = createComputeRef(() => reifyNamed(named), null, \"hash\"),\n      children = new Map();\n    // Setup the children so that templates can bypass getting the value of\n    // the reference and treat children lazily\n    for (let name in named) children.set(name, named[name]);\n    return ref.children = children, ref;\n  });\nlet ARGS_CACHES = true ? new WeakMap() : void 0;\nfunction getArgs(proxy) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return getValue(true ? ARGS_CACHES.get(proxy) : proxy.argsCache);\n}\nclass SimpleArgsProxy {\n  constructor(context, computeArgs = () => EMPTY_ARGS) {\n    let argsCache = createCache(() => computeArgs(context));\n    true ? (\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    ARGS_CACHES.set(this, argsCache), Object.freeze(this)) : this.argsCache = argsCache;\n  }\n  get named() {\n    return getArgs(this).named || EMPTY_NAMED;\n  }\n  get positional() {\n    return getArgs(this).positional || EMPTY_POSITIONAL;\n  }\n}\n\n////////////\nfunction invokeHelper(context, definition, computeArgs) {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS usage\n  if (true && (\"object\" != typeof context || null === context)) throw new Error(`Expected a context object to be passed as the first parameter to invokeHelper, got ${context}`);\n  const owner = getOwner(context),\n    internalManager = getInternalHelperManager(definition);\n  if (true && \"function\" == typeof internalManager) throw new Error(\"Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.\");\n  const manager = internalManager.getDelegateFor(owner);\n  let cache,\n    args = new SimpleArgsProxy(context, computeArgs),\n    bucket = manager.createHelper(definition, args);\n  if (!hasValue(manager)) throw new Error(\"TODO: unreachable, to be implemented with hasScheduledEffect\");\n  if (cache = createCache(() => {\n    if (true && (isDestroying(cache) || isDestroyed(cache))) throw new Error(\"You attempted to get the value of a helper after the helper was destroyed, which is not allowed\");\n    return manager.getValue(bucket);\n  }), associateDestroyableChild(context, cache), hasDestroyable(manager)) {\n    let destroyable = manager.getDestroyable(bucket);\n    associateDestroyableChild(cache, destroyable);\n  }\n  return cache;\n}\nconst untouchableContext = buildUntouchableThis(\"`on` modifier\");\nclass OnModifierState {\n  constructor(element, args) {\n    this.tag = createUpdatableTag(), this.listener = null, this.element = element, this.args = args, registerDestructor(this, () => {\n      let {\n        element: element,\n        listener: listener\n      } = this;\n      if (listener) {\n        let {\n          eventName: eventName,\n          callback: callback,\n          options: options\n        } = listener;\n        removeEventListener(element, eventName, callback, options);\n      }\n    });\n  }\n  // Update this.listener if needed\n  updateListener() {\n    let {\n      element: element,\n      args: args,\n      listener: listener\n    } = this;\n    args.positional[0];\n    let eventName = valueForRef(args.positional[0]);\n    args.positional[1];\n    let once,\n      passive,\n      capture,\n      userProvidedCallback = valueForRef(args.positional[1]);\n    if (true && 2 !== args.positional.length) throw new Error(`You can only pass two positional arguments (event name and callback) to the \\`on\\` modifier, but you provided ${args.positional.length}. Consider using the \\`fn\\` helper to provide additional arguments to the \\`on\\` callback.`);\n    if (true) {\n      let {\n        once: _once,\n        passive: _passive,\n        capture: _capture,\n        ...extra\n      } = reifyNamed(args.named);\n      if (once = _once, passive = _passive, capture = _capture, Object.keys(extra).length > 0) throw new Error(`You can only \\`once\\`, \\`passive\\` or \\`capture\\` named arguments to the \\`on\\` modifier, but you provided ${Object.keys(extra).join(\", \")}.`);\n    } else {\n      let {\n        once: _once,\n        passive: _passive,\n        capture: _capture\n      } = args.named;\n      _once && (once = valueForRef(_once)), _passive && (passive = valueForRef(_passive)), _capture && (capture = valueForRef(_capture));\n    }\n    let options,\n      shouldUpdate = false;\n    if (shouldUpdate = null === listener || eventName !== listener.eventName || userProvidedCallback !== listener.userProvidedCallback || once !== listener.once || passive !== listener.passive || capture !== listener.capture,\n    // we want to handle both `true` and `false` because both have a meaning:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=770208\n    shouldUpdate && (void 0 === once && void 0 === passive && void 0 === capture || (options = {\n      once: once,\n      passive: passive,\n      capture: capture\n    })), shouldUpdate) {\n      let callback = userProvidedCallback;\n      if (true && (callback = userProvidedCallback.bind(untouchableContext), passive)) {\n        let _callback = callback;\n        callback = event => (event.preventDefault = () => {\n          throw new Error(`You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \\n\\n${userProvidedCallback.name || \"{anonymous function}\"}`);\n        }, _callback(event));\n      }\n      this.listener = {\n        eventName: eventName,\n        callback: callback,\n        userProvidedCallback: userProvidedCallback,\n        once: once,\n        passive: passive,\n        capture: capture,\n        options: options\n      }, listener && removeEventListener(element, listener.eventName, listener.callback, listener.options), function (element, eventName, callback, options) {\n        adds++, element.addEventListener(eventName, callback, options);\n      }\n      /**\n      The `{{on}}` modifier lets you easily add event listeners (it uses\n      [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)\n      internally).\n      For example, if you'd like to run a function on your component when a `<button>`\n      in the components template is clicked you might do something like:\n      ```app/components/like-post.hbs\n      <button {{on 'click' this.saveLike}}>Like this post!</button>\n      ```\n      ```app/components/like-post.js\n      import Component from '@glimmer/component';\n      import { action } from '@ember/object';\n      export default class LikePostComponent extends Component {\n      saveLike = () => {\n      // someone likes your post!\n      // better send a request off to your server...\n      }\n      }\n      ```\n      ### Arguments\n      `{{on}}` accepts two positional arguments, and a few named arguments.\n      The positional arguments are:\n      - `event` -- the name to use when calling `addEventListener`\n      - `callback` -- the function to be passed to `addEventListener`\n      The named arguments are:\n      - capture -- a `true` value indicates that events of this type will be dispatched\n      to the registered listener before being dispatched to any EventTarget beneath it\n      in the DOM tree.\n      - once -- indicates that the listener should be invoked at most once after being\n      added. If true, the listener would be automatically removed when invoked.\n      - passive -- if `true`, indicates that the function specified by listener will never\n      call preventDefault(). If a passive listener does call preventDefault(), the user\n      agent will do nothing other than generate a console warning. See\n      [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)\n      to learn more.\n      The callback function passed to `{{on}}` will receive any arguments that are passed\n      to the event handler. Most commonly this would be the `event` itself.\n      If you would like to pass additional arguments to the function you should use\n      the `{{fn}}` helper.\n      For example, in our example case above if you'd like to pass in the post that\n      was being liked when the button is clicked you could do something like:\n      ```app/components/like-post.hbs\n      <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>\n      ```\n      In this case, the `saveLike` function will receive two arguments: the click event\n      and the value of `@post`.\n      ### Function Context\n      In the example above, we used an arrow function to ensure that `likePost` is\n      properly bound to the `items-list`, but let's explore what happens if we\n      left out the arrow function:\n      ```app/components/like-post.js\n      import Component from '@glimmer/component';\n      export default class LikePostComponent extends Component {\n      saveLike() {\n      // ...snip...\n      }\n      }\n      ```\n      In this example, when the button is clicked `saveLike` will be invoked,\n      it will **not** have access to the component instance. In other\n      words, it will have no `this` context, so please make sure your functions\n      are bound (via an arrow function or other means) before passing into `on`!\n      @method on\n      @public\n      */(element, eventName, callback, options);\n    }\n  }\n}\nlet adds = 0,\n  removes = 0;\nfunction removeEventListener(element, eventName, callback, options) {\n  removes++, element.removeEventListener(eventName, callback, options);\n}\nconst on = setInternalModifierManager(new class {\n  getDebugName() {\n    return \"on\";\n  }\n  getDebugInstance() {\n    return null;\n  }\n  get counters() {\n    return {\n      adds: adds,\n      removes: removes\n    };\n  }\n  create(_owner, element, _state, args) {\n    return new OnModifierState(element, args);\n  }\n  getTag({\n    tag: tag\n  }) {\n    return tag;\n  }\n  install(state) {\n    state.updateListener();\n  }\n  update(state) {\n    state.updateListener();\n  }\n  getDestroyable(state) {\n    return state;\n  }\n}(), {});\nclass LowLevelVM {\n  constructor(stack, context, externs, registers) {\n    this.stack = stack, this.externs = externs, this.currentOpSize = 0, this.context = context, this.registers = registers;\n  }\n  fetchRegister(register) {\n    return this.registers[register];\n  }\n  loadRegister(register, value) {\n    this.registers[register] = value;\n  }\n  setPc(pc) {\n    this.registers[$pc] = pc;\n  }\n  // Start a new frame and save $ra and $fp on the stack\n  pushFrame() {\n    this.stack.push(this.registers[$ra]), this.stack.push(this.registers[$fp]), this.registers[$fp] = this.registers[$sp] - 1;\n  }\n  // Restore $ra, $sp and $fp\n  popFrame() {\n    this.registers[$sp] = this.registers[$fp] - 1, this.registers[$ra] = this.stack.get(0), this.registers[$fp] = this.stack.get(1);\n  }\n  pushSmallFrame() {\n    this.stack.push(this.registers[$ra]);\n  }\n  popSmallFrame() {\n    this.registers[$ra] = this.stack.pop();\n  }\n  // Jump to an address in `program`\n  goto(offset) {\n    this.setPc(this.target(offset));\n  }\n  target(offset) {\n    return this.registers[$pc] + offset - this.currentOpSize;\n  }\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle) {\n    this.registers[$ra] = this.registers[$pc], this.setPc(this.context.program.heap.getaddr(handle));\n  }\n  // Put a specific `program` address in $ra\n  returnTo(offset) {\n    this.registers[$ra] = this.target(offset);\n  }\n  // Return to the `program` address stored in $ra\n  return() {\n    this.setPc(this.registers[$ra]);\n  }\n  nextStatement() {\n    let {\n        registers: registers,\n        context: context\n      } = this,\n      pc = registers[$pc];\n    if (-1 === pc) return null;\n    // We have to save off the current operations size so that\n    // when we do a jump we can calculate the correct offset\n    // to where we are going. We can't simply ask for the size\n    // in a jump because we have have already incremented the\n    // program counter to the next instruction prior to executing.\n    let opcode = context.program.opcode(pc),\n      operationSize = this.currentOpSize = opcode.size;\n    return this.registers[$pc] += operationSize, opcode;\n  }\n  evaluateOuter(opcode, vm) {\n    this.evaluateInner(opcode, vm);\n  }\n  evaluateInner(opcode, vm) {\n    opcode.isMachine ? this.evaluateMachine(opcode, vm) : this.evaluateSyscall(opcode, vm);\n  }\n  evaluateMachine(opcode, vm) {\n    switch (opcode.type) {\n      case 0:\n        return void this.pushFrame();\n      case 1:\n        return void this.popFrame();\n      case 3:\n        return void this.call(opcode.op1);\n      case 2:\n        return void vm.call(this.stack.pop());\n      case 4:\n        return void this.goto(opcode.op1);\n      case 5:\n        return void vm.return();\n      case 6:\n        return void this.returnTo(opcode.op1);\n    }\n  }\n  evaluateSyscall(opcode, vm) {\n    APPEND_OPCODES.evaluate(vm, opcode, opcode.type);\n  }\n}\nconst badProtocols = [\"javascript:\", \"vbscript:\"],\n  badTags = [\"A\", \"BODY\", \"LINK\", \"IMG\", \"IFRAME\", \"BASE\", \"FORM\"],\n  badTagsForDataURI = [\"EMBED\"],\n  badAttributes = [\"href\", \"src\", \"background\", \"action\"],\n  badAttributesForDataURI = [\"src\"];\nfunction has(array, item) {\n  return -1 !== array.indexOf(item);\n}\nfunction checkURI(tagName, attribute) {\n  return (null === tagName || has(badTags, tagName)) && has(badAttributes, attribute);\n}\nfunction checkDataURI(tagName, attribute) {\n  return null !== tagName && has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);\n}\nfunction requiresSanitization(tagName, attribute) {\n  return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);\n}\nlet _protocolForUrlImplementation, DebugStyleAttributeManager;\nfunction sanitizeAttributeValue(element, attribute, value) {\n  if (null == value) return value;\n  if (isSafeString(value)) return value.toHTML();\n  const tagName = element.tagName.toUpperCase();\n  let str = normalizeStringValue(value);\n  if (checkURI(tagName, attribute)) {\n    let protocol = (url = str, _protocolForUrlImplementation || (_protocolForUrlImplementation = function () {\n      const weirdURL = URL;\n      if (\"object\" == typeof weirdURL && null !== weirdURL &&\n      // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check\n      // thinks it is `never` without this `as unknown as any`\n      \"function\" == typeof weirdURL.parse) {\n        // In Ember-land the `fastboot` package sets the `URL` global to `require('url')`\n        // ultimately, this should be changed (so that we can either rely on the natural `URL` global\n        // that exists) but for now we have to detect the specific `FastBoot` case first\n        // a future version of `fastboot` will detect if this legacy URL setup is required (by\n        // inspecting Ember version) and if new enough, it will avoid shadowing the `URL` global\n        // constructor with `require('url')`.\n        let nodeURL = weirdURL;\n        return url => {\n          let protocol = null;\n          return \"string\" == typeof url && (protocol = nodeURL.parse(url).protocol), null === protocol ? \":\" : protocol;\n        };\n      }\n      if (\"function\" == typeof weirdURL) return _url => {\n        try {\n          return new weirdURL(_url).protocol;\n        } catch {\n          // any non-fully qualified url string will trigger an error (because there is no\n          // baseURI that we can provide; in that case we **know** that the protocol is\n          // \"safe\" because it isn't specifically one of the `badProtocols` listed above\n          // (and those protocols can never be the default baseURI)\n          return \":\";\n        }\n      };\n      throw new Error('@glimmer/runtime needs a valid \"globalThis.URL\"');\n    }()), _protocolForUrlImplementation(url));\n    if (has(badProtocols, protocol)) return `unsafe:${str}`;\n  }\n  var url;\n  return checkDataURI(tagName, attribute) ? `unsafe:${str}` : str;\n}\nfunction dynamicAttribute(element, attr, namespace, isTrusting = false) {\n  const {\n      tagName: tagName,\n      namespaceURI: namespaceURI\n    } = element,\n    attribute = {\n      element: element,\n      name: attr,\n      namespace: namespace\n    };\n  if (true && \"style\" === attr && !isTrusting) return new DebugStyleAttributeManager(attribute);\n  if (namespaceURI === NS_SVG) return buildDynamicAttribute(tagName, attr, attribute);\n  const {\n    type: type,\n    normalized: normalized\n  } = normalizeProperty(element, attr);\n  return \"attr\" === type ? buildDynamicAttribute(tagName, normalized, attribute) : function (tagName, name, attribute) {\n    return requiresSanitization(tagName, name) ? new SafeDynamicProperty(name, attribute) : function (tagName, attribute) {\n      return (\"INPUT\" === tagName || \"TEXTAREA\" === tagName) && \"value\" === attribute;\n    }(tagName, name) ? new InputValueDynamicAttribute(name, attribute) : function (tagName, attribute) {\n      return \"OPTION\" === tagName && \"selected\" === attribute;\n    }(tagName, name) ? new OptionSelectedDynamicAttribute(name, attribute) : new DefaultDynamicProperty(name, attribute);\n  }(tagName, normalized, attribute);\n}\nfunction buildDynamicAttribute(tagName, name, attribute) {\n  return requiresSanitization(tagName, name) ? new SafeDynamicAttribute(attribute) : new SimpleDynamicAttribute(attribute);\n}\nclass DynamicAttribute {\n  constructor(attribute) {\n    this.attribute = attribute;\n  }\n}\nclass SimpleDynamicAttribute extends DynamicAttribute {\n  set(dom, value, _env) {\n    const normalizedValue = normalizeValue(value);\n    if (null !== normalizedValue) {\n      const {\n        name: name,\n        namespace: namespace\n      } = this.attribute;\n      dom.__setAttribute(name, normalizedValue, namespace);\n    }\n  }\n  update(value, _env) {\n    const normalizedValue = normalizeValue(value),\n      {\n        element: element,\n        name: name\n      } = this.attribute;\n    null === normalizedValue ? element.removeAttribute(name) : element.setAttribute(name, normalizedValue);\n  }\n}\nclass DefaultDynamicProperty extends DynamicAttribute {\n  constructor(normalizedName, attribute) {\n    super(attribute), this.normalizedName = normalizedName;\n  }\n  set(dom, value, _env) {\n    null != value && (this.value = value, dom.__setProperty(this.normalizedName, value));\n  }\n  update(value, _env) {\n    const {\n      element: element\n    } = this.attribute;\n    this.value !== value && (element[this.normalizedName] = this.value = value, null == value && this.removeAttribute());\n  }\n  removeAttribute() {\n    // TODO this sucks but to preserve properties first and to meet current\n    // semantics we must do this.\n    const {\n      element: element,\n      namespace: namespace\n    } = this.attribute;\n    namespace ? element.removeAttributeNS(namespace, this.normalizedName) : element.removeAttribute(this.normalizedName);\n  }\n}\nclass SafeDynamicProperty extends DefaultDynamicProperty {\n  set(dom, value, env) {\n    const {\n        element: element,\n        name: name\n      } = this.attribute,\n      sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n  update(value, env) {\n    const {\n        element: element,\n        name: name\n      } = this.attribute,\n      sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\nclass SafeDynamicAttribute extends SimpleDynamicAttribute {\n  set(dom, value, env) {\n    const {\n        element: element,\n        name: name\n      } = this.attribute,\n      sanitized = sanitizeAttributeValue(element, name, value);\n    super.set(dom, sanitized, env);\n  }\n  update(value, env) {\n    const {\n        element: element,\n        name: name\n      } = this.attribute,\n      sanitized = sanitizeAttributeValue(element, name, value);\n    super.update(sanitized, env);\n  }\n}\nclass InputValueDynamicAttribute extends DefaultDynamicProperty {\n  set(dom, value) {\n    dom.__setProperty(\"value\", normalizeStringValue(value));\n  }\n  update(value) {\n    const input = this.attribute.element,\n      currentValue = input.value,\n      normalizedValue = normalizeStringValue(value);\n    currentValue !== normalizedValue && (input.value = normalizedValue);\n  }\n}\nclass OptionSelectedDynamicAttribute extends DefaultDynamicProperty {\n  set(dom, value) {\n    null != value && false !== value && dom.__setProperty(\"selected\", true);\n  }\n  update(value) {\n    this.attribute.element.selected = !!value;\n  }\n}\nfunction normalizeValue(value) {\n  return false === value || null == value || void 0 === value.toString ? null : true === value ? \"\" :\n  // onclick function etc in SSR\n  \"function\" == typeof value ? null : String(value);\n}\ntrue && (DebugStyleAttributeManager = class extends SimpleDynamicAttribute {\n  set(dom, value, env) {\n    warnIfStyleNotTrusted(value), super.set(dom, value, env);\n  }\n  update(value, env) {\n    warnIfStyleNotTrusted(value), super.update(value, env);\n  }\n});\nclass First {\n  constructor(node) {\n    this.node = node;\n  }\n  firstNode() {\n    return this.node;\n  }\n}\nclass Last {\n  constructor(node) {\n    this.node = node;\n  }\n  lastNode() {\n    return this.node;\n  }\n}\nclass NewTreeBuilder {\n  static forInitialRender(env, cursor) {\n    return new this(env, cursor.element, cursor.nextSibling).initialize();\n  }\n  static resume(env, block) {\n    let stack = new this(env, block.parentElement(), block.reset(env)).initialize();\n    return stack.pushBlock(block), stack;\n  }\n  constructor(env, parentNode, nextSibling) {\n    this.constructing = null, this.operations = null, this.cursors = new StackImpl(), this.modifierStack = new StackImpl(), this.blockStack = new StackImpl(), this.pushElement(parentNode, nextSibling), this.env = env, this.dom = env.getAppendOperations(), this.updateOperations = env.getDOM();\n  }\n  initialize() {\n    return this.pushAppendingBlock(), this;\n  }\n  debugBlocks() {\n    return this.blockStack.toArray();\n  }\n  get element() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return this.cursors.current.element;\n  }\n  get nextSibling() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    return this.cursors.current.nextSibling;\n  }\n  get hasBlocks() {\n    return this.blockStack.size > 0;\n  }\n  block() {\n    return this.blockStack.current;\n  }\n  popElement() {\n    this.cursors.pop(), this.cursors.current;\n  }\n  pushAppendingBlock() {\n    return this.pushBlock(new AppendingBlockImpl(this.element));\n  }\n  pushResettableBlock() {\n    return this.pushBlock(new ResettableBlockImpl(this.element));\n  }\n  pushBlockList(list) {\n    return this.pushBlock(new AppendingBlockList(this.element, list));\n  }\n  pushBlock(block, isRemote = false) {\n    let current = this.blockStack.current;\n    return null !== current && (isRemote || current.didAppendBounds(block)), this.__openBlock(), this.blockStack.push(block), block;\n  }\n  popBlock() {\n    return this.block().finalize(this), this.__closeBlock(), this.blockStack.pop();\n  }\n  __openBlock() {}\n  __closeBlock() {}\n  // todo return seems unused\n  openElement(tag) {\n    let element = this.__openElement(tag);\n    return this.constructing = element, element;\n  }\n  __openElement(tag) {\n    return this.dom.createElement(tag, this.element);\n  }\n  flushElement(modifiers) {\n    let parent = this.element,\n      element = this.constructing;\n    this.__flushElement(parent, element), this.constructing = null, this.operations = null, this.pushModifiers(modifiers), this.pushElement(element, null), this.didOpenElement(element);\n  }\n  __flushElement(parent, constructing) {\n    this.dom.insertBefore(parent, constructing, this.nextSibling);\n  }\n  closeElement() {\n    return this.willCloseElement(), this.popElement(), this.popModifiers();\n  }\n  pushRemoteElement(element, guid, insertBefore) {\n    return this.__pushRemoteElement(element, guid, insertBefore);\n  }\n  __pushRemoteElement(element, _guid, insertBefore) {\n    if (this.pushElement(element, insertBefore), void 0 === insertBefore) for (; element.lastChild;) element.removeChild(element.lastChild);\n    let block = new RemoteBlock(element);\n    return this.pushBlock(block, true);\n  }\n  popRemoteElement() {\n    const block = this.popBlock();\n    return this.popElement(), block;\n  }\n  pushElement(element, nextSibling = null) {\n    this.cursors.push(new CursorImpl(element, nextSibling));\n  }\n  pushModifiers(modifiers) {\n    this.modifierStack.push(modifiers);\n  }\n  popModifiers() {\n    return this.modifierStack.pop();\n  }\n  didAppendBounds(bounds) {\n    return this.block().didAppendBounds(bounds), bounds;\n  }\n  didAppendNode(node) {\n    return this.block().didAppendNode(node), node;\n  }\n  didOpenElement(element) {\n    return this.block().openElement(element), element;\n  }\n  willCloseElement() {\n    this.block().closeElement();\n  }\n  appendText(string) {\n    return this.didAppendNode(this.__appendText(string));\n  }\n  __appendText(text) {\n    let {\n        dom: dom,\n        element: element,\n        nextSibling: nextSibling\n      } = this,\n      node = dom.createTextNode(text);\n    return dom.insertBefore(element, node, nextSibling), node;\n  }\n  __appendNode(node) {\n    return this.dom.insertBefore(this.element, node, this.nextSibling), node;\n  }\n  __appendFragment(fragment) {\n    let first = fragment.firstChild;\n    if (first) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      let ret = new ConcreteBounds(this.element, first, fragment.lastChild);\n      return this.dom.insertBefore(this.element, fragment, this.nextSibling), ret;\n    }\n    {\n      const comment = this.__appendComment(\"\");\n      return new ConcreteBounds(this.element, comment, comment);\n    }\n  }\n  __appendHTML(html) {\n    return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);\n  }\n  appendDynamicHTML(value) {\n    let bounds = this.trustedContent(value);\n    this.didAppendBounds(bounds);\n  }\n  appendDynamicText(value) {\n    let node = this.untrustedContent(value);\n    return this.didAppendNode(node), node;\n  }\n  appendDynamicFragment(value) {\n    let bounds = this.__appendFragment(value);\n    this.didAppendBounds(bounds);\n  }\n  appendDynamicNode(value) {\n    let node = this.__appendNode(value),\n      bounds = new ConcreteBounds(this.element, node, node);\n    this.didAppendBounds(bounds);\n  }\n  trustedContent(value) {\n    return this.__appendHTML(value);\n  }\n  untrustedContent(value) {\n    return this.__appendText(value);\n  }\n  appendComment(string) {\n    return this.didAppendNode(this.__appendComment(string));\n  }\n  __appendComment(string) {\n    let {\n        dom: dom,\n        element: element,\n        nextSibling: nextSibling\n      } = this,\n      node = dom.createComment(string);\n    return dom.insertBefore(element, node, nextSibling), node;\n  }\n  __setAttribute(name, value, namespace) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    this.dom.setAttribute(this.constructing, name, value, namespace);\n  }\n  __setProperty(name, value) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    this.constructing[name] = value;\n  }\n  setStaticAttribute(name, value, namespace) {\n    this.__setAttribute(name, value, namespace);\n  }\n  setDynamicAttribute(name, value, trusting, namespace) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    let attribute = dynamicAttribute(this.constructing, name, namespace, trusting);\n    return attribute.set(this, value, this.env), attribute;\n  }\n}\nclass AppendingBlockImpl {\n  constructor(parent) {\n    this.parent = parent, this.first = null, this.last = null, this.nesting = 0;\n  }\n  parentElement() {\n    return this.parent;\n  }\n  firstNode() {\n    return this.first.firstNode();\n  }\n  lastNode() {\n    return this.last.lastNode();\n  }\n  openElement(element) {\n    this.didAppendNode(element), this.nesting++;\n  }\n  closeElement() {\n    this.nesting--;\n  }\n  didAppendNode(node) {\n    0 === this.nesting && (this.first || (this.first = new First(node)), this.last = new Last(node));\n  }\n  didAppendBounds(bounds) {\n    0 === this.nesting && (this.first || (this.first = bounds), this.last = bounds);\n  }\n  finalize(stack) {\n    null === this.first && stack.appendComment(\"\");\n  }\n}\nclass RemoteBlock extends AppendingBlockImpl {\n  constructor(parent) {\n    super(parent), registerDestructor(this, () => {\n      // In general, you only need to clear the root of a hierarchy, and should never\n      // need to clear any child nodes. This is an important constraint that gives us\n      // a strong guarantee that clearing a subtree is a single DOM operation.\n      // Because remote blocks are not normally physically nested inside of the tree\n      // that they are logically nested inside, we manually clear remote blocks when\n      // a logical parent is cleared.\n      // HOWEVER, it is currently possible for a remote block to be physically nested\n      // inside of the block it is logically contained inside of. This happens when\n      // the remote block is appended to the end of the application's entire element.\n      // The problem with that scenario is that Glimmer believes that it owns more of\n      // the DOM than it actually does. The code is attempting to write past the end\n      // of the Glimmer-managed root, but Glimmer isn't aware of that.\n      // The correct solution to that problem is for Glimmer to be aware of the end\n      // of the bounds that it owns, and once we make that change, this check could\n      // be removed.\n      // For now, a more targeted fix is to check whether the node was already removed\n      // and avoid clearing the node if it was. In most cases this shouldn't happen,\n      // so this might hide bugs where the code clears nested nodes unnecessarily,\n      // so we should eventually try to do the correct fix.\n      this.parentElement() === this.firstNode().parentNode && clear(this);\n    });\n  }\n}\nclass ResettableBlockImpl extends AppendingBlockImpl {\n  constructor(parent) {\n    super(parent);\n  }\n  reset() {\n    destroy(this);\n    let nextSibling = clear(this);\n    return this.first = null, this.last = null, this.nesting = 0, nextSibling;\n  }\n}\n\n// FIXME: All the noops in here indicate a modelling problem\nclass AppendingBlockList {\n  constructor(parent, boundList) {\n    this.parent = parent, this.boundList = boundList, this.parent = parent, this.boundList = boundList;\n  }\n  parentElement() {\n    return this.parent;\n  }\n  firstNode() {\n    return this.boundList[0].firstNode();\n  }\n  lastNode() {\n    let boundList = this.boundList;\n    return boundList[boundList.length - 1].lastNode();\n  }\n  openElement(_element) {}\n  closeElement() {}\n  didAppendNode(_node) {}\n  didAppendBounds(_bounds) {}\n  finalize(_stack) {\n    this.boundList.length;\n  }\n}\nfunction clientBuilder(env, cursor) {\n  return NewTreeBuilder.forInitialRender(env, cursor);\n}\nclass UpdatingVM {\n  constructor(env, {\n    alwaysRevalidate = false\n  }) {\n    this.frameStack = new StackImpl(), this.env = env, this.dom = env.getDOM(), this.alwaysRevalidate = alwaysRevalidate;\n  }\n  execute(opcodes, handler) {\n    if (true) {\n      let hasErrored = true;\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        debug.runInTrackingTransaction(() => this._execute(opcodes, handler), \"- While rendering:\"),\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        hasErrored = !1;\n      } finally {\n        hasErrored &&\n        // eslint-disable-next-line no-console\n        console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n      }\n    } else this._execute(opcodes, handler);\n  }\n  _execute(opcodes, handler) {\n    let {\n      frameStack: frameStack\n    } = this;\n    for (this.try(opcodes, handler); !frameStack.isEmpty();) {\n      let opcode = this.frame.nextStatement();\n      void 0 !== opcode ? opcode.evaluate(this) : frameStack.pop();\n    }\n  }\n  get frame() {\n    return this.frameStack.current;\n  }\n  goto(index) {\n    this.frame.goto(index);\n  }\n  try(ops, handler) {\n    this.frameStack.push(new UpdatingVMFrame(ops, handler));\n  }\n  throw() {\n    this.frame.handleException(), this.frameStack.pop();\n  }\n}\nclass BlockOpcode {\n  constructor(state, context, bounds, children) {\n    this.state = state, this.context = context, this.children = children, this.bounds = bounds;\n  }\n  parentElement() {\n    return this.bounds.parentElement();\n  }\n  firstNode() {\n    return this.bounds.firstNode();\n  }\n  lastNode() {\n    return this.bounds.lastNode();\n  }\n  evaluate(vm) {\n    vm.try(this.children, null);\n  }\n}\nclass TryOpcode extends BlockOpcode {\n  evaluate(vm) {\n    vm.try(this.children, this);\n  }\n  handleException() {\n    let {\n      state: state,\n      bounds: bounds,\n      context: {\n        env: env\n      }\n    } = this;\n    destroyChildren(this);\n    let tree = NewTreeBuilder.resume(env, bounds),\n      vm = state.evaluate(tree),\n      children = this.children = [],\n      result = vm.execute(vm => {\n        vm.updateWith(this), vm.pushUpdating(children);\n      });\n    associateDestroyableChild(this, result.drop);\n  }\n  constructor(...args) {\n    super(...args), this.type = \"try\";\n  }\n}\nclass ListItemOpcode extends TryOpcode {\n  constructor(state, context, bounds, key, memo, value) {\n    super(state, context, bounds, []), this.key = key, this.memo = memo, this.value = value, this.retained = false, this.index = -1;\n  }\n  shouldRemove() {\n    return !this.retained;\n  }\n  reset() {\n    this.retained = false;\n  }\n}\nclass ListBlockOpcode extends BlockOpcode {\n  constructor(state, context, bounds, children, iterableRef) {\n    super(state, context, bounds, children), this.iterableRef = iterableRef, this.type = \"list-block\", this.opcodeMap = new Map(), this.marker = null, this.lastIterator = valueForRef(iterableRef);\n  }\n  initializeChild(opcode) {\n    opcode.index = this.children.length - 1, this.opcodeMap.set(opcode.key, opcode);\n  }\n  evaluate(vm) {\n    let iterator = valueForRef(this.iterableRef);\n    if (this.lastIterator !== iterator) {\n      let {\n          bounds: bounds\n        } = this,\n        {\n          dom: dom\n        } = vm,\n        marker = this.marker = dom.createComment(\"\");\n      dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode()), this.sync(iterator), this.parentElement().removeChild(marker), this.marker = null, this.lastIterator = iterator;\n    }\n    // Run now-updated updating opcodes\n    super.evaluate(vm);\n  }\n  sync(iterator) {\n    let {\n        opcodeMap: itemMap,\n        children: children\n      } = this,\n      currentOpcodeIndex = 0,\n      seenIndex = 0;\n    for (this.children = this.bounds.boundList = [];;) {\n      let item = iterator.next();\n      if (null === item) break;\n      let opcode = children[currentOpcodeIndex],\n        {\n          key: key\n        } = item;\n      // Items that have already been found and moved will already be retained,\n      // we can continue until we find the next unretained item\n      for (; void 0 !== opcode && opcode.retained;) opcode = children[++currentOpcodeIndex];\n      if (void 0 !== opcode && opcode.key === key) this.retainItem(opcode, item), currentOpcodeIndex++;else if (itemMap.has(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n        let itemOpcode = itemMap.get(key);\n        // The item opcode was seen already, so we should move it.\n        if (itemOpcode.index < seenIndex) this.moveItem(itemOpcode, item, opcode);else {\n          // Update the seen index, we are going to be moving this item around\n          // so any other items that come before it will likely need to move as\n          // well.\n          seenIndex = itemOpcode.index;\n          let seenUnretained = false;\n          // iterate through all of the opcodes between the current position and\n          // the position of the item's opcode, and determine if they are all\n          // retained.\n          for (let i = currentOpcodeIndex + 1; i < seenIndex; i++) if (!children[i].retained) {\n            seenUnretained = true;\n            break;\n          }\n          // If we have seen only retained opcodes between this and the matching\n          // opcode, it means that all the opcodes in between have been moved\n          // already, and we can safely retain this item's opcode.\n          seenUnretained ? (this.moveItem(itemOpcode, item, opcode), currentOpcodeIndex++) : (this.retainItem(itemOpcode, item), currentOpcodeIndex = seenIndex + 1);\n        }\n      } else this.insertItem(item, opcode);\n    }\n    for (const opcode of children) opcode.retained ? opcode.reset() : this.deleteItem(opcode);\n  }\n  retainItem(opcode, item) {\n    let {\n      children: children\n    } = this;\n    updateRef(opcode.memo, item.memo), updateRef(opcode.value, item.value), opcode.retained = true, opcode.index = children.length, children.push(opcode);\n  }\n  insertItem(item, before) {\n    let {\n        opcodeMap: opcodeMap,\n        bounds: bounds,\n        state: state,\n        children: children,\n        context: {\n          env: env\n        }\n      } = this,\n      {\n        key: key\n      } = item,\n      nextSibling = void 0 === before ? this.marker : before.firstNode(),\n      elementStack = NewTreeBuilder.forInitialRender(env, {\n        element: bounds.parentElement(),\n        nextSibling: nextSibling\n      });\n    state.evaluate(elementStack).execute(vm => {\n      let opcode = vm.enterItem(item);\n      opcode.index = children.length, children.push(opcode), opcodeMap.set(key, opcode), associateDestroyableChild(this, opcode);\n    });\n  }\n  moveItem(opcode, item, before) {\n    let currentSibling,\n      nextSibling,\n      {\n        children: children\n      } = this;\n    updateRef(opcode.memo, item.memo), updateRef(opcode.value, item.value), opcode.retained = true, void 0 === before ? move(opcode, this.marker) : (currentSibling = opcode.lastNode().nextSibling, nextSibling = before.firstNode(),\n    // Items are moved throughout the algorithm, so there are cases where the\n    // the items already happen to be siblings (e.g. an item in between was\n    // moved before this move happened). Check to see if they are siblings\n    // first before doing the move.\n    currentSibling !== nextSibling && move(opcode, nextSibling)), opcode.index = children.length, children.push(opcode);\n  }\n  deleteItem(opcode) {\n    destroy(opcode), clear(opcode), this.opcodeMap.delete(opcode.key);\n  }\n}\nclass UpdatingVMFrame {\n  constructor(ops, exceptionHandler) {\n    this.ops = ops, this.exceptionHandler = exceptionHandler, this.current = 0;\n  }\n  goto(index) {\n    this.current = index;\n  }\n  nextStatement() {\n    return this.ops[this.current++];\n  }\n  handleException() {\n    this.exceptionHandler && this.exceptionHandler.handleException();\n  }\n}\nclass RenderResultImpl {\n  constructor(env, updating, bounds, drop) {\n    this.env = env, this.updating = updating, this.bounds = bounds, this.drop = drop, associateDestroyableChild(this, drop), registerDestructor(this, () => clear(this.bounds));\n  }\n  rerender({\n    alwaysRevalidate = false\n  } = {\n    alwaysRevalidate: false\n  }) {\n    let {\n      env: env,\n      updating: updating\n    } = this;\n    new UpdatingVM(env, {\n      alwaysRevalidate: alwaysRevalidate\n    }).execute(updating, this);\n  }\n  parentElement() {\n    return this.bounds.parentElement();\n  }\n  firstNode() {\n    return this.bounds.firstNode();\n  }\n  lastNode() {\n    return this.bounds.lastNode();\n  }\n  handleException() {}\n}\nclass EvaluationStackImpl {\n  static restore(snapshot, pc) {\n    const stack = new this(snapshot.slice(), [0, -1, snapshot.length - 1, 0]);\n    return stack.registers[$pc] = pc, stack.registers[$sp] = snapshot.length - 1, stack.registers[$fp] = -1, stack;\n  }\n  // fp -> sp\n  constructor(stack = [], registers) {\n    this.stack = stack, this.registers = registers;\n  }\n  push(value) {\n    this.stack[++this.registers[$sp]] = value;\n  }\n  dup(position = this.registers[$sp]) {\n    this.stack[++this.registers[$sp]] = this.stack[position];\n  }\n  copy(from, to) {\n    this.stack[to] = this.stack[from];\n  }\n  pop(n = 1) {\n    let top = this.stack[this.registers[$sp]];\n    return this.registers[$sp] -= n, top;\n  }\n  peek(offset = 0) {\n    return this.stack[this.registers[$sp] - offset];\n  }\n  get(offset, base = this.registers[$fp]) {\n    return this.stack[base + offset];\n  }\n  set(value, offset, base = this.registers[$fp]) {\n    this.stack[base + offset] = value;\n  }\n  slice(start, end) {\n    return this.stack.slice(start, end);\n  }\n  capture(items) {\n    let end = this.registers[$sp] + 1,\n      start = end - items;\n    return this.stack.slice(start, end);\n  }\n  reset() {\n    this.stack.length = 0;\n  }\n}\nclass Stacks {\n  constructor(scope, dynamicScope) {\n    this.drop = {}, this.scope = new StackImpl(), this.dynamicScope = new StackImpl(), this.updating = new StackImpl(), this.cache = new StackImpl(), this.list = new StackImpl(), this.destroyable = new StackImpl(), this.scope.push(scope), this.dynamicScope.push(dynamicScope), this.destroyable.push(this.drop);\n  }\n}\nclass VM {\n  #stacks;\n  get stack() {\n    return this.lowlevel.stack;\n  }\n  /* Registers */\n  get pc() {\n    return this.lowlevel.fetchRegister($pc);\n  }\n  #registers;\n  /**\n  * Fetch a value from a syscall register onto the stack.\n  *\n  * ## Opcodes\n  *\n  * - Append: `Fetch`\n  *\n  * ## State changes\n  *\n  * [!] push Eval Stack <- $register\n  */\n  fetch(register) {\n    let value = this.fetchValue(register);\n    this.stack.push(value);\n  }\n  /**\n  * Load a value from the stack into a syscall register.\n  *\n  * ## Opcodes\n  *\n  * - Append: `Load`\n  *\n  * ## State changes\n  *\n  * [!] pop Eval Stack -> `value`\n  * [$] $register <- `value`\n  */\n  load(register) {\n    let value = this.stack.pop();\n    this.loadValue(register, value);\n  }\n  /**\n  * Load a value into a syscall register.\n  *\n  * ## State changes\n  *\n  * [$] $register <- `value`\n  *\n  * @utility\n  */\n  loadValue(register, value) {\n    this.#registers[register] = value;\n  }\n  fetchValue(register) {\n    return isLowLevelRegister(register) ? this.lowlevel.fetchRegister(register) : this.#registers[register];\n  }\n  // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n  call(handle) {\n    null !== handle && this.lowlevel.call(handle);\n  }\n  // Return to the `program` address stored in $ra\n  return() {\n    this.lowlevel.return();\n  }\n  #tree;\n  constructor({\n    scope: scope,\n    dynamicScope: dynamicScope,\n    stack: stack,\n    pc: pc\n  }, context, tree) {\n    this.#registers = [null, null, null, null, null, null, null, null, null], true &&\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    assertGlobalContextWasSet();\n    let evalStack = EvaluationStackImpl.restore(stack, pc);\n    this.#tree = tree, this.context = context, this.#stacks = new Stacks(scope, dynamicScope), this.args = new VMArgumentsImpl(), this.lowlevel = new LowLevelVM(evalStack, context, void 0, evalStack.registers), this.pushUpdating();\n  }\n  static initial(context, options) {\n    let scope = ScopeImpl.root(options.owner, options.scope ?? {\n      self: UNDEFINED_REFERENCE,\n      size: 0\n    });\n    const state = function (pc, scope, dynamicScope) {\n      return {\n        pc: pc,\n        scope: scope,\n        dynamicScope: dynamicScope,\n        stack: []\n      };\n    }\n    /**\n    * A closure captures the state of the VM for a particular block of code that is necessary to\n    * re-invoke the block in the future.\n    *\n    * In practice, this allows us to clear the previous render and \"replay\" the block's execution,\n    * rendering content in the same position as the first render.\n    */(context.program.heap.getaddr(options.handle), scope, options.dynamicScope);\n    return new VM(state, context, options.tree);\n  }\n  compile(block) {\n    return unwrapHandle(block.compile(this.context));\n  }\n  get constants() {\n    return this.context.program.constants;\n  }\n  get program() {\n    return this.context.program;\n  }\n  get env() {\n    return this.context.env;\n  }\n  captureClosure(args, pc = this.lowlevel.fetchRegister($pc)) {\n    return {\n      pc: pc,\n      scope: this.scope(),\n      dynamicScope: this.dynamicScope(),\n      stack: this.stack.capture(args)\n    };\n  }\n  capture(args, pc = this.lowlevel.fetchRegister($pc)) {\n    return new Closure(this.captureClosure(args, pc), this.context);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `BeginComponentTransaction`\n  *\n  * ## State Changes\n  *\n  * [ ] create `guard` (`JumpIfNotModifiedOpcode`)\n  * [ ] create `tracker` (`BeginTrackFrameOpcode`)\n  * [!] push Updating Stack <- `guard`\n  * [!] push Updating Stack <- `tracker`\n  * [!] push Cache Stack <- `guard`\n  * [!] push Tracking Stack\n  */\n  beginCacheGroup(name) {\n    let opcodes = this.updating(),\n      guard = new JumpIfNotModifiedOpcode();\n    opcodes.push(guard), opcodes.push(new BeginTrackFrameOpcode(name)), this.#stacks.cache.push(guard), beginTrackFrame(name);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `CommitComponentTransaction`\n  *\n  * ## State Changes\n  *\n  * Create a new `EndTrackFrameOpcode` (`end`)\n  *\n  * [!] pop CacheStack -> `guard`\n  * [!] pop Tracking Stack -> `tag`\n  * [ ] create `end` (`EndTrackFrameOpcode`) with `guard`\n  * [-] consume `tag`\n  */\n  commitCacheGroup() {\n    let opcodes = this.updating(),\n      guard = this.#stacks.cache.pop(),\n      tag = endTrackFrame();\n    opcodes.push(new EndTrackFrameOpcode(guard)), guard.finalize(tag, opcodes.length);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `Enter`\n  *\n  * ## State changes\n  *\n  * [!] push Element Stack as `block`\n  * [ ] create `try` (`TryOpcode`) with `block`, capturing `args` from the Eval Stack\n  *\n  * Did Enter (`try`):\n  * [-] associate destroyable `try`\n  * [!] push Destroyable Stack <- `try`\n  * [!] push Updating List <- `try`\n  * [!] push Updating Stack <- `try.children`\n  */\n  enter(args) {\n    let state = this.capture(args),\n      block = this.tree().pushResettableBlock(),\n      tryOpcode = new TryOpcode(state, this.context, block, []);\n    this.didEnter(tryOpcode);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `Iterate`\n  * - Update: `ListBlock`\n  *\n  * ## State changes\n  *\n  * Create a new ref for the iterator item (`value`).\n  * Create a new ref for the iterator key (`key`).\n  *\n  * [ ] create `valueRef` (`Reference`) from `value`\n  * [ ] create `keyRef` (`Reference`) from `key`\n  * [!] push Eval Stack <- `valueRef`\n  * [!] push Eval Stack <- `keyRef`\n  * [!] push Element Stack <- `UpdatableBlock` as `block`\n  * [ ] capture `closure` with *2* items from the Eval Stack\n  * [ ] create `iteration` (`ListItemOpcode`) with `closure`, `block`, `key`, `keyRef` and `valueRef`\n  *\n  * Did Enter (`iteration`):\n  * [-] associate destroyable `iteration`\n  * [!] push Destroyable Stack <- `iteration`\n  * [!] push Updating List <- `iteration`\n  * [!] push Updating Stack <- `iteration.children`\n  */\n  enterItem({\n    key: key,\n    value: value,\n    memo: memo\n  }) {\n    let {\n        stack: stack\n      } = this,\n      valueRef = createIteratorItemRef(value),\n      memoRef = createIteratorItemRef(memo);\n    stack.push(valueRef), stack.push(memoRef);\n    let state = this.capture(2),\n      block = this.tree().pushResettableBlock(),\n      opcode = new ListItemOpcode(state, this.context, block, key, memoRef, valueRef);\n    return this.didEnter(opcode), opcode;\n  }\n  registerItem(opcode) {\n    this.listBlock().initializeChild(opcode);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `EnterList`\n  *\n  * ## State changes\n  *\n  * [ ] capture `closure` with *0* items from the Eval Stack, and `$pc` from `offset`\n  * [ ] create `updating` (empty `Array`)\n  * [!] push Element Stack <- `list` (`BlockList`) with `updating`\n  * [ ] create `list` (`ListBlockOpcode`) with `closure`, `list`, `updating` and `iterableRef`\n  * [!] push List Stack <- `list`\n  *\n  * Did Enter (`list`):\n  * [-] associate destroyable `list`\n  * [!] push Destroyable Stack <- `list`\n  * [!] push Updating List <- `list`\n  * [!] push Updating Stack <- `list.children`\n  */\n  enterList(iterableRef, offset) {\n    let updating = [],\n      addr = this.lowlevel.target(offset),\n      state = this.capture(0, addr),\n      list = this.tree().pushBlockList(updating),\n      opcode = new ListBlockOpcode(state, this.context, list, updating, iterableRef);\n    this.#stacks.list.push(opcode), this.didEnter(opcode);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `Enter`\n  * - Append: `Iterate`\n  * - Append: `EnterList`\n  * - Update: `ListBlock`\n  *\n  * ## State changes\n  *\n  * [-] associate destroyable `opcode`\n  * [!] push Destroyable Stack <- `opcode`\n  * [!] push Updating List <- `opcode`\n  * [!] push Updating Stack <- `opcode.children`\n  *\n  */\n  didEnter(opcode) {\n    this.associateDestroyable(opcode), this.#stacks.destroyable.push(opcode), this.updateWith(opcode), this.pushUpdating(opcode.children);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `Exit`\n  * - Append: `ExitList`\n  *\n  * ## State changes\n  *\n  * [!] pop Destroyable Stack\n  * [!] pop Element Stack\n  * [!] pop Updating Stack\n  */\n  exit() {\n    this.#stacks.destroyable.pop(), this.#tree.popBlock(), this.popUpdating();\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `ExitList`\n  *\n  * ## State changes\n  *\n  * Pop List:\n  * [!] pop Destroyable Stack\n  * [!] pop Element Stack\n  * [!] pop Updating Stack\n  *\n  * [!] pop List Stack\n  */\n  exitList() {\n    this.exit(), this.#stacks.list.pop();\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `RootScope`\n  * - Append: `VirtualRootScope`\n  *\n  * ## State changes\n  *\n  * [!] push Scope Stack\n  */\n  pushRootScope(size, owner) {\n    let scope = ScopeImpl.sized(owner, size);\n    return this.#stacks.scope.push(scope), scope;\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `ChildScope`\n  *\n  * ## State changes\n  *\n  * [!] push Scope Stack <- `child` of current Scope\n  */\n  pushChildScope() {\n    this.#stacks.scope.push(this.scope().child());\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `Yield`\n  *\n  * ## State changes\n  *\n  * [!] push Scope Stack <- `scope`\n  */\n  pushScope(scope) {\n    this.#stacks.scope.push(scope);\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `PopScope`\n  *\n  * ## State changes\n  *\n  * [!] pop Scope Stack\n  */\n  popScope() {\n    this.#stacks.scope.pop();\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `PushDynamicScope`\n  *\n  * ## State changes:\n  *\n  * [!] push Dynamic Scope Stack <- child of current Dynamic Scope\n  */\n  pushDynamicScope() {\n    let child = this.dynamicScope().child();\n    return this.#stacks.dynamicScope.push(child), child;\n  }\n  /**\n  * ## Opcodes\n  *\n  * - Append: `BindDynamicScope`\n  *\n  * ## State changes:\n  *\n  * [!] pop Dynamic Scope Stack `names.length` times\n  */\n  bindDynamicScope(names) {\n    let scope = this.dynamicScope();\n    for (const name of reverse(names)) scope.set(name, this.stack.pop());\n  }\n  /**\n  * ## State changes\n  *\n  * - [!] push Updating Stack\n  *\n  * @utility\n  */\n  pushUpdating(list = []) {\n    this.#stacks.updating.push(list);\n  }\n  /**\n  * ## State changes\n  *\n  * [!] pop Updating Stack\n  *\n  * @utility\n  */\n  popUpdating() {\n    return this.#stacks.updating.pop();\n  }\n  /**\n  * ## State changes\n  *\n  * [!] push Updating List\n  *\n  * @utility\n  */\n  updateWith(opcode) {\n    this.updating().push(opcode);\n  }\n  listBlock() {\n    return this.#stacks.list.current;\n  }\n  /**\n  * ## State changes\n  *\n  * [-] associate destroyable `child`\n  *\n  * @utility\n  */\n  associateDestroyable(child) {\n    let parent = this.#stacks.destroyable.current;\n    associateDestroyableChild(parent, child);\n  }\n  updating() {\n    return this.#stacks.updating.current;\n  }\n  /**\n  * Get Tree Builder\n  */\n  tree() {\n    return this.#tree;\n  }\n  /**\n  * Get current Scope\n  */\n  scope() {\n    return this.#stacks.scope.current;\n  }\n  /**\n  * Get current Dynamic Scope\n  */\n  dynamicScope() {\n    return this.#stacks.dynamicScope.current;\n  }\n  popDynamicScope() {\n    this.#stacks.dynamicScope.pop();\n  }\n  /// SCOPE HELPERS\n  getOwner() {\n    return this.scope().owner;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getSelf() {\n    return this.scope().getSelf();\n  }\n  referenceForSymbol(symbol) {\n    return this.scope().getSymbol(symbol);\n  }\n  /// EXECUTION\n  execute(initialize) {\n    if (!true) return this._execute(initialize);\n    {\n      let hasErrored = true;\n      try {\n        let value = this._execute(initialize);\n        // using a boolean here to avoid breaking ergonomics of \"pause on uncaught exceptions\"\n        // which would happen with a `catch` + `throw`\n        return hasErrored = !1, value;\n      } finally {\n        if (hasErrored) {\n          // If any existing blocks are open, due to an error or something like\n          // that, we need to close them all and clean things up properly.\n          let elements = this.tree();\n          for (; elements.hasBlocks;) elements.popBlock();\n          // eslint-disable-next-line no-console\n          console.error(`\\n\\nError occurred:\\n\\n${resetTracking()}\\n\\n`);\n        }\n      }\n    }\n  }\n  _execute(initialize) {\n    let result;\n    initialize && initialize(this);\n    do {\n      result = this.next();\n    } while (!result.done);\n    return result.value;\n  }\n  next() {\n    let result,\n      {\n        env: env\n      } = this,\n      opcode = this.lowlevel.nextStatement();\n    return null !== opcode ? (this.lowlevel.evaluateOuter(opcode, this), result = {\n      done: false,\n      value: null\n    }) : (\n    // Unload the stack\n    this.stack.reset(), result = {\n      done: true,\n      value: new RenderResultImpl(env, this.popUpdating(), this.#tree.popBlock(), this.#stacks.drop)\n    }), result;\n  }\n}\nclass Closure {\n  constructor(state, context) {\n    this.state = state, this.context = context;\n  }\n  evaluate(tree) {\n    return new VM(this.state, this.context, tree);\n  }\n}\nclass TemplateIteratorImpl {\n  constructor(vm) {\n    this.vm = vm;\n  }\n  next() {\n    return this.vm.next();\n  }\n  sync() {\n    return true ? debug.runInTrackingTransaction(() => this.vm.execute(), \"- While rendering:\") : this.vm.execute();\n  }\n}\nfunction renderSync(env, iterator) {\n  let result;\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n  return inTransaction(env, () => result = iterator.sync()), result;\n}\nfunction renderMain(context, owner, self, tree, layout, dynamicScope = new DynamicScopeImpl()) {\n  let handle = unwrapHandle(layout.compile(context)),\n    numSymbols = layout.symbolTable.symbols.length,\n    vm = VM.initial(context, {\n      scope: {\n        self: self,\n        size: numSymbols\n      },\n      dynamicScope: dynamicScope,\n      tree: tree,\n      handle: handle,\n      owner: owner\n    });\n  return new TemplateIteratorImpl(vm);\n}\nfunction renderComponent(context, tree, owner, definition, args = {}, dynamicScope = new DynamicScopeImpl()) {\n  return function (vm, context, owner, definition, args) {\n    // Get a list of tuples of argument names and references, like\n    // [['title', reference], ['name', reference]]\n    const argList = Object.keys(args).map(key => [key, args[key]]),\n      blockNames = [\"main\", \"else\", \"attrs\"],\n      argNames = argList.map(([name]) => `@${name}`);\n    let reified = vm.constants.component(definition, owner, void 0, \"{ROOT}\");\n    vm.lowlevel.pushFrame();\n    // Push blocks on to the stack, three stack values per block\n    for (let i = 0; i < 3 * blockNames.length; i++) vm.stack.push(null);\n    vm.stack.push(null),\n    // For each argument, push its backing reference on to the stack\n    argList.forEach(([, reference]) => {\n      vm.stack.push(reference);\n    }),\n    // Configure VM based on blocks and args just pushed on to the stack.\n    vm.args.setup(vm.stack, argNames, blockNames, 0, true);\n    const compilable = reified.compilable,\n      invocation = {\n        handle: unwrapHandle(compilable.compile(context)),\n        symbolTable: compilable.symbolTable\n      };\n    // Needed for the Op.Main opcode: arguments, component invocation object, and\n    // component definition.\n    return vm.stack.push(vm.args), vm.stack.push(invocation), vm.stack.push(reified), new TemplateIteratorImpl(vm);\n  }(VM.initial(context, {\n    tree: tree,\n    handle: context.stdlib.main,\n    dynamicScope: dynamicScope,\n    owner: owner\n  }), context, owner, definition, function (record) {\n    const root = createConstRef(record, \"args\");\n    return Object.keys(record).reduce((acc, key) => (acc[key] = childRefFor(root, key), acc), {});\n  }(args));\n}\nconst SERIALIZATION_FIRST_NODE_STRING = \"%+b:0%\";\nfunction isSerializationFirstNode(node) {\n  return \"%+b:0%\" === node.nodeValue;\n}\nclass RehydratingCursor extends CursorImpl {\n  constructor(element, nextSibling, startingBlockDepth) {\n    super(element, nextSibling), this.startingBlockDepth = startingBlockDepth, this.candidate = null, this.injectedOmittedNode = false, this.openBlockDepth = startingBlockDepth - 1;\n  }\n}\nclass RehydrateTree extends NewTreeBuilder {\n  constructor(env, parentNode, nextSibling) {\n    if (super(env, parentNode, nextSibling), this.unmatchedAttributes = null, this.blockDepth = 0, nextSibling) throw new Error(\"Rehydration with nextSibling not supported\");\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    let node = this.currentCursor.element.firstChild;\n    for (; null !== node && !isOpenBlock(node);) node = node.nextSibling;\n    this.candidate = node;\n    const startingBlockOffset = getBlockDepth(node);\n    if (0 !== startingBlockOffset) {\n      // We are rehydrating from a partial tree and not the root component\n      // We need to add an extra block before the first block to rehydrate correctly\n      // The extra block is needed since the renderComponent API creates a synthetic component invocation which generates the extra block\n      const newBlockDepth = startingBlockOffset - 1,\n        newCandidate = this.dom.createComment(`%+b:${newBlockDepth}%`);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      node.parentNode.insertBefore(newCandidate, this.candidate);\n      let closingNode = node.nextSibling;\n      for (; null !== closingNode && (!isCloseBlock(closingNode) || getBlockDepth(closingNode) !== startingBlockOffset);) closingNode = closingNode.nextSibling;\n      const newClosingBlock = this.dom.createComment(`%-b:${newBlockDepth}%`);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      node.parentNode.insertBefore(newClosingBlock, closingNode.nextSibling), this.candidate = newCandidate, this.startingBlockOffset = newBlockDepth;\n    } else this.startingBlockOffset = 0;\n  }\n  get currentCursor() {\n    return this.cursors.current;\n  }\n  get candidate() {\n    return this.currentCursor ? this.currentCursor.candidate : null;\n  }\n  set candidate(node) {\n    this.currentCursor.candidate = node;\n  }\n  disableRehydration(nextSibling) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    const currentCursor = this.currentCursor;\n    // rehydration will be disabled until we either:\n    // * hit popElement (and return to using the parent elements cursor)\n    // * hit closeBlock and the next sibling is a close block comment\n    //   matching the expected openBlockDepth\n    currentCursor.candidate = null, currentCursor.nextSibling = nextSibling;\n  }\n  enableRehydration(candidate) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n    const currentCursor = this.currentCursor;\n    currentCursor.candidate = candidate, currentCursor.nextSibling = null;\n  }\n  pushElement(element, nextSibling = null) {\n    const cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);\n    /**\n    * <div>   <---------------  currentCursor.element\n    *   <!--%+b:1%--> <-------  would have been removed during openBlock\n    *   <div> <---------------  currentCursor.candidate -> cursor.element\n    *     <!--%+b:2%--> <-----  currentCursor.candidate.firstChild -> cursor.candidate\n    *     Foo\n    *     <!--%-b:2%-->\n    *   </div>\n    *   <!--%-b:1%-->  <------  becomes currentCursor.candidate\n    */\n    null !== this.candidate && (cursor.candidate = element.firstChild, this.candidate = element.nextSibling), this.cursors.push(cursor);\n  }\n  // clears until the end of the current container\n  // either the current open block or higher\n  clearMismatch(candidate) {\n    let current = candidate;\n    const currentCursor = this.currentCursor;\n    if (null !== currentCursor) {\n      const openBlockDepth = currentCursor.openBlockDepth;\n      if (openBlockDepth >= currentCursor.startingBlockDepth) for (; current && !(isCloseBlock(current) && openBlockDepth >= getBlockDepthWithOffset(current, this.startingBlockOffset));) current = this.remove(current);else for (; null !== current;) current = this.remove(current);\n      // current cursor parentNode should be openCandidate if element\n      // or openCandidate.parentNode if comment\n      this.disableRehydration(current);\n    }\n  }\n  __openBlock() {\n    const {\n      currentCursor: currentCursor\n    } = this;\n    if (null === currentCursor) return;\n    const blockDepth = this.blockDepth;\n    this.blockDepth++;\n    const {\n      candidate: candidate\n    } = currentCursor;\n    if (null === candidate) return;\n    const {\n      tagName: tagName\n    } = currentCursor.element;\n    isOpenBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth ? (this.candidate = this.remove(candidate), currentCursor.openBlockDepth = blockDepth) : \"TITLE\" !== tagName && \"SCRIPT\" !== tagName && \"STYLE\" !== tagName && this.clearMismatch(candidate);\n  }\n  __closeBlock() {\n    const {\n      currentCursor: currentCursor\n    } = this;\n    if (null === currentCursor) return;\n    // openBlock is the last rehydrated open block\n    const openBlockDepth = currentCursor.openBlockDepth;\n    // this currently is the expected next open block depth\n    this.blockDepth--;\n    const {\n      candidate: candidate\n    } = currentCursor;\n    let isRehydrating = false;\n    if (null !== candidate)\n      //assert(\n      //  openBlockDepth === this.blockDepth,\n      //  'when rehydrating, openBlockDepth should match this.blockDepth here'\n      //);\n      if (isRehydrating = true, isCloseBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth) {\n        const nextSibling = this.remove(candidate);\n        this.candidate = nextSibling, currentCursor.openBlockDepth--;\n      } else\n        // close the block and clear mismatch in parent container\n        // we will be either at the end of the element\n        // or at the end of our containing block\n        this.clearMismatch(candidate), isRehydrating = false;\n    if (!isRehydrating) {\n      // check if nextSibling matches our expected close block\n      // if so, we remove the close block comment and\n      // restore rehydration after clearMismatch disabled\n      const nextSibling = currentCursor.nextSibling;\n      if (null !== nextSibling && isCloseBlock(nextSibling) && getBlockDepthWithOffset(nextSibling, this.startingBlockOffset) === this.blockDepth) {\n        // restore rehydration state\n        const candidate = this.remove(nextSibling);\n        this.enableRehydration(candidate), currentCursor.openBlockDepth--;\n      }\n    }\n  }\n  __appendNode(node) {\n    const {\n      candidate: candidate\n    } = this;\n    // This code path is only used when inserting precisely one node. It needs more\n    // comparison logic, but we can probably lean on the cases where this code path\n    // is actually used.\n    return candidate || super.__appendNode(node);\n  }\n  __appendHTML(html) {\n    const candidateBounds = this.markerBounds();\n    if (candidateBounds) {\n      const first = candidateBounds.firstNode(),\n        last = candidateBounds.lastNode(),\n        newBounds = new ConcreteBounds(this.element, first.nextSibling, last.previousSibling),\n        possibleEmptyMarker = this.remove(first);\n      return this.remove(last), null !== possibleEmptyMarker && isEmpty(possibleEmptyMarker) && (this.candidate = this.remove(possibleEmptyMarker), null !== this.candidate && this.clearMismatch(this.candidate)), newBounds;\n    }\n    return super.__appendHTML(html);\n  }\n  remove(node) {\n    const element = node.parentNode,\n      next = node.nextSibling;\n    return element.removeChild(node), next;\n  }\n  markerBounds() {\n    const _candidate = this.candidate;\n    if (_candidate && isMarker(_candidate)) {\n      const first = _candidate;\n      let last = first.nextSibling;\n      for (; !isMarker(last);) last = last.nextSibling;\n      return new ConcreteBounds(this.element, first, last);\n    }\n    return null;\n  }\n  __appendText(string) {\n    const {\n      candidate: candidate\n    } = this;\n    return candidate ? 3 === candidate.nodeType ? (candidate.nodeValue !== string && (candidate.nodeValue = string), this.candidate = candidate.nextSibling, candidate) : 8 === (node = candidate).nodeType && \"%|%\" === node.nodeValue || isEmpty(candidate) && \"\" === string ? (this.candidate = this.remove(candidate), this.__appendText(string)) : (this.clearMismatch(candidate), super.__appendText(string)) : super.__appendText(string);\n    var node;\n  }\n  __appendComment(string) {\n    const _candidate = this.candidate;\n    return _candidate && 8 === _candidate.nodeType ? (_candidate.nodeValue !== string && (_candidate.nodeValue = string), this.candidate = _candidate.nextSibling, _candidate) : (_candidate && this.clearMismatch(_candidate), super.__appendComment(string));\n  }\n  __openElement(tag) {\n    const _candidate = this.candidate;\n    if (_candidate && isElement(_candidate) && function (candidate, tag) {\n      return candidate.namespaceURI === NS_SVG ? candidate.tagName === tag : candidate.tagName === tag.toUpperCase();\n    }(_candidate, tag)) return this.unmatchedAttributes = [].slice.call(_candidate.attributes), _candidate;\n    if (_candidate) {\n      if (isElement(_candidate) && \"TBODY\" === _candidate.tagName) return this.pushElement(_candidate, null),\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      this.currentCursor.injectedOmittedNode = true, this.__openElement(tag);\n      this.clearMismatch(_candidate);\n    }\n    return super.__openElement(tag);\n  }\n  __setAttribute(name, value, namespace) {\n    const unmatched = this.unmatchedAttributes;\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) return attr.value !== value && (attr.value = value), void unmatched.splice(unmatched.indexOf(attr), 1);\n    }\n    return super.__setAttribute(name, value, namespace);\n  }\n  __setProperty(name, value) {\n    const unmatched = this.unmatchedAttributes;\n    if (unmatched) {\n      const attr = findByName(unmatched, name);\n      if (attr) return attr.value !== value && (attr.value = value), void unmatched.splice(unmatched.indexOf(attr), 1);\n    }\n    return super.__setProperty(name, value);\n  }\n  __flushElement(parent, constructing) {\n    const {\n      unmatchedAttributes: unmatched\n    } = this;\n    if (unmatched) {\n      for (const attr of unmatched)\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme\n      this.constructing.removeAttribute(attr.name);\n      this.unmatchedAttributes = null;\n    } else super.__flushElement(parent, constructing);\n  }\n  willCloseElement() {\n    const {\n      candidate: candidate,\n      currentCursor: currentCursor\n    } = this;\n    null !== candidate && this.clearMismatch(candidate), currentCursor && currentCursor.injectedOmittedNode && this.popElement(), super.willCloseElement();\n  }\n  getMarker(element, guid) {\n    const marker = element.querySelector(`script[glmr=\"${guid}\"]`);\n    return marker ? castToSimple(marker) : null;\n  }\n  __pushRemoteElement(element, cursorId, insertBefore) {\n    const marker = this.getMarker(element, cursorId);\n    // when insertBefore is not present, we clear the element\n    if (!marker || marker.parentNode, void 0 === insertBefore) {\n      for (; null !== element.firstChild && element.firstChild !== marker;) this.remove(element.firstChild);\n      insertBefore = null;\n    }\n    const cursor = new RehydratingCursor(element, null, this.blockDepth);\n    this.cursors.push(cursor), null === marker ? this.disableRehydration(insertBefore) : this.candidate = this.remove(marker);\n    const block = new RemoteBlock(element);\n    return this.pushBlock(block, true);\n  }\n  didAppendBounds(bounds) {\n    if (super.didAppendBounds(bounds), this.candidate) {\n      const last = bounds.lastNode();\n      this.candidate = last.nextSibling;\n    }\n    return bounds;\n  }\n}\nfunction isOpenBlock(node) {\n  return 8 === node.nodeType && 0 === node.nodeValue.lastIndexOf(\"%+b:\", 0);\n}\nfunction isCloseBlock(node) {\n  return 8 === node.nodeType && 0 === node.nodeValue.lastIndexOf(\"%-b:\", 0);\n}\nfunction getBlockDepth(node) {\n  return parseInt(node.nodeValue.slice(4), 10);\n}\nfunction getBlockDepthWithOffset(node, offset) {\n  return getBlockDepth(node) - offset;\n}\nfunction isElement(node) {\n  return 1 === node.nodeType;\n}\nfunction isMarker(node) {\n  return 8 === node.nodeType && \"%glmr%\" === node.nodeValue;\n}\nfunction isEmpty(node) {\n  return 8 === node.nodeType && \"% %\" === node.nodeValue;\n}\nfunction findByName(array, name) {\n  for (const attr of array) if (attr.name === name) return attr;\n}\nfunction rehydrationBuilder(env, cursor) {\n  return RehydrateTree.forInitialRender(env, cursor);\n}\nexport { ConcreteBounds, CurriedValue, CursorImpl, DOMChanges, DOMTreeConstruction, DynamicAttribute, DynamicScopeImpl, EMPTY_ARGS, EMPTY_NAMED, EMPTY_POSITIONAL, EnvironmentImpl, DOMChangesImpl as IDOMChanges, LowLevelVM, NewTreeBuilder, RehydrateTree, RemoteBlock, ResettableBlockImpl, SERIALIZATION_FIRST_NODE_STRING, ScopeImpl, SimpleDynamicAttribute, TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition as TemplateOnlyComponent, TemplateOnlyComponentManager, UpdatingVM, array, clear, clientBuilder, concat, createCapturedArgs, curry, destroy, dynamicAttribute, fn, get, hash, inTransaction, invokeHelper, isDestroyed, isDestroying, isSerializationFirstNode, isWhitespace, normalizeProperty, on, registerDestructor, rehydrationBuilder, reifyArgs, reifyNamed, reifyPositional, renderComponent, renderMain, renderSync, resetDebuggerCallback, runtimeOptions, setDebuggerCallback, templateOnlyComponent };"],
  "mappings": "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",
  "names": ["helper", "templateFactory", "fn", "node", "unwrapTemplate", "context", "num", "isIndexable", "constants", "owner", "definition", "manager", "classes", "instance", "length", "helper", "type", "owner", "resolver", "isStrict", "value", "isIndexable", "context", "get", "iterator", "document", "context", "svgNamespace", "parent", "div", "html", "source", "nextSibling", "artifacts", "helper", "value", "fn", "callbackRef", "element", "callback", "eventName", "options", "context", "array", "url", "protocol", "tagName", "attribute", "opcodes", "vm", "scope", "context", "owner", "definition", "args", "candidate", "tag", "array"]
}
