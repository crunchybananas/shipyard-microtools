// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/global-context/index.js
var scheduleDestroy;
var scheduleDestroyed;
var toIterator;
var toBool;
var getProp;
var setProp;
var getPath;
var setPath;
var warnIfStyleNotTrusted;
var assert;
var deprecate;
var scheduleRevalidate = () => {
};
function debugAssert(test, msg, options) {
  assert && assert(test, "string" == typeof msg ? msg : msg(), options);
}
var assertGlobalContextWasSet;
var testOverrideGlobalContext;
var globalContextWasSet = false;
function setGlobalContext(context) {
  if (true) {
    if (globalContextWasSet) throw new Error("Attempted to set the global context twice. This should only be set once.");
    globalContextWasSet = true;
  }
  scheduleRevalidate = context.scheduleRevalidate, scheduleDestroy = context.scheduleDestroy, scheduleDestroyed = context.scheduleDestroyed, toIterator = context.toIterator, toBool = context.toBool, getProp = context.getProp, setProp = context.setProp, getPath = context.getPath, setPath = context.setPath, warnIfStyleNotTrusted = context.warnIfStyleNotTrusted, assert = context.assert, deprecate = context.deprecate;
}
assertGlobalContextWasSet = () => {
  if (!globalContextWasSet) throw new Error("The global context for Glimmer VM was not set. You must set these global context functions to let Glimmer VM know how to accomplish certain operations. You can do this by importing `setGlobalContext` from `@glimmer/global-context`");
}, testOverrideGlobalContext = (context) => {
  let originalGlobalContext = globalContextWasSet ? {
    scheduleRevalidate,
    scheduleDestroy,
    scheduleDestroyed,
    toIterator,
    toBool,
    getProp,
    setProp,
    getPath,
    setPath,
    warnIfStyleNotTrusted,
    assert,
    deprecate
  } : null;
  return globalContextWasSet = null !== context, // We use `undefined as any` here to unset the values when resetting the
  // context at the end of a test.
  scheduleRevalidate = context?.scheduleRevalidate || void 0, scheduleDestroy = context?.scheduleDestroy || void 0, scheduleDestroyed = context?.scheduleDestroyed || void 0, toIterator = context?.toIterator || void 0, toBool = context?.toBool || void 0, getProp = context?.getProp || void 0, setProp = context?.setProp || void 0, getPath = context?.getPath || void 0, setPath = context?.setPath || void 0, warnIfStyleNotTrusted = context?.warnIfStyleNotTrusted || void 0, assert = context?.assert || void 0, deprecate = context?.deprecate || void 0, originalGlobalContext;
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/destroyable/index.js
var debugToString;
if (true) {
  let getFunctionName = (fn) => {
    let functionName = fn.name;
    if ("" === functionName) {
      let match = /function (\w+)\s*\(/u.exec(String(fn));
      functionName = match && match[1] || "";
    }
    return functionName.replace(/^bound /u, "");
  }, getObjectName = (obj) => {
    let name, className;
    return "function" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), "toString" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && // eslint-disable-next-line @typescript-eslint/no-base-to-string
    (name = obj.toString()), name && /<.*:ember\d+>/u.test(name) && className && "_" !== className[0] && className.length > 2 && "Class" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;
  }, getPrimitiveName = (value) => String(value);
  debugToString = (value) => "function" == typeof value ? getFunctionName(value) || "(unknown function)" : "object" == typeof value && null !== value ? getObjectName(value) || "(unknown object)" : getPrimitiveName(value);
}
var debugToString$1 = debugToString;
var enableDestroyableTracking;
var assertDestroyablesDestroyed;
var DESTROYABLE_META = /* @__PURE__ */ new WeakMap();
function push(collection, newItem) {
  return null === collection ? newItem : Array.isArray(collection) ? (collection.push(newItem), collection) : [collection, newItem];
}
function iterate(collection, fn) {
  Array.isArray(collection) ? collection.forEach(fn) : null !== collection && fn(collection);
}
function remove(collection, item, message) {
  if (true) {
    let collectionIsItem = collection === item, collectionContainsItem = Array.isArray(collection) && -1 !== collection.indexOf(item);
    if (!collectionIsItem && !collectionContainsItem) throw new Error(String(message));
  }
  if (Array.isArray(collection) && collection.length > 1) {
    let index = collection.indexOf(item);
    return collection.splice(index, 1), collection;
  }
  return null;
}
function getDestroyableMeta(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return void 0 === meta && (meta = {
    parents: null,
    children: null,
    eagerDestructors: null,
    destructors: null,
    state: 0
  }, meta.source = destroyable, DESTROYABLE_META.set(destroyable, meta)), meta;
}
function associateDestroyableChild(parent, child) {
  if (isDestroying(parent)) throw new Error("Attempted to associate a destroyable child with an object that is already destroying or destroyed");
  let parentMeta = getDestroyableMeta(parent), childMeta = getDestroyableMeta(child);
  return parentMeta.children = push(parentMeta.children, child), childMeta.parents = push(childMeta.parents, parent), child;
}
function registerDestructor(destroyable, destructor, eager = false) {
  if (isDestroying(destroyable)) throw new Error("Attempted to register a destructor with an object that is already destroying or destroyed");
  let meta = getDestroyableMeta(destroyable), destructorsKey = eager ? "eagerDestructors" : "destructors";
  return meta[destructorsKey] = push(meta[destructorsKey], destructor), destructor;
}
function destroy(destroyable) {
  let meta = getDestroyableMeta(destroyable);
  if (meta.state >= 1) return;
  let {
    parents,
    children,
    eagerDestructors,
    destructors
  } = meta;
  meta.state = 1, iterate(children, destroy), iterate(eagerDestructors, (destructor) => {
    destructor(destroyable);
  }), iterate(destructors, (destructor) => {
    scheduleDestroy(destroyable, destructor);
  }), scheduleDestroyed(() => {
    iterate(parents, (parent) => {
      !(function(child, parent2) {
        let parentMeta = getDestroyableMeta(parent2);
        0 === parentMeta.state && (parentMeta.children = remove(parentMeta.children, child, "attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors."));
      })(destroyable, parent);
    }), meta.state = 2;
  });
}
function destroyChildren(destroyable) {
  let {
    children
  } = getDestroyableMeta(destroyable);
  iterate(children, destroy);
}
function _hasDestroyableChildren(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return void 0 !== meta && null !== meta.children;
}
function isDestroying(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return void 0 !== meta && meta.state >= 1;
}
function isDestroyed(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return void 0 !== meta && meta.state >= 2;
}
if (true) {
  let isTesting = false;
  enableDestroyableTracking = () => {
    if (isTesting)
      throw DESTROYABLE_META = /* @__PURE__ */ new WeakMap(), new Error("Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`");
    isTesting = true, DESTROYABLE_META = /* @__PURE__ */ new Map();
  }, assertDestroyablesDestroyed = () => {
    if (!isTesting) throw new Error("Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`");
    isTesting = false;
    let map = DESTROYABLE_META;
    DESTROYABLE_META = /* @__PURE__ */ new WeakMap();
    let undestroyed = [];
    if (map.forEach((meta) => {
      2 !== meta.state && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
      undestroyed.push(meta.source);
    }), undestroyed.length > 0) {
      let objectsToString = undestroyed.map(debugToString$1).join("\n    "), error = new Error(`Some destroyables were not destroyed during this test:
    ${objectsToString}`);
      throw error.destroyables = undestroyed, error;
    }
  };
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/validator/index.js
var debug = {};
if (true) {
  let CONSUMED_TAGS = null;
  const TRANSACTION_STACK = [], TRANSACTION_ENV = {
    debugMessage(obj, keyName) {
      let objName;
      return objName = "function" == typeof obj ? obj.name : "object" == typeof obj && null !== obj ? `(an instance of ${obj.constructor.name || "(unknown class)"})` : void 0 === obj ? "(an unknown tag)" : String(obj), `You attempted to update ${keyName ? `\`${keyName}\` on \`${objName}\`` : `\`${objName}\``}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;
    }
  };
  debug.setTrackingTransactionEnv = (env) => Object.assign(TRANSACTION_ENV, env), debug.beginTrackingTransaction = (_debugLabel) => {
    CONSUMED_TAGS = CONSUMED_TAGS || /* @__PURE__ */ new WeakMap();
    let debugLabel = _debugLabel || void 0, parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] ?? null;
    TRANSACTION_STACK.push({
      parent,
      debugLabel
    });
  }, debug.endTrackingTransaction = () => {
    if (0 === TRANSACTION_STACK.length) throw new Error("attempted to close a tracking transaction, but one was not open");
    TRANSACTION_STACK.pop(), 0 === TRANSACTION_STACK.length && (CONSUMED_TAGS = null);
  }, debug.resetTrackingTransaction = () => {
    let stack = "";
    return TRANSACTION_STACK.length > 0 && (stack = debug.logTrackingStack(TRANSACTION_STACK[TRANSACTION_STACK.length - 1])), TRANSACTION_STACK.splice(0, TRANSACTION_STACK.length), CONSUMED_TAGS = null, stack;
  }, /**
  * Creates a global autotracking transaction. This will prevent any backflow
  * in any `track` calls within the transaction, even if they are not
  * externally consumed.
  *
  * `runInAutotrackingTransaction` can be called within itself, and it will add
  * onto the existing transaction if one exists.
  *
  * TODO: Only throw an error if the `track` is consumed.
  */
  debug.runInTrackingTransaction = (fn, debugLabel) => {
    debug.beginTrackingTransaction(debugLabel);
    let didError = true;
    try {
      let value = fn();
      return didError = false, value;
    } finally {
      didError || debug.endTrackingTransaction();
    }
  };
  let nthIndex = (str, pattern, n, startingPos = -1) => {
    let i = startingPos;
    for (; n-- > 0 && i++ < str.length && (i = str.indexOf(pattern, i), !(i < 0)); ) ;
    return i;
  }, makeTrackingErrorMessage = (transaction, obj, keyName) => {
    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];
    return message.push(`\`${String(keyName)}\` was first used:`), message.push(debug.logTrackingStack(transaction)), message.push("Stack trace for the update:"), message.join("\n\n");
  };
  debug.logTrackingStack = (transaction) => {
    let trackingStack = [], current = transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];
    if (void 0 === current) return "";
    for (; current; ) current.debugLabel && trackingStack.unshift(current.debugLabel), current = current.parent;
    return trackingStack.map((label, index) => " ".repeat(2 * index) + label).join("\n");
  }, debug.markTagAsConsumed = (_tag) => {
    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;
    var list;
    CONSUMED_TAGS.set(_tag, 0 === (list = TRANSACTION_STACK).length ? void 0 : list[list.length - 1]);
    let subtag = _tag.subtag;
    subtag && debug.markTagAsConsumed && (Array.isArray(subtag) ? subtag.forEach(debug.markTagAsConsumed) : debug.markTagAsConsumed(subtag));
  }, debug.assertTagNotConsumed = (tag, obj, keyName) => {
    if (null === CONSUMED_TAGS) return;
    let transaction = CONSUMED_TAGS.get(tag);
    var error;
    if (transaction)
      try {
        assert(false, makeTrackingErrorMessage(transaction, obj, keyName));
      } catch (e) {
        if ("object" == typeof (error = e) && null !== error && "stack" in error && "string" == typeof error.stack) {
          let updateStackBegin = e.stack.indexOf("Stack trace for the update:");
          if (-1 !== updateStackBegin) {
            let start = nthIndex(e.stack, "\n", 1, updateStackBegin), end = nthIndex(e.stack, "\n", 4, updateStackBegin);
            e.stack = e.stack.substr(0, start) + e.stack.substr(end);
          }
        }
        throw e;
      }
  };
}
function unwrap(val) {
  if (null == val) throw new Error("Expected value to be present");
  return val;
}
var INITIAL = 1;
var $REVISION = 1;
var COMPUTE = Symbol("TAG_COMPUTE");
function valueForTag(tag) {
  return tag[COMPUTE]();
}
function validateTag(tag, snapshot) {
  return snapshot >= tag[COMPUTE]();
}
Reflect.set(globalThis, "COMPUTE_SYMBOL", COMPUTE);
var TYPE = Symbol("TAG_TYPE");
var ALLOW_CYCLES;
ALLOW_CYCLES = /* @__PURE__ */ new WeakMap();
var MonomorphicTagImpl = class _MonomorphicTagImpl {
  static combine(tags) {
    switch (tags.length) {
      case 0:
        return CONSTANT_TAG;
      case 1:
        return tags[0];
      default: {
        let tag = new _MonomorphicTagImpl(2);
        return tag.subtag = tags, tag;
      }
    }
  }
  constructor(type) {
    this.revision = 1, this.lastChecked = 1, this.lastValue = 1, this.isUpdating = false, this.subtag = null, this.subtagBufferCache = null, this[TYPE] = type;
  }
  [COMPUTE]() {
    let {
      lastChecked
    } = this;
    if (this.isUpdating) {
      if (void 0 !== ALLOW_CYCLES && !ALLOW_CYCLES.has(this)) throw new Error("Cycles in tags are not allowed");
      this.lastChecked = ++$REVISION;
    } else if (lastChecked !== $REVISION) {
      this.isUpdating = true, this.lastChecked = $REVISION;
      try {
        let {
          subtag,
          revision
        } = this;
        if (null !== subtag) if (Array.isArray(subtag)) for (const tag of subtag) {
          let value = tag[COMPUTE]();
          revision = Math.max(value, revision);
        }
        else {
          let subtagValue = subtag[COMPUTE]();
          subtagValue === this.subtagBufferCache ? revision = Math.max(revision, this.lastValue) : (
            // Clear the temporary buffer cache
            (this.subtagBufferCache = null, revision = Math.max(revision, subtagValue))
          );
        }
        this.lastValue = revision;
      } finally {
        this.isUpdating = false;
      }
    }
    return this.lastValue;
  }
  static updateTag(_tag, _subtag) {
    if (1 !== _tag[TYPE]) throw new Error("Attempted to update a tag that was not updatable");
    let tag = _tag, subtag = _subtag;
    subtag === CONSTANT_TAG ? tag.subtag = null : (
      // There are two different possibilities when updating a subtag:
      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();
      // 2. subtag[COMPUTE]() > tag[COMPUTE]();
      // The first possibility is completely fine within our caching model, but
      // the second possibility presents a problem. If the parent tag has
      // already been read, then it's value is cached and will not update to
      // reflect the subtag's greater value. Next time the cache is busted, the
      // subtag's value _will_ be read, and it's value will be _greater_ than
      // the saved snapshot of the parent, causing the resulting calculation to
      // be rerun erroneously.
      // In order to prevent this, when we first update to a new subtag we store
      // its computed value, and then check against that computed value on
      // subsequent updates. If its value hasn't changed, then we return the
      // parent's previous value. Once the subtag changes for the first time,
      // we clear the cache and everything is finally in sync with the parent.
      (tag.subtagBufferCache = subtag[COMPUTE](), tag.subtag = subtag)
    );
  }
  static dirtyTag(tag, disableConsumptionAssertion) {
    if (1 !== tag[TYPE] && 0 !== tag[TYPE]) throw new Error("Attempted to dirty a tag that was not dirtyable");
    true !== disableConsumptionAssertion && // Usually by this point, we've already asserted with better error information,
    // but this is our last line of defense.
    unwrap(debug.assertTagNotConsumed)(tag), tag.revision = ++$REVISION, scheduleRevalidate();
  }
};
var DIRTY_TAG = MonomorphicTagImpl.dirtyTag;
var UPDATE_TAG = MonomorphicTagImpl.updateTag;
function createTag() {
  return new MonomorphicTagImpl(0);
}
function createUpdatableTag() {
  return new MonomorphicTagImpl(1);
}
var CONSTANT_TAG = new MonomorphicTagImpl(3);
var VolatileTag = class {
  [COMPUTE]() {
    return NaN;
  }
  constructor() {
    this[TYPE] = 100;
  }
};
var VOLATILE_TAG = new VolatileTag();
var CurrentTag = class {
  [COMPUTE]() {
    return $REVISION;
  }
  constructor() {
    this[TYPE] = 101;
  }
};
var CURRENT_TAG = new CurrentTag();
var combine = MonomorphicTagImpl.combine;
var tag1 = createUpdatableTag();
var tag2 = createUpdatableTag();
var tag3 = createUpdatableTag();
valueForTag(tag1), DIRTY_TAG(tag1), valueForTag(tag1), UPDATE_TAG(tag1, combine([tag2, tag3])), valueForTag(tag1), DIRTY_TAG(tag2), valueForTag(tag1), DIRTY_TAG(tag3), valueForTag(tag1), UPDATE_TAG(tag1, tag3), valueForTag(tag1), DIRTY_TAG(tag3), valueForTag(tag1);
var Tracker = class {
  add(tag) {
    tag !== CONSTANT_TAG && (this.tags.add(tag), unwrap(debug.markTagAsConsumed)(tag), this.last = tag);
  }
  combine() {
    let {
      tags
    } = this;
    return 0 === tags.size ? CONSTANT_TAG : 1 === tags.size ? this.last : combine(Array.from(this.tags));
  }
  constructor() {
    this.tags = /* @__PURE__ */ new Set(), this.last = null;
  }
};
var CURRENT_TRACKER = null;
var OPEN_TRACK_FRAMES = [];
function beginTrackFrame(debuggingContext) {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER), CURRENT_TRACKER = new Tracker(), unwrap(debug.beginTrackingTransaction)(debuggingContext);
}
function endTrackFrame() {
  let current = CURRENT_TRACKER;
  if (true) {
    if (0 === OPEN_TRACK_FRAMES.length) throw new Error("attempted to close a tracking frame, but one was not open");
    unwrap(debug.endTrackingTransaction)();
  }
  return CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null, unwrap(current).combine();
}
function beginUntrackFrame() {
  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER), CURRENT_TRACKER = null;
}
function endUntrackFrame() {
  if (0 === OPEN_TRACK_FRAMES.length) throw new Error("attempted to close a tracking frame, but one was not open");
  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;
}
function resetTracking() {
  for (; OPEN_TRACK_FRAMES.length > 0; ) OPEN_TRACK_FRAMES.pop();
  if (CURRENT_TRACKER = null, true) return unwrap(debug.resetTrackingTransaction)();
}
function isTracking() {
  return null !== CURRENT_TRACKER;
}
function consumeTag(tag) {
  null !== CURRENT_TRACKER && CURRENT_TRACKER.add(tag);
}
var FN = Symbol("FN");
var LAST_VALUE = Symbol("LAST_VALUE");
var TAG = Symbol("TAG");
var SNAPSHOT = Symbol("SNAPSHOT");
var DEBUG_LABEL = Symbol("DEBUG_LABEL");
function createCache(fn, debuggingLabel) {
  if ("function" != typeof fn) throw new Error(`createCache() must be passed a function as its first parameter. Called with: ${String(fn)}`);
  let cache = {
    [FN]: fn,
    [LAST_VALUE]: void 0,
    [TAG]: void 0,
    [SNAPSHOT]: -1
  };
  return cache[DEBUG_LABEL] = debuggingLabel, cache;
}
function getValue(cache) {
  assertCache(cache, "getValue");
  let fn = cache[FN], tag = cache[TAG], snapshot = cache[SNAPSHOT];
  if (void 0 !== tag && validateTag(tag, snapshot)) consumeTag(tag);
  else {
    beginTrackFrame();
    try {
      cache[LAST_VALUE] = fn();
    } finally {
      tag = endTrackFrame(), cache[TAG] = tag, cache[SNAPSHOT] = valueForTag(tag), consumeTag(tag);
    }
  }
  return cache[LAST_VALUE];
}
function assertCache(value, fnName) {
  if ("object" != typeof value || !(FN in value)) throw new Error(`${fnName}() can only be used on an instance of a cache created with createCache(). Called with: ${String(
    // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme
    value
  )}`);
}
function track(block, debugLabel) {
  let tag;
  beginTrackFrame(debugLabel);
  try {
    block();
  } finally {
    tag = endTrackFrame();
  }
  return tag;
}
function untrack(callback) {
  beginUntrackFrame();
  try {
    return callback();
  } finally {
    endUntrackFrame();
  }
}
var ARRAY_GETTER_METHODS = /* @__PURE__ */ new Set([Symbol.iterator, "concat", "entries", "every", "filter", "find", "findIndex", "flat", "flatMap", "forEach", "includes", "indexOf", "join", "keys", "lastIndexOf", "map", "reduce", "reduceRight", "slice", "some", "values"]);
var ARRAY_WRITE_THEN_READ_METHODS = /* @__PURE__ */ new Set(["fill", "push", "unshift"]);
function convertToInt(prop) {
  if ("symbol" == typeof prop) return null;
  const num = Number(prop);
  return isNaN(num) ? null : num % 1 == 0 ? num : null;
}
var TrackedArray = class _TrackedArray {
  #options;
  constructor(arr, options) {
    this.#collection = createUpdatableTag(), this.#storages = /* @__PURE__ */ new Map(), this.#options = options;
    const clone = arr.slice(), self = this, boundFns = /* @__PURE__ */ new Map();
    let nativelyAccessingLengthFromPushOrUnshift = false;
    return new Proxy(clone, {
      get(target, prop) {
        const index = convertToInt(prop);
        if (null !== index) return self.#readStorageFor(index), consumeTag(self.#collection), target[index];
        if ("length" === prop)
          return nativelyAccessingLengthFromPushOrUnshift ? nativelyAccessingLengthFromPushOrUnshift = false : consumeTag(self.#collection), target[prop];
        if (ARRAY_WRITE_THEN_READ_METHODS.has(prop) && (nativelyAccessingLengthFromPushOrUnshift = true), ARRAY_GETTER_METHODS.has(prop)) {
          let fn = boundFns.get(prop);
          return void 0 === fn && (fn = (...args) => (consumeTag(self.#collection), target[prop](...args)), boundFns.set(prop, fn)), fn;
        }
        return target[prop];
      },
      set(target, prop, value) {
        if (self.#options.equals(target[prop], value)) return true;
        target[prop] = value;
        const index = convertToInt(prop);
        return null !== index ? (self.#dirtyStorageFor(index), self.#dirtyCollection()) : "length" === prop && self.#dirtyCollection(), true;
      },
      getPrototypeOf: () => _TrackedArray.prototype
    });
  }
  #collection;
  #storages;
  #readStorageFor(index) {
    let storage = this.#storages.get(index);
    void 0 === storage && (storage = createUpdatableTag(), this.#storages.set(index, storage)), consumeTag(storage);
  }
  #dirtyStorageFor(index) {
    const storage = this.#storages.get(index);
    storage && DIRTY_TAG(storage);
  }
  #dirtyCollection() {
    DIRTY_TAG(this.#collection), this.#storages.clear();
  }
};
Object.setPrototypeOf(TrackedArray.prototype, Array.prototype);
var TrackedMap = class {
  #options;
  #collection;
  #storages;
  #vals;
  #storageFor(key) {
    const storages = this.#storages;
    let storage = storages.get(key);
    return void 0 === storage && (storage = createUpdatableTag(), storages.set(key, storage)), storage;
  }
  #dirtyStorageFor(key) {
    const storage = this.#storages.get(key);
    storage && DIRTY_TAG(storage);
  }
  constructor(existing, options) {
    this.#collection = createUpdatableTag(), this.#storages = /* @__PURE__ */ new Map(), // TypeScript doesn't correctly resolve the overloads for calling the `Map`
    // constructor for the no-value constructor. This resolves that.
    this.#vals = existing instanceof Map ? new Map(existing.entries()) : new Map(existing), this.#options = options;
  }
  get(key) {
    return consumeTag(this.#storageFor(key)), this.#vals.get(key);
  }
  has(key) {
    return consumeTag(this.#storageFor(key)), this.#vals.has(key);
  }
  // **** ALL GETTERS ****
  entries() {
    return consumeTag(this.#collection), this.#vals.entries();
  }
  keys() {
    return consumeTag(this.#collection), this.#vals.keys();
  }
  values() {
    return consumeTag(this.#collection), this.#vals.values();
  }
  forEach(fn) {
    consumeTag(this.#collection), this.#vals.forEach(fn);
  }
  get size() {
    return consumeTag(this.#collection), this.#vals.size;
  }
  /**
  * When iterating:
  * - we entangle with the collection (as we iterate over the whole thing
  * - for each individual item, we entangle with the item as well
  */
  [Symbol.iterator]() {
    let keys = this.keys(), self = this;
    return {
      next() {
        let next = keys.next(), currentKey = next.value;
        return next.done ? {
          value: [void 0, void 0],
          done: true
        } : {
          value: [currentKey, self.get(currentKey)],
          done: false
        };
      }
    };
  }
  get [Symbol.toStringTag]() {
    return this.#vals[Symbol.toStringTag];
  }
  set(key, value) {
    let existing = this.#vals.get(key);
    return existing && this.#options.equals(existing, value) || (this.#dirtyStorageFor(key), existing || DIRTY_TAG(this.#collection), this.#vals.set(key, value)), this;
  }
  delete(key) {
    return !this.#vals.has(key) || (this.#dirtyStorageFor(key), DIRTY_TAG(this.#collection), this.#storages.delete(key), this.#vals.delete(key));
  }
  clear() {
    0 !== this.#vals.size && (this.#storages.forEach((s) => DIRTY_TAG(s)), this.#storages.clear(), DIRTY_TAG(this.#collection), this.#vals.clear());
  }
};
Object.setPrototypeOf(TrackedMap.prototype, Map.prototype);
var TrackedSet = class {
  #options;
  #collection;
  #storages;
  #vals;
  #storageFor(key) {
    const storages = this.#storages;
    let storage = storages.get(key);
    return void 0 === storage && (storage = createUpdatableTag(), storages.set(key, storage)), storage;
  }
  #dirtyStorageFor(key) {
    const storage = this.#storages.get(key);
    storage && DIRTY_TAG(storage);
  }
  constructor(existing, options) {
    this.#collection = createUpdatableTag(), this.#storages = /* @__PURE__ */ new Map(), this.#vals = new Set(existing), this.#options = options;
  }
  // **** KEY GETTERS ****
  has(value) {
    return consumeTag(this.#storageFor(value)), this.#vals.has(value);
  }
  // **** ALL GETTERS ****
  entries() {
    return consumeTag(this.#collection), this.#vals.entries();
  }
  keys() {
    return consumeTag(this.#collection), this.#vals.keys();
  }
  values() {
    return consumeTag(this.#collection), this.#vals.values();
  }
  union(other) {
    return consumeTag(this.#collection), this.#vals.union(other);
  }
  intersection(other) {
    return consumeTag(this.#collection), this.#vals.intersection(other);
  }
  difference(other) {
    return consumeTag(this.#collection), this.#vals.difference(other);
  }
  symmetricDifference(other) {
    return consumeTag(this.#collection), this.#vals.symmetricDifference(other);
  }
  isSubsetOf(other) {
    return consumeTag(this.#collection), this.#vals.isSubsetOf(other);
  }
  isSupersetOf(other) {
    return consumeTag(this.#collection), this.#vals.isSupersetOf(other);
  }
  isDisjointFrom(other) {
    return consumeTag(this.#collection), this.#vals.isDisjointFrom(other);
  }
  forEach(fn) {
    consumeTag(this.#collection), this.#vals.forEach(fn);
  }
  get size() {
    return consumeTag(this.#collection), this.#vals.size;
  }
  [Symbol.iterator]() {
    return consumeTag(this.#collection), this.#vals[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return this.#vals[Symbol.toStringTag];
  }
  add(value) {
    if (this.#vals.has(value)) {
      if (this.#options.equals(value, value)) return this;
    } else DIRTY_TAG(this.#collection);
    return this.#dirtyStorageFor(value), this.#vals.add(value), this;
  }
  delete(value) {
    return !this.#vals.has(value) || (this.#dirtyStorageFor(value), DIRTY_TAG(this.#collection), this.#storages.delete(value), this.#vals.delete(value));
  }
  // **** ALL SETTERS ****
  clear() {
    0 !== this.#vals.size && (this.#storages.forEach((s) => DIRTY_TAG(s)), DIRTY_TAG(this.#collection), this.#storages.clear(), this.#vals.clear());
  }
};
Object.setPrototypeOf(TrackedSet.prototype, Set.prototype);
var TrackedWeakMap = class {
  #options;
  #storages;
  #vals;
  #storageFor(key) {
    let storage = this.#storages.get(key);
    return void 0 === storage && (storage = createUpdatableTag(), this.#storages.set(key, storage)), storage;
  }
  #dirtyStorageFor(key) {
    const storage = this.#storages.get(key);
    storage && DIRTY_TAG(storage);
  }
  constructor(existing, options) {
    this.#storages = /* @__PURE__ */ new WeakMap(), /**
    * SAFETY: note that wehn passing in an existing weak map, we can't
    *         clone it as it is not iterable and not a supported type of structuredClone
    */
    this.#vals = existing instanceof WeakMap ? existing : new WeakMap(existing), this.#options = options;
  }
  get(key) {
    return consumeTag(this.#storageFor(key)), this.#vals.get(key);
  }
  has(key) {
    return consumeTag(this.#storageFor(key)), this.#vals.has(key);
  }
  set(key, value) {
    let existing = this.#vals.get(key);
    return existing && this.#options.equals(existing, value) || (this.#dirtyStorageFor(key), this.#vals.set(key, value)), this;
  }
  delete(key) {
    return !this.#vals.has(key) || (this.#dirtyStorageFor(key), this.#storages.delete(key), this.#vals.delete(key));
  }
  get [Symbol.toStringTag]() {
    return this.#vals[Symbol.toStringTag];
  }
};
Object.setPrototypeOf(TrackedWeakMap.prototype, WeakMap.prototype);
var TrackedWeakSet = class {
  #options;
  #storages;
  #vals;
  #storageFor(key) {
    let storage = this.#storages.get(key);
    return void 0 === storage && (storage = createUpdatableTag(), this.#storages.set(key, storage)), storage;
  }
  #dirtyStorageFor(key) {
    const storage = this.#storages.get(key);
    storage && DIRTY_TAG(storage);
  }
  constructor(values, options) {
    this.#storages = /* @__PURE__ */ new WeakMap(), this.#options = options, this.#vals = new WeakSet(values);
  }
  has(value) {
    return consumeTag(this.#storageFor(value)), this.#vals.has(value);
  }
  add(value) {
    return this.#vals.has(value) && this.#options.equals(value, value) || // Add to vals first to get better error message
    (this.#vals.add(value), this.#dirtyStorageFor(value)), this;
  }
  delete(value) {
    return !this.#vals.has(value) || (this.#dirtyStorageFor(value), this.#storages.delete(value), this.#vals.delete(value));
  }
  get [Symbol.toStringTag]() {
    return this.#vals[Symbol.toStringTag];
  }
};
Object.setPrototypeOf(TrackedWeakSet.prototype, WeakSet.prototype);
var TRACKED_TAGS = /* @__PURE__ */ new WeakMap();
function dirtyTagFor(obj, key, meta) {
  if (("object" != typeof (u = obj) || null === u) && "function" != typeof u) throw new Error("BUG: Can't update a tag for a primitive");
  var u;
  let tags = void 0 === meta ? TRACKED_TAGS.get(obj) : meta;
  if (void 0 === tags) return;
  let propertyTag = tags.get(key);
  void 0 !== propertyTag && (unwrap(debug.assertTagNotConsumed)(propertyTag, obj, key), DIRTY_TAG(propertyTag, true));
}
function tagMetaFor(obj) {
  let tags = TRACKED_TAGS.get(obj);
  return void 0 === tags && (tags = /* @__PURE__ */ new Map(), TRACKED_TAGS.set(obj, tags)), tags;
}
function tagFor(obj, key, meta) {
  let tags = void 0 === meta ? tagMetaFor(obj) : meta, tag = tags.get(key);
  return void 0 === tag && (tag = createUpdatableTag(), tags.set(key, tag)), tag;
}
function trackedData(key, initializer) {
  let values = /* @__PURE__ */ new WeakMap(), hasInitializer = "function" == typeof initializer;
  return {
    getter: function(self) {
      let value;
      return consumeTag(tagFor(self, key)), hasInitializer && !values.has(self) ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
        (value = initializer.call(self), values.set(self, value))
      ) : value = values.get(self), value;
    },
    setter: function(self, value) {
      dirtyTagFor(self, key), values.set(self, value);
    }
  };
}
var GLIMMER_VALIDATOR_REGISTRATION = Symbol("GLIMMER_VALIDATOR_REGISTRATION");
if (Reflect.has(globalThis, GLIMMER_VALIDATOR_REGISTRATION)) throw new Error("The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.");
Reflect.set(globalThis, GLIMMER_VALIDATOR_REGISTRATION, true);

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/util/index.js
var EMPTY_ARRAY = Object.freeze([]);
function emptyArray() {
  return EMPTY_ARRAY;
}
var EMPTY_STRING_ARRAY = emptyArray();
var EMPTY_NUMBER_ARRAY = emptyArray();
function* reverse(input) {
  for (let i = input.length - 1; i >= 0; i--)
    yield input[i];
}
function* enumerate(input) {
  let i = 0;
  for (const item of input) yield [i++, item];
}
function getLast(list) {
  return 0 === list.length ? void 0 : list[list.length - 1];
}
function dict() {
  return /* @__PURE__ */ Object.create(null);
}
function isDict(u) {
  return null != u;
}
function isIndexable(u) {
  return "function" == typeof u || "object" == typeof u && null !== u;
}
var StackImpl = class {
  constructor(values = []) {
    this.current = null, this.stack = values;
  }
  get size() {
    return this.stack.length;
  }
  push(item) {
    this.current = item, this.stack.push(item);
  }
  pop() {
    let item = this.stack.pop();
    return this.current = getLast(this.stack) ?? null, void 0 === item ? null : item;
  }
  nth(from) {
    let len = this.stack.length;
    return len < from ? null : this.stack[len - from];
  }
  isEmpty() {
    return 0 === this.stack.length;
  }
  snapshot() {
    return [...this.stack];
  }
  toArray() {
    return this.stack;
  }
};
function clearElement(parent) {
  let current = parent.firstChild;
  for (; current; ) {
    let next = current.nextSibling;
    parent.removeChild(current), current = next;
  }
}
var assign = Object.assign;

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/reference/index.js
var REFERENCE = Symbol("REFERENCE");
var ReferenceImpl = class {
  constructor(type) {
    this.tag = null, this.lastRevision = INITIAL, this.children = null, this.compute = null, this.update = null, this[REFERENCE] = type;
  }
};
function createPrimitiveRef(value) {
  const ref = new ReferenceImpl(2);
  return ref.tag = CONSTANT_TAG, ref.lastValue = value, ref.debugLabel = String(value), ref;
}
var UNDEFINED_REFERENCE = createPrimitiveRef(void 0);
var NULL_REFERENCE = createPrimitiveRef(null);
var TRUE_REFERENCE = createPrimitiveRef(true);
var FALSE_REFERENCE = createPrimitiveRef(false);
function createConstRef(value, debugLabel) {
  const ref = new ReferenceImpl(0);
  return ref.lastValue = value, ref.tag = CONSTANT_TAG, ref.debugLabel = debugLabel, ref;
}
function createUnboundRef(value, debugLabel) {
  const ref = new ReferenceImpl(2);
  return ref.lastValue = value, ref.tag = CONSTANT_TAG, ref.debugLabel = debugLabel, ref;
}
function createComputeRef(compute, update = null, debugLabel = "unknown") {
  const ref = new ReferenceImpl(1);
  return ref.compute = compute, ref.update = update, ref.debugLabel = `(result of a \`${debugLabel}\` helper)`, ref;
}
function createReadOnlyRef(ref) {
  return isUpdatableRef(ref) ? createComputeRef(() => valueForRef(ref), null, ref.debugLabel) : ref;
}
function isInvokableRef(ref) {
  return 3 === ref[REFERENCE];
}
function createInvokableRef(inner) {
  const ref = createComputeRef(() => valueForRef(inner), (value) => updateRef(inner, value));
  return ref.debugLabel = inner.debugLabel, ref[REFERENCE] = 3, ref;
}
function isConstRef(_ref) {
  return _ref.tag === CONSTANT_TAG;
}
function isUpdatableRef(_ref) {
  return null !== _ref.update;
}
function valueForRef(_ref) {
  const ref = _ref;
  let {
    tag
  } = ref;
  if (tag === CONSTANT_TAG) return ref.lastValue;
  const {
    lastRevision
  } = ref;
  let lastValue;
  if (null !== tag && validateTag(tag, lastRevision)) lastValue = ref.lastValue;
  else {
    const {
      compute
    } = ref, newTag = track(() => {
      lastValue = ref.lastValue = compute();
    }, ref.debugLabel);
    tag = ref.tag = newTag, ref.lastRevision = valueForTag(newTag);
  }
  return consumeTag(tag), lastValue;
}
function updateRef(_ref, value) {
  (0, _ref.update)(value);
}
function childRefFor(_parentRef, path) {
  const parentRef = _parentRef, type = parentRef[REFERENCE];
  let child, children = parentRef.children;
  if (null === children) children = parentRef.children = /* @__PURE__ */ new Map();
  else {
    const next = children.get(path);
    if (next) return next;
  }
  if (2 === type) {
    const parent = valueForRef(parentRef);
    child = isDict(parent) ? createUnboundRef(parent[path], `${parentRef.debugLabel}.${path}`) : UNDEFINED_REFERENCE;
  } else child = createComputeRef(() => {
    const parent = valueForRef(parentRef);
    if (isDict(parent)) return getProp(parent, path);
  }, (val) => {
    const parent = valueForRef(parentRef);
    if (isDict(parent)) return setProp(parent, path, val);
  }), child.debugLabel = `${parentRef.debugLabel}.${path}`;
  return children.set(path, child), child;
}
function childRefFromParts(root, parts) {
  let reference = root;
  for (const part of parts) reference = childRefFor(reference, part);
  return reference;
}
var createDebugAliasRef;
createDebugAliasRef = (debugLabel, inner) => {
  const ref = createComputeRef(() => valueForRef(inner), isUpdatableRef(inner) ? (value) => updateRef(inner, value) : null);
  return ref[REFERENCE] = inner[REFERENCE], ref.debugLabel = debugLabel, ref;
};
var NULL_IDENTITY = {};
var KEY = (_, index) => index;
var INDEX = (_, index) => String(index);
var IDENTITY = (item) => null === item ? NULL_IDENTITY : item;
var WeakMapWithPrimitives = class {
  get weakMap() {
    return void 0 === this._weakMap && (this._weakMap = /* @__PURE__ */ new WeakMap()), this._weakMap;
  }
  get primitiveMap() {
    return void 0 === this._primitiveMap && (this._primitiveMap = /* @__PURE__ */ new Map()), this._primitiveMap;
  }
  set(key, value) {
    isIndexable(key) ? this.weakMap.set(key, value) : this.primitiveMap.set(key, value);
  }
  get(key) {
    return isIndexable(key) ? this.weakMap.get(key) : this.primitiveMap.get(key);
  }
};
var IDENTITIES = new WeakMapWithPrimitives();
function uniqueKeyFor(keyFor) {
  let seen = new WeakMapWithPrimitives();
  return (value, memo) => {
    let key = keyFor(value, memo), count = seen.get(key) || 0;
    return seen.set(key, count + 1), 0 === count ? key : (function(value2, count2) {
      let identities = IDENTITIES.get(value2);
      void 0 === identities && (identities = [], IDENTITIES.set(value2, identities));
      let identity = identities[count2];
      return void 0 === identity && (identity = {
        value: value2,
        count: count2
      }, identities[count2] = identity), identity;
    })(key, count);
  };
}
function createIteratorRef(listRef, key) {
  return createComputeRef(() => {
    let iterable = valueForRef(listRef), keyFor = (function(key2) {
      switch (key2) {
        case "@key":
          return uniqueKeyFor(KEY);
        case "@index":
          return uniqueKeyFor(INDEX);
        case "@identity":
          return uniqueKeyFor(IDENTITY);
        default:
          return (function(path) {
            if ("@" === path[0]) throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);
            return uniqueKeyFor((item) => getPath(item, path));
          })(key2);
      }
    })(key);
    if (Array.isArray(iterable)) return new ArrayIterator(iterable, keyFor);
    let maybeIterator = toIterator(iterable);
    return null === maybeIterator ? new ArrayIterator(EMPTY_ARRAY, () => null) : new IteratorWrapper(maybeIterator, keyFor);
  });
}
function createIteratorItemRef(_value) {
  let value = _value, tag = createTag();
  return createComputeRef(() => (consumeTag(tag), value), (newValue) => {
    value !== newValue && (value = newValue, DIRTY_TAG(tag));
  });
}
var IteratorWrapper = class {
  constructor(inner, keyFor) {
    this.inner = inner, this.keyFor = keyFor;
  }
  isEmpty() {
    return this.inner.isEmpty();
  }
  next() {
    let nextValue = this.inner.next();
    return null !== nextValue && (nextValue.key = this.keyFor(nextValue.value, nextValue.memo)), nextValue;
  }
};
var ArrayIterator = class {
  constructor(iterator, keyFor) {
    this.iterator = iterator, this.keyFor = keyFor, this.pos = 0, 0 === iterator.length ? this.current = {
      kind: "empty"
    } : this.current = {
      kind: "first",
      value: iterator[this.pos]
    };
  }
  isEmpty() {
    return "empty" === this.current.kind;
  }
  next() {
    let value, current = this.current;
    if ("first" === current.kind) this.current = {
      kind: "progress"
    }, value = current.value;
    else {
      if (this.pos >= this.iterator.length - 1) return null;
      value = this.iterator[++this.pos];
    }
    let {
      keyFor
    } = this;
    return {
      key: keyFor(value, this.pos),
      value,
      memo: this.pos
    };
  }
};

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/vm/index.js
var ContentType = {
  Component: 0,
  Helper: 1,
  String: 2,
  Empty: 3,
  SafeString: 4,
  Fragment: 5,
  Node: 6,
  Other: 8
};
var InternalComponentCapabilities = {
  Empty: 0,
  dynamicLayout: 1,
  dynamicTag: 2,
  prepareArgs: 4,
  createArgs: 8,
  attributeHook: 16,
  elementHook: 32,
  dynamicScope: 64,
  createCaller: 128,
  updateHook: 256,
  createInstance: 512,
  wrapped: 1024,
  willDestroy: 2048,
  hasSubOwner: 4096
};
var ARG_SHIFT = 8;
var MAX_SIZE = 2147483647;
var TYPE_SIZE = 255;
var TYPE_MASK = 255;
var OPERAND_LEN_MASK = 768;
var MACHINE_MASK = 1024;
var $pc = 0;
var $ra = 1;
var $fp = 2;
var $sp = 3;
var $s0 = 4;
var $s1 = 5;
var $t0 = 6;
var $t1 = 7;
var $v0 = 8;
function isLowLevelRegister(register) {
  return register <= 3;
}

// ../../node_modules/.pnpm/ember-source@6.10.0_@glimmer+component@2.0.0_rsvp@4.8.5/node_modules/ember-source/dist/packages/@glimmer/manager/index.js
var debugToString2;
if (true) {
  let getFunctionName = (fn) => {
    let functionName = fn.name;
    if ("" === functionName) {
      let match = /function (\w+)\s*\(/u.exec(String(fn));
      functionName = match && match[1] || "";
    }
    return functionName.replace(/^bound /u, "");
  }, getObjectName = (obj) => {
    let name, className;
    return "function" == typeof obj.constructor && (className = getFunctionName(obj.constructor)), "toString" in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString && // eslint-disable-next-line @typescript-eslint/no-base-to-string
    (name = obj.toString()), name && /<.*:ember\d+>/u.test(name) && className && "_" !== className[0] && className.length > 2 && "Class" !== className ? name.replace(/<.*:/u, `<${className}:`) : name || className;
  }, getPrimitiveName = (value) => String(value);
  debugToString2 = (value) => "function" == typeof value ? getFunctionName(value) || "(unknown function)" : "object" == typeof value && null !== value ? getObjectName(value) || "(unknown object)" : getPrimitiveName(value);
}
var debugToString$12 = debugToString2;
var CUSTOM_TAG_FOR = /* @__PURE__ */ new WeakMap();
function getCustomTagFor(obj) {
  return CUSTOM_TAG_FOR.get(obj);
}
function setCustomTagFor(obj, customTagFn) {
  CUSTOM_TAG_FOR.set(obj, customTagFn);
}
function convertToInt2(prop) {
  if ("symbol" == typeof prop) return null;
  const num = Number(prop);
  return isNaN(num) ? null : num % 1 == 0 ? num : null;
}
var NamedArgsProxy = class {
  constructor(named) {
    this.named = named;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme
  get(_target, prop) {
    const ref = this.named[prop];
    if (void 0 !== ref) return valueForRef(ref);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme
  has(_target, prop) {
    return prop in this.named;
  }
  ownKeys() {
    return Object.keys(this.named);
  }
  isExtensible() {
    return false;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-object-type -- @fixme
  getOwnPropertyDescriptor(_target, prop) {
    if (!(prop in this.named)) throw new Error(`args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \`${String(prop)}\``);
    return {
      enumerable: true,
      configurable: true
    };
  }
};
var PositionalArgsProxy = class {
  constructor(positional) {
    this.positional = positional;
  }
  get(target, prop) {
    let {
      positional
    } = this;
    if ("length" === prop) return positional.length;
    const parsed = convertToInt2(prop);
    return null !== parsed && parsed < positional.length ? valueForRef(positional[parsed]) : target[prop];
  }
  isExtensible() {
    return false;
  }
  has(_target, prop) {
    const parsed = convertToInt2(prop);
    return null !== parsed && parsed < this.positional.length;
  }
};
var argsProxyFor = (capturedArgs, type) => {
  const {
    named,
    positional
  } = capturedArgs, namedHandler = new NamedArgsProxy(named), positionalHandler = new PositionalArgsProxy(positional), namedTarget = /* @__PURE__ */ Object.create(null);
  if (true) {
    const setHandler = function(_target, prop) {
      throw new Error(`You attempted to set ${String(prop)} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`);
    }, forInDebugHandler = () => {
      throw new Error(`Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`);
    };
    namedHandler.set = setHandler, positionalHandler.set = setHandler, positionalHandler.ownKeys = forInDebugHandler;
  }
  const namedProxy = new Proxy(namedTarget, namedHandler), positionalProxy = new Proxy([], positionalHandler);
  return setCustomTagFor(namedProxy, (_obj, key) => (function(namedArgs, key2) {
    return track(() => {
      key2 in namedArgs && // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
      valueForRef(namedArgs[key2]);
    });
  })(named, key)), setCustomTagFor(positionalProxy, (_obj, key) => (function(positionalArgs, key2) {
    return track(() => {
      "[]" === key2 && // consume all of the tags in the positional array
      positionalArgs.forEach(valueForRef);
      const parsed = convertToInt2(key2);
      null !== parsed && parsed < positionalArgs.length && // consume the tag of the referenced index
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
      valueForRef(positionalArgs[parsed]);
    });
  })(positional, key)), {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    named: namedProxy,
    positional: positionalProxy
  };
};
var FROM_CAPABILITIES = true ? /* @__PURE__ */ new WeakSet() : void 0;
function buildCapabilities(capabilities) {
  return /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme */ FROM_CAPABILITIES.add(capabilities), Object.freeze(capabilities), capabilities;
}
var EMPTY = InternalComponentCapabilities.Empty;
function capabilityFlagsFrom(capabilities) {
  return EMPTY | capability(capabilities, "dynamicLayout") | capability(capabilities, "dynamicTag") | capability(capabilities, "prepareArgs") | capability(capabilities, "createArgs") | capability(capabilities, "attributeHook") | capability(capabilities, "elementHook") | capability(capabilities, "dynamicScope") | capability(capabilities, "createCaller") | capability(capabilities, "updateHook") | capability(capabilities, "createInstance") | capability(capabilities, "wrapped") | capability(capabilities, "willDestroy") | capability(capabilities, "hasSubOwner");
}
function capability(capabilities, capability2) {
  return capabilities[capability2] ? InternalComponentCapabilities[capability2] : EMPTY;
}
function managerHasCapability(_manager, capabilities, capability2) {
  return !!(capabilities & capability2);
}
function hasCapability(capabilities, capability2) {
  return !!(capabilities & capability2);
}
function helperCapabilities(managerAPI, options = {}) {
  if (debugAssert(
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check
    "3.23" === managerAPI,
    () => `Invalid helper manager compatibility specified; you specified ${managerAPI}, but only '3.23' is supported.`
  ), !options.hasValue && !options.hasScheduledEffect || options.hasValue && options.hasScheduledEffect) throw new Error("You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.");
  if (options.hasScheduledEffect) throw new Error("The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead");
  return buildCapabilities({
    hasValue: Boolean(options.hasValue),
    hasDestroyable: Boolean(options.hasDestroyable),
    hasScheduledEffect: Boolean(options.hasScheduledEffect)
  });
}
function hasValue(manager) {
  return manager.capabilities.hasValue;
}
function hasDestroyable(manager) {
  return manager.capabilities.hasDestroyable;
}
var CustomHelperManager = class {
  constructor(factory) {
    this.factory = factory, this.helperManagerDelegates = /* @__PURE__ */ new WeakMap(), this.undefinedDelegate = null;
  }
  getDelegateForOwner(owner) {
    let delegate = this.helperManagerDelegates.get(owner);
    if (void 0 === delegate) {
      let {
        factory
      } = this;
      if (delegate = factory(owner), !FROM_CAPABILITIES.has(delegate.capabilities))
        throw new Error(`Custom helper managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.23')\` (imported via \`import { capabilities } from '@ember/helper';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      this.helperManagerDelegates.set(owner, delegate);
    }
    return delegate;
  }
  getDelegateFor(owner) {
    if (void 0 === owner) {
      let {
        undefinedDelegate
      } = this;
      if (null === undefinedDelegate) {
        let {
          factory
        } = this;
        this.undefinedDelegate = undefinedDelegate = factory(void 0);
      }
      return undefinedDelegate;
    }
    return this.getDelegateForOwner(owner);
  }
  getHelper(definition) {
    return (capturedArgs, owner) => {
      let manager = this.getDelegateFor(owner);
      const args = argsProxyFor(capturedArgs, "helper"), bucket = manager.createHelper(definition, args);
      if (hasValue(manager)) {
        let cache = createComputeRef(() => manager.getValue(bucket), null, manager.getDebugName && manager.getDebugName(definition));
        return hasDestroyable(manager) && associateDestroyableChild(cache, manager.getDestroyable(bucket)), cache;
      }
      if (hasDestroyable(manager)) {
        let ref = createConstRef(void 0, manager.getDebugName?.(definition) ?? "unknown helper");
        return associateDestroyableChild(ref, manager.getDestroyable(bucket)), ref;
      }
      return UNDEFINED_REFERENCE;
    };
  }
};
var FunctionHelperManager = class {
  createHelper(fn, args) {
    return {
      fn,
      args
    };
  }
  getValue({
    fn,
    args
  }) {
    return Object.keys(args.named).length > 0 ? fn(...args.positional, args.named) : fn(...args.positional);
  }
  getDebugName(fn) {
    return fn.name ? `(helper function ${fn.name})` : "(anonymous helper function)";
  }
  constructor() {
    this.capabilities = buildCapabilities({
      hasValue: true,
      hasDestroyable: false,
      hasScheduledEffect: false
    });
  }
};
var COMPONENT_MANAGERS = /* @__PURE__ */ new WeakMap();
var MODIFIER_MANAGERS = /* @__PURE__ */ new WeakMap();
var HELPER_MANAGERS = /* @__PURE__ */ new WeakMap();
var getPrototypeOf$1 = Object.getPrototypeOf;
function setManager(map, manager, obj) {
  return debugAssert(
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check
    null !== obj && ("object" == typeof obj || "function" == typeof obj),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    `Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString$12(obj)}`
  ), debugAssert(!map.has(obj), `Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString$12(obj)}`), map.set(obj, manager), obj;
}
function getManager(map, obj) {
  let pointer = obj;
  for (; null !== pointer; ) {
    const manager = map.get(pointer);
    if (void 0 !== manager) return manager;
    pointer = getPrototypeOf$1(pointer);
  }
}
function setInternalModifierManager(manager, definition) {
  return setManager(MODIFIER_MANAGERS, manager, definition);
}
function getInternalModifierManager(definition, isOptional) {
  debugAssert(
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check
    "object" == typeof definition && null !== definition || "function" == typeof definition,
    () => (
      // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme
      `Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`
    )
  );
  const manager = getManager(MODIFIER_MANAGERS, definition);
  return void 0 === manager ? (debugAssert(
    isOptional,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    `Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString$12(definition)}`
  ), null) : manager;
}
function setInternalHelperManager(manager, definition) {
  return setManager(HELPER_MANAGERS, manager, definition);
}
var DEFAULT_MANAGER = new CustomHelperManager(() => new FunctionHelperManager());
function getInternalHelperManager(definition, isOptional) {
  debugAssert(
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check
    "object" == typeof definition && null !== definition || "function" == typeof definition,
    () => (
      // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme
      `Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`
    )
  );
  let manager = getManager(HELPER_MANAGERS, definition);
  if (void 0 === manager && "function" == typeof definition && (manager = DEFAULT_MANAGER), manager) return manager;
  if (true === isOptional) return null;
  if (true) throw new Error(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    `Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString$12(definition)}`
  );
  return null;
}
function setInternalComponentManager(factory, obj) {
  return setManager(COMPONENT_MANAGERS, factory, obj);
}
function getInternalComponentManager(definition, isOptional) {
  debugAssert(
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- JS-only check
    "object" == typeof definition && null !== definition || "function" == typeof definition,
    () => (
      // eslint-disable-next-line @typescript-eslint/no-base-to-string -- @fixme
      `Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`
    )
  );
  const manager = getManager(COMPONENT_MANAGERS, definition);
  return void 0 === manager ? (debugAssert(isOptional, () => (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    `Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString$12(definition)}`
  )), null) : manager;
}
function hasInternalComponentManager(definition) {
  return void 0 !== getManager(COMPONENT_MANAGERS, definition);
}
function hasInternalHelperManager(definition) {
  return /* @__PURE__ */ (function(definition2) {
    return "function" == typeof definition2;
  })(definition) || void 0 !== getManager(HELPER_MANAGERS, definition);
}
var CAPABILITIES = {
  dynamicLayout: false,
  dynamicTag: false,
  prepareArgs: false,
  createArgs: true,
  attributeHook: false,
  elementHook: false,
  createCaller: false,
  dynamicScope: true,
  updateHook: true,
  createInstance: true,
  wrapped: false,
  willDestroy: false,
  hasSubOwner: false
};
function componentCapabilities(managerAPI, options = {}) {
  if ("3.13" !== managerAPI) throw new Error("Invalid component manager compatibility specified");
  let updateHook = Boolean(options.updateHook);
  return buildCapabilities({
    asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),
    destructor: Boolean(options.destructor),
    updateHook
  });
}
function hasAsyncLifeCycleCallbacks(delegate) {
  return delegate.capabilities.asyncLifeCycleCallbacks;
}
function hasUpdateHook(delegate) {
  return delegate.capabilities.updateHook;
}
var CustomComponentManager = class {
  constructor(factory) {
    this.factory = factory, this.componentManagerDelegates = /* @__PURE__ */ new WeakMap();
  }
  getDelegateFor(owner) {
    let {
      componentManagerDelegates
    } = this, delegate = componentManagerDelegates.get(owner);
    if (void 0 === delegate) {
      let {
        factory
      } = this;
      if (delegate = factory(owner), !FROM_CAPABILITIES.has(delegate.capabilities))
        throw new Error(`Custom component managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.13')\` (imported via \`import { capabilities } from '@ember/component';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      componentManagerDelegates.set(owner, delegate);
    }
    return delegate;
  }
  create(owner, definition, vmArgs) {
    let delegate = this.getDelegateFor(owner), args = argsProxyFor(vmArgs.capture(), "component"), component = delegate.createComponent(definition, args);
    return new CustomComponentState(component, delegate, args);
  }
  getDebugName(definition) {
    return "function" == typeof definition ? definition.name : definition.toString();
  }
  update(bucket) {
    let {
      delegate
    } = bucket;
    if (hasUpdateHook(delegate)) {
      let {
        component,
        args
      } = bucket;
      delegate.updateComponent(component, args);
    }
  }
  didCreate({
    component,
    delegate
  }) {
    hasAsyncLifeCycleCallbacks(delegate) && delegate.didCreateComponent(component);
  }
  didUpdate({
    component,
    delegate
  }) {
    (function(delegate2) {
      return hasAsyncLifeCycleCallbacks(delegate2) && hasUpdateHook(delegate2);
    })(delegate) && delegate.didUpdateComponent(component);
  }
  didRenderLayout() {
  }
  didUpdateLayout() {
  }
  getSelf({
    component,
    delegate
  }) {
    return createConstRef(delegate.getContext(component), "this");
  }
  getDestroyable(bucket) {
    const {
      delegate
    } = bucket;
    if ((function(delegate2) {
      return delegate2.capabilities.destructor;
    })(delegate)) {
      const {
        component
      } = bucket;
      return registerDestructor(bucket, () => delegate.destroyComponent(component)), bucket;
    }
    return null;
  }
  getCapabilities() {
    return CAPABILITIES;
  }
};
var CustomComponentState = class {
  constructor(component, delegate, args) {
    this.component = component, this.delegate = delegate, this.args = args;
  }
};
function modifierCapabilities(managerAPI, optionalFeatures = {}) {
  return debugAssert("3.22" === managerAPI, () => `Invalid modifier manager compatibility specified; you specified ${managerAPI}, but only '3.22' is supported.`), buildCapabilities({
    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking)
  });
}
var CustomModifierManager = class {
  constructor(factory) {
    this.factory = factory, this.componentManagerDelegates = /* @__PURE__ */ new WeakMap();
  }
  getDelegateFor(owner) {
    let {
      componentManagerDelegates
    } = this, delegate = componentManagerDelegates.get(owner);
    if (void 0 === delegate) {
      let {
        factory
      } = this;
      if (delegate = factory(owner), !FROM_CAPABILITIES.has(delegate.capabilities))
        throw new Error(`Custom modifier managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.22')\` (imported via \`import { capabilities } from '@ember/modifier';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      componentManagerDelegates.set(owner, delegate);
    }
    return delegate;
  }
  create(owner, element, definition, capturedArgs) {
    let state, delegate = this.getDelegateFor(owner), args = argsProxyFor(capturedArgs, "modifier"), instance = delegate.createModifier(definition, args);
    return state = {
      tag: createUpdatableTag(),
      element,
      delegate,
      args,
      modifier: instance
    }, registerDestructor(state, () => delegate.destroyModifier(instance, args)), state;
  }
  getDebugName(definition) {
    return "function" == typeof definition ? definition.name || definition.toString() : "<unknown>";
  }
  getDebugInstance({
    modifier
  }) {
    return modifier;
  }
  getTag({
    tag
  }) {
    return tag;
  }
  install({
    element,
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;
    capabilities.disableAutoTracking ? untrack(() => delegate.installModifier(modifier, element, args)) : delegate.installModifier(modifier, element, args);
  }
  update({
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;
    capabilities.disableAutoTracking ? untrack(() => delegate.updateModifier(modifier, args)) : delegate.updateModifier(modifier, args);
  }
  getDestroyable(state) {
    return state;
  }
};
function setComponentManager(factory, obj) {
  return setInternalComponentManager(new CustomComponentManager(factory), obj);
}
function setModifierManager(factory, obj) {
  return setInternalModifierManager(new CustomModifierManager(factory), obj);
}
function setHelperManager(factory, obj) {
  return setInternalHelperManager(new CustomHelperManager(factory), obj);
}
var TEMPLATES = /* @__PURE__ */ new WeakMap();
var getPrototypeOf = Reflect.getPrototypeOf;
function setComponentTemplate(factory, obj) {
  if (null === obj || "object" != typeof obj && "function" != typeof obj)
    throw new Error(`Cannot call \`setComponentTemplate\` on \`${debugToString$12(obj)}\``);
  if (TEMPLATES.has(obj)) throw new Error(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- @fixme
    `Cannot call \`setComponentTemplate\` multiple times on the same class (\`${debugToString$12(obj)}\`)`
  );
  return TEMPLATES.set(obj, factory), obj;
}
function getComponentTemplate(obj) {
  let pointer = obj;
  for (; null !== pointer; ) {
    let template = TEMPLATES.get(pointer);
    if (void 0 !== template) return template;
    pointer = getPrototypeOf(pointer);
  }
}

export {
  toBool,
  getPath,
  setPath,
  warnIfStyleNotTrusted,
  debugAssert,
  assertGlobalContextWasSet,
  setGlobalContext,
  associateDestroyableChild,
  registerDestructor,
  destroy,
  destroyChildren,
  _hasDestroyableChildren,
  isDestroying,
  isDestroyed,
  EMPTY_ARRAY,
  emptyArray,
  EMPTY_STRING_ARRAY,
  reverse,
  enumerate,
  dict,
  isDict,
  isIndexable,
  StackImpl,
  clearElement,
  assign,
  debug,
  INITIAL,
  valueForTag,
  validateTag,
  ALLOW_CYCLES,
  DIRTY_TAG,
  UPDATE_TAG,
  createTag,
  createUpdatableTag,
  CONSTANT_TAG,
  CURRENT_TAG,
  combine,
  beginTrackFrame,
  endTrackFrame,
  beginUntrackFrame,
  endUntrackFrame,
  resetTracking,
  isTracking,
  consumeTag,
  createCache,
  getValue,
  track,
  untrack,
  dirtyTagFor,
  tagMetaFor,
  tagFor,
  trackedData,
  createPrimitiveRef,
  UNDEFINED_REFERENCE,
  NULL_REFERENCE,
  TRUE_REFERENCE,
  FALSE_REFERENCE,
  createConstRef,
  createUnboundRef,
  createComputeRef,
  createReadOnlyRef,
  isInvokableRef,
  createInvokableRef,
  isConstRef,
  isUpdatableRef,
  valueForRef,
  updateRef,
  childRefFor,
  childRefFromParts,
  createDebugAliasRef,
  createIteratorRef,
  createIteratorItemRef,
  ContentType,
  InternalComponentCapabilities,
  ARG_SHIFT,
  MAX_SIZE,
  TYPE_SIZE,
  TYPE_MASK,
  OPERAND_LEN_MASK,
  MACHINE_MASK,
  $pc,
  $ra,
  $fp,
  $sp,
  $s0,
  $s1,
  $t0,
  $t1,
  $v0,
  isLowLevelRegister,
  getCustomTagFor,
  setCustomTagFor,
  capabilityFlagsFrom,
  managerHasCapability,
  hasCapability,
  helperCapabilities,
  setInternalModifierManager,
  getInternalModifierManager,
  setInternalHelperManager,
  getInternalHelperManager,
  setInternalComponentManager,
  getInternalComponentManager,
  hasInternalComponentManager,
  hasInternalHelperManager,
  componentCapabilities,
  modifierCapabilities,
  setComponentManager,
  setModifierManager,
  setHelperManager,
  setComponentTemplate,
  getComponentTemplate
};
//# sourceMappingURL=chunk-HJOPXKLZ.js.map
