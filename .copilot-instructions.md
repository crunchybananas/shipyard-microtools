# GitHub Copilot Instructions for FlowForge (Ember)

## Project Context
FlowForge is a visual node-based programming editor being converted from vanilla JS to Ember 6.10 with TypeScript and GTS components.

**Ember Version:** 6.10 with Embroider + Vite  
**File Format:** GTS only (`.gts` files with `<template>` tags)  
**Package Manager:** pnpm only

---

## Code Style & Conventions

### 1. Arrow Functions for All Methods
Use arrow functions instead of `@action` decorators. This ensures proper `this` binding in templates.

```typescript
// ✅ CORRECT
class MyComponent extends Component {
  handleClick = (event: MouseEvent) => {
    this.doSomething();
  };
  
  computeValue = () => {
    return this.data.map(item => item.value);
  };
}

// ❌ WRONG - Don't use @action
import { action } from '@ember/object';

class MyComponent extends Component {
  @action
  handleClick(event: MouseEvent) {
    this.doSomething();
  }
}
```

### 2. TypeScript Inference
Let TypeScript infer types when obvious. Only add explicit types when necessary for clarity.

```typescript
// ✅ CORRECT - Let inference work
const items = this.data.filter(item => item.active);
const count = items.length;

// ❌ WRONG - Unnecessary explicit types
const items: Item[] = this.data.filter((item: Item): boolean => item.active);
const count: number = items.length;
```

### 3. GTS Component Structure
Always use this structure for GTS files:

```typescript
import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import { on } from "@ember/modifier";
import { service } from "@ember/service";

// Types
export interface MyComponentSignature {
  Element: HTMLDivElement;
  Args: {
    value: string;
    onChange: (newValue: string) => void;
  };
  Blocks: {
    default: [];
  };
}

// Component class
export default class MyComponent extends Component<MyComponentSignature> {
  @service declare myService: MyService;
  
  @tracked localState = "";

  handleChange = (event: Event) => {
    const target = event.target as HTMLInputElement;
    this.args.onChange(target.value);
  };

  <template>
    <div class="my-component" ...attributes>
      <input {{on "change" this.handleChange}} />
      {{yield}}
    </div>

    <style>
      .my-component {
        /* scoped styles */
      }
    </style>
  </template>
}
```

### 4. Indentation
Use 2 spaces for indentation (matching Dockhand project conventions).

### 5. Dynamic Styles
Always use `htmlSafe` for dynamic style bindings:

```typescript
import { htmlSafe } from "@ember/template";

// ✅ CORRECT
getStyle = (x: number, y: number) => {
  return htmlSafe(`left: ${x}px; top: ${y}px`);
};

// In template:
<div style={{this.getStyle node.x node.y}}>

// ❌ WRONG - Will show XSS warning
<div style="left: {{x}}px; top: {{y}}px">
```

### 6. Custom Helpers for Multi-Arg Handlers
When a template event handler needs multiple arguments, define a local `fn` helper:

```typescript
// For 2 args
function fn<T, E extends Event>(
  handler: (arg: T, event: E) => void,
  arg: T
): (event: E) => void {
  return (event: E) => handler(arg, event);
}

// For 5 args
function fn5<T1, T2, T3, T4, E extends Event>(
  handler: (a1: T1, a2: T2, a3: T3, a4: T4, event: E) => void,
  a1: T1, a2: T2, a3: T3, a4: T4
): (event: E) => void {
  return (event: E) => handler(a1, a2, a3, a4, event);
}

// Usage in template:
{{on "click" (fn this.handleClick item.id)}}
{{on "mousedown" (fn5 this.handlePort node.id port.name true index)}}
```

### 7. Ember Modifiers
Use `ember-modifier` for complex DOM setup/teardown:

```typescript
import { modifier } from "ember-modifier";

setupCanvas = modifier((element: HTMLElement) => {
  const handleEvent = (e: Event) => { /* ... */ };
  
  element.addEventListener("event", handleEvent);
  
  return () => {
    element.removeEventListener("event", handleEvent);
  };
});

// In template:
<div {{this.setupCanvas}}></div>
```

---

## Project Structure

```
app/
├── components/           # GTS components
│   ├── feature-name.gts  # Top-level feature component
│   └── feature-name/     # Sub-components
│       ├── part-a.gts
│       └── part-b.gts
├── services/             # Ember services (plain .ts)
├── types/                # TypeScript interfaces (plain .ts)
└── styles/
    └── app.css           # Global CSS variables
```

---

## Service Pattern

```typescript
import Service from "@ember/service";
import { tracked } from "@glimmer/tracking";

export default class MyService extends Service {
  @tracked data: Item[] = [];
  @tracked isLoading = false;

  // Arrow functions for methods
  fetchData = async () => {
    this.isLoading = true;
    try {
      this.data = await fetch("/api/data").then(r => r.json());
    } finally {
      this.isLoading = false;
    }
  };
}

// Don't forget declaration merging for TypeScript
declare module "@ember/service" {
  interface Registry {
    "my-service": MyService;
  }
}
```

---

## Imports

Prefer specific imports from Ember packages:

```typescript
// ✅ CORRECT
import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import { service } from "@ember/service";
import { on } from "@ember/modifier";
import { htmlSafe } from "@ember/template";

// ❌ WRONG - Don't use barrel imports
import { Component, tracked, service } from "ember";
```

---

## Testing Patterns

```typescript
import { module, test } from "qunit";
import { setupRenderingTest } from "ember-qunit";
import { render, click } from "@ember/test-helpers";

module("Integration | Component | my-component", function (hooks) {
  setupRenderingTest(hooks);

  test("it renders", async function (assert) {
    await render(<template><MyComponent /></template>);
    assert.dom(".my-component").exists();
  });
});
```

---

## Common Gotchas

1. **Template methods need arrow functions** - Regular methods lose `this` context in templates
2. **`@tracked` triggers re-render** - Any tracked property change re-renders consuming templates
3. **Immutable updates for arrays** - Use `this.items = [...this.items, newItem]` not `this.items.push()`
4. **Service injection** - Use `@service declare myService: MyService;` with `declare`

---

## FlowForge-Specific Notes

- Node types are defined in `app/types/node-types.ts`
- Flow execution uses topological sort in `flow-engine` service
- Connection paths are SVG bezier curves
- Ports have data attributes for connection tracking: `data-node-id`, `data-port-name`, `data-is-output`
