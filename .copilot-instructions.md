# GitHub Copilot Instructions for shipyard-microtools

## Project Context
shipyard-microtools is a pnpm workspace monorepo of Ember apps — developer tools,
visualizers, and games — deployed to GitHub Pages via GitHub Actions.

**Ember Version:** 6.10 with Embroider v2 + Vite
**File Format:** GTS only (`.gts` files with `<template>` tags)
**Package Manager:** pnpm only
**Indentation:** 2 spaces

---

## Architecture: Ember-Native, Not Thin Wrappers

The #1 goal is to **use Ember the way Ember is meant to be used**. Every app
should showcase idiomatic Ember Octane patterns — reactive state, component
composition, data-driven rendering — not raw HTML glued together with
`getElementById` and `addEventListener`.

### ❌ Anti-Pattern: Thin Wrapper (`init.ts`)

Do NOT write an `init.ts` file that grabs DOM elements by ID and wires up event
listeners imperatively. This defeats the entire purpose of using Ember.

```typescript
// ❌ WRONG — This is jQuery-era thinking
export function init() {
  const btn = document.getElementById("copy-btn")!;
  const input = document.getElementById("output") as HTMLInputElement;
  btn.addEventListener("click", () => {
    navigator.clipboard.writeText(input.value);
  });
}
```

If you catch yourself writing `document.getElementById`, `querySelector`, or
`addEventListener` in app code — stop. There is almost certainly an Ember
pattern that handles it better.

### ✅ Pattern: Ember-Native Component

Let Ember own the rendering and event handling. Use `@tracked` for state,
`{{on}}` for events, `{{#each}}` for lists, and `{{#if}}` for conditionals.

```typescript
// ✅ CORRECT — Ember does the work
export default class MyTool extends Component {
  @tracked output = "";

  copy = async () => {
    await navigator.clipboard.writeText(this.output);
  };

  <template>
    <input value={{this.output}} readonly />
    <button type="button" {{on "click" this.copy}}>Copy</button>
  </template>
}
```

---

## Building a New Microtool

### 1. Component Composition — Break It Up

If your UI has distinct panels, cards, or sections, each one should be its own
component with a typed `Signature` interface. The parent composes children.

```
app/components/my-tool/
├── app.gts             # Parent — composes children, owns shared state
├── card.gts            # Reusable child — receives @args, owns local state
├── settings-panel.gts  # Another child
└── status-message.gts  # Tiny presentational component
```

Children receive data and callbacks via `@args`. They own their own local
`@tracked` state. They never reach into the parent or the DOM.

```typescript
// Parent template
<Card @data={{item}} @onAction={{this.handleAction}} />

// Child signature
interface CardSignature {
  Args: { data: ItemDef; onAction: (msg: string) => void };
}
```

### 2. Data-Driven Rendering — Use `{{#each}}`

If you have 3+ similar blocks of HTML (cards, tabs, rows), define a data
registry and render with `{{#each}}`. Never copy-paste the same HTML block.

```typescript
// ✅ CORRECT — One definition, N cards
const GENERATORS = [
  { id: "uuid4", title: "UUID v4", generate: generateUUID4 },
  { id: "nanoid", title: "Nano ID", generate: generateNanoId },
];

// In template:
{{#each this.generators as |gen|}}
  <IdCard @generator={{gen}} @onStatus={{this.showStatus}} />
{{/each}}
```

```html
<!-- ❌ WRONG — Copy-pasted blocks with different IDs -->
<div class="card" id="uuid4-card">...</div>
<div class="card" id="nanoid-card">...</div>
<div class="card" id="shortid-card">...</div>
```

### 3. Pure Utility Modules for Business Logic

Keep generator functions, parsers, encoders, and other logic in plain `.ts`
files — no Ember dependencies. Import them into components.

```
app/my-tool/
├── generators.ts   # Pure functions: generateUUID4(), etc.
├── parsers.ts      # Pure functions: parseJWT(), etc.
```

### 4. Engine / Wrapper Pattern for Canvas & WebGL

For complex Canvas/WebGL apps (games, visualizers), wrap the imperative code in
an engine class. The component owns input handling and UI state; the engine owns
the render loop.

```typescript
// engine.ts — pure class, no Ember imports
export class DriftEngine {
  start(canvas: HTMLCanvasElement, opts: Options) { /* ... */ }
  destroy() { /* ... */ }
}

// app.gts — component owns lifecycle and inputs
setupCanvas = modifier((el: HTMLCanvasElement) => {
  this.engine = new DriftEngine();
  this.engine.start(el, this.options);
  return () => this.engine.destroy();
});
```

### 5. Conditional Rendering with `{{#if}}`

Use `{{#if}}` for visibility, not CSS classes toggled by JS.

```handlebars
{{!-- ✅ CORRECT --}}
{{#if this.hasOutput}}
  <button type="button" {{on "click" this.copyAll}}>Copy All</button>
{{/if}}

{{!-- ❌ WRONG --}}
<button class={{if this.hasOutput "" "hidden"}} ...>Copy All</button>
```

### 6. Computed Getters for Derived State

Use native getters — they auto-track `@tracked` dependencies. No need for
`@computed` or manual dependency lists.

```typescript
@tracked items: Item[] = [];
@tracked filter = "";

get filteredItems() {
  return this.items.filter(i => i.name.includes(this.filter));
}

get isEmpty() {
  return this.filteredItems.length === 0;
}
```

---

## Code Style & Conventions

### Arrow Functions for All Handlers
Use fat arrow class fields instead of `@action` decorators. This ensures proper
`this` binding in templates.

```typescript
// ✅ CORRECT
handleClick = (event: MouseEvent) => {
  this.doSomething();
};

// ❌ WRONG — Don't use @action
@action handleClick(event: MouseEvent) { ... }
```

### TypeScript Inference
Let TypeScript infer types when obvious. Only add explicit types for clarity.

### GTS Component Structure
```typescript
import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import { on } from "@ember/modifier";

interface MyComponentSignature {
  Args: {
    value: string;
    onChange: (newValue: string) => void;
  };
}

export default class MyComponent extends Component<MyComponentSignature> {
  @tracked localState = "";

  handleChange = (event: Event) => {
    const target = event.target as HTMLInputElement;
    this.args.onChange(target.value);
  };

  <template>
    <div class="my-component" ...attributes>
      <input {{on "change" this.handleChange}} />
    </div>

    <style>
      .my-component { /* scoped styles */ }
    </style>
  </template>
}
```

### Dynamic Styles
Always use `htmlSafe` for dynamic style bindings:

```typescript
import { htmlSafe } from "@ember/template";

getStyle = (x: number, y: number) => {
  return htmlSafe(`left: ${x}px; top: ${y}px`);
};
```

### Multi-Arg Event Handlers
Use `{{fn}}` from `@ember/helper` or define a local `fn` helper when you need
to pass arguments to event handlers:

```handlebars
{{on "click" (fn this.switchTab tab.id)}}
```

### Ember Modifiers
Use `ember-modifier` for complex DOM setup/teardown (Canvas, resize observers,
keyboard listeners on `document`, etc.):

```typescript
import { modifier } from "ember-modifier";

setupCanvas = modifier((element: HTMLCanvasElement) => {
  const ctx = element.getContext("2d")!;
  // setup ...
  return () => { /* cleanup */ };
});
```

---

## Project Structure

```
apps/<tool-name>/
└── app/
    ├── components/
    │   └── <tool-name>/
    │       ├── app.gts           # Root component
    │       ├── child-a.gts       # Child components
    │       └── child-b.gts
    ├── <tool-name>/
    │   ├── generators.ts         # Pure utility modules
    │   └── engine.ts             # Engine class (Canvas/WebGL)
    ├── services/                 # Ember services (plain .ts)
    └── styles/
        └── app.css               # Global CSS variables
```

---

## Imports

```typescript
// ✅ CORRECT — specific package imports
import Component from "@glimmer/component";
import { tracked } from "@glimmer/tracking";
import { on } from "@ember/modifier";
import { fn } from "@ember/helper";
import { htmlSafe } from "@ember/template";
import { service } from "@ember/service";

// ❌ WRONG — barrel imports
import { Component, tracked } from "ember";
```

---

## Ember Build & Routing
- `config/environment.js`: `locationType: "hash"`, `rootURL: "./"`
- Each app must include `app/config/environment.js` using `@embroider/config-meta-loader`.
- Vite output: `../../docs/ember/<app-name>` with `base: "./"`.

---

## CI & Deployment
- GitHub Pages source is set to **GitHub Actions** (not branch).
- CI builds all apps with `--workspace-concurrency=1` to avoid `@embroider/vite`
  race conditions on shared temp dirs.
- Build artifacts (`docs/ember/`) are NOT committed to git. CI is the sole
  source of truth via `upload-pages-artifact` + `deploy-pages`.

---

## Common Gotchas

1. **Arrow functions in templates** — Regular methods lose `this` context.
2. **`@tracked` triggers re-render** — Any tracked property change re-renders.
3. **Immutable array updates** — `this.items = [...this.items, newItem]` not `.push()`.
4. **No `init.ts`** — Delete it. Move logic into the component or a utility module.
5. **Glimmer components are tagless** — No implicit root element, no built-in
   event methods. Use `{{on}}` modifier on explicit elements.
6. **Service injection** — `@service declare myService: MyService;` with `declare`.
7. **Don't read `@tracked` in modifiers that shouldn't re-run** — Ember
   auto-tracks reads inside modifier bodies. If the modifier sets up a
   long-lived resource (Canvas engine, WebSocket, etc.), reading `@tracked`
   properties will cause it to tear down and re-create on every change. Use
   literal defaults in the modifier and update via setter methods instead.

---

## App Organization

- Each microtool is a standalone Ember app under `apps/`.
- Games and complex visualizers (Canvas/WebGL) use the engine/wrapper pattern.
- When converting a vanilla app to Ember, add both **Vanilla** and **Ember**
  links on `docs/index.html`.

---

**Last Updated:** February 12, 2026
